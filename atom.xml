<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deng&#39;s Blog</title>
  <subtitle>Work Smart, Enjoy Life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://objcer.com/"/>
  <updated>2018-01-22T13:28:45.000Z</updated>
  <id>http://objcer.com/</id>
  
  <author>
    <name>小邓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习正则表达式</title>
    <link href="http://objcer.com/2018/01/22/learn-regexp/"/>
    <id>http://objcer.com/2018/01/22/learn-regexp/</id>
    <published>2018-01-22T13:26:08.000Z</published>
    <updated>2018-01-22T13:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/regex.jpg" alt=""><br>对正则表达式，我们并不陌生。在很多地方都会用到，尤其是字符串处理，正则表达式更是一把利器。本文通过一个例子来学习总结一下正则表达式的一些知识内容 🤓</p>
<a id="more"></a>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p><code>index.html</code> 页面中，有如下一段代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#000000"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>React SharedPen App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./pace/pace.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./pace/pace-theme-minimal.css"</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- SharedPen scripts --&gt;</span></div><div class="line">  <span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:5000/Utils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:5000/SharedPen.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- SharedPen stylesheet --&gt;</span></div><div class="line">  <span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://localhost:5000/SharedPen.css"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- end --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>注意这两段注释标签<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure></p>
<p>在页面在开发环境中，加载的是本地源文件，在生产环境中，我希望将其替换成压缩文件：<code>./dist/sharedpen.min.js</code> 和 <code>./dist/SharedPen.css</code>。</p>
<p><strong>解决思路是：</strong>使用 webpack 插件 <a href="https://www.npmjs.com/package/html-replace-webpack-plugin" target="_blank" rel="external">html-replace-webpack-plugin</a> 配置正则表达式，然后进行替换。最终的代码如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const HtmlReplaceWebpackPlugin = require('html-replace-webpack-plugin')</div><div class="line">const tpl = &#123;</div><div class="line">  css: '<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>',</div><div class="line">  js: '<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"%s"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>'</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // Definition for Webpack plugins</div><div class="line">  plugin: [</div><div class="line">    // Replace html contents with string or regex patterns</div><div class="line">    new HtmlReplaceWebpackPlugin([&#123;</div><div class="line">      pattern: /(<span class="comment">&lt;!--\s*)(css|js):([\w-\/\.]+)(\s*--&gt;</span>)([\s\S]*?)(<span class="comment">&lt;!--\s*end\s*--&gt;</span>)/,</div><div class="line">      replacement: function (match, $1, type, file) &#123;</div><div class="line">        switch (type) &#123;</div><div class="line">          case 'css':</div><div class="line">          case 'js':</div><div class="line">            return tpl[type].replace('%s', file)</div><div class="line">          default:</div><div class="line">            return ''</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;])</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中关键就是写出正则表达式，匹配出那两段注释代码。正则语法可以参考文末附录二，为了方便测试，我们可以在 <a href="https://regex101.com/" target="_blank" rel="external">https://regex101.com/</a> 这个网站上编写正则表达式。</p>
<h2 id="撰写正则表达式"><a href="#撰写正则表达式" class="headerlink" title="撰写正则表达式"></a>撰写正则表达式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure>
<h3 id="分成三部分处理"><a href="#分成三部分处理" class="headerlink" title="分成三部分处理"></a>分成三部分处理</h3><p>观察这两段注释，每一段可以分成三部分，根据正则语法，可以写出如下三部分的正则表达式：</p>
<ul>
<li><p>起始部分 匹配 <code>&lt;!-- js:./dist/sharedpen.min.js --&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):[\w\-\/\.]+\s*--&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>中间内容部分</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">\s</span><span class="symbol">\S</span>]*</div></pre></td></tr></table></figure>
</li>
<li><p>结束部分 匹配 <code>&lt;!-- end --&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*end\s*--&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>在第一部分 <code>&lt;!-- js:./dist/sharedpen.min.js --&gt;</code>，我们还需要正则表达式能匹配出：文件类型和文件路径</p>
<blockquote>
<p>注意到<br>1、<code>(pattern)</code> <strong>匹配 pattern 并捕获该匹配的子表达式。可以使用 $1…$9 属性从结果“匹配”集合中检索捕获的匹配。</strong><br>2、在 JavaScript 中 <code>$1…$9</code> 属性是包含括号子串匹配的正则表达式的静态只读属性，我们可以通过 <code>RegExp.$1, ..., RegExp.$9</code> 来使用它们</p>
</blockquote>
<p>通过括号写出子表达式，匹配出我们需要的内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regexp = new RegExp(/<span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>/)</div><div class="line">var str = '<span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span>'</div><div class="line">regexp.exec(str)</div><div class="line">console.log(RegExp.$1) // "js"</div><div class="line">console.log(RegExp.$2) // "./dist/sharedpen.min.js"</div></pre></td></tr></table></figure>
<h3 id="最长匹配（贪婪匹配）和最短匹配（懒惰匹配）"><a href="#最长匹配（贪婪匹配）和最短匹配（懒惰匹配）" class="headerlink" title="最长匹配（贪婪匹配）和最短匹配（懒惰匹配）"></a>最长匹配（贪婪匹配）和最短匹配（懒惰匹配）</h3><p>到目前为止，我们的正则表达式为：<code>&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;[\s\S]*&lt;!--\s*end\s*--&gt;</code>，但是会发现，此时匹配有点问题：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/51E1FD12-5B3D-4600-8EEE-C00AE4485F46.png" alt=""></p>
<p>我们是希望遇到第一个 <code>&lt;!-- end --&gt;</code> 就结束匹配，而现在却是匹配到最后一个。这个时候就需要了解正则表达式的最长匹配（贪婪匹配）和最短匹配（懒惰匹配）<br>例子一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> regexp1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>) <span class="comment">// 最长匹配</span></div><div class="line"><span class="keyword">var</span> regexp2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*?/</span>) <span class="comment">// 最短匹配</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp1.exec(str)[<span class="number">0</span>]) <span class="comment">// "abc123"</span></div><div class="line"><span class="built_in">console</span>.log(regexp2.exec(str)[<span class="number">0</span>]) <span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p>
<p>例子二：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = '<span class="comment">/*** 注释1 ****/</span> <span class="keyword">var</span> name = <span class="string">"aty"</span>; <span class="comment">/***注释2****/</span>'</div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="type">RegExp</span>(/\/\*([\s\<span class="type">S</span>]*?)\*\<span class="comment">//)</span></div><div class="line"></div><div class="line">console.log(regexp.exec(str)[<span class="number">0</span>]) <span class="comment">// 使用 `*?` 就可以正确的匹配到注释内容</span></div></pre></td></tr></table></figure></p>
<p>我们会发现，最长和最短匹配的差别是，前者匹配尽可能多的字符，后者匹配尽可能少的字符。一般正则表达式引擎默认都是最长匹配，<strong>如果想要最短匹配，那么需要在数量修饰符(例如：<code>*</code>，<code>+</code>)后面添加一个 <code>?</code> 变成最短匹配</strong></p>
<p>所以此时执行对我们的正则表达式增加一个 <code>?</code> 即可<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>[\s\S]*?<span class="comment">&lt;!--\s*end\s*--&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>JavaScript 中使用正则表达式有两种方式：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 直接量语法</span></div><div class="line">/pattern/attributes</div><div class="line"></div><div class="line"><span class="meta"># 创建 RegExp 对象的语法</span></div><div class="line"><span class="keyword">new</span> RegExp(pattern, attributes);</div></pre></td></tr></table></figure></p>
<p><strong>参数:</strong></p>
<ul>
<li>pattern 是一个字符串，指定了正则表达式</li>
<li>attributes 是一个可选的字符串，包含属性: <strong>“g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配</strong>。</li>
</ul>
<p>其中 <code>g</code> 指定正则表达式全局匹配，那么有什么特殊之处呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>, <span class="string">'g'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>其中第二次 console 输出为啥是 <code>false</code> 呢？</p>
<ul>
<li>在全局匹配模式下可以对指定要查找的字符串<strong>执行多次匹配</strong>。</li>
<li>每次匹配使用当前正则对象的 <code>lastIndex</code> 属性的值作为在目标字符串中开始查找的起始位置。</li>
<li><code>lastIndex</code> 属性的初始值为 0，找到匹配的项后，<code>lastIndex</code> 的值被重置为匹配内容的下一个字符在字符串中的位置索引，用来标识下次执行匹配时开始查找的位置。</li>
<li>如果找不到匹配的项，<code>lastIndex</code> 的值会被设置为 0。</li>
<li>没有设置正则对象的全局匹配标志时 <code>lastIndex</code> 属性的值始终为0，每次执行匹配仅查找字符串中第一个匹配的项。</li>
</ul>
<p>如果我们每次执行 <code>regexp.test(str)</code> 方法后，查看一下正则对象的 lastIndex 属性的值，就清楚了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>, <span class="string">'g'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>第一次执行 <code>regexp.test(str)</code> 前，正则对象的 <code>lastIndex</code> 属性值为 0，匹配到字符 <code>abc123</code> 后，正则对象的 <code>lastIndex</code> 属性值变成 6；<br>在第二次执行 <code>regexp.test(str)</code> 时，从第 7 个字符(从0开始)开始进行匹配，当然就匹配失败啦。</p>
<p>下面再来看看正则对象的另一个方法 <code>exec</code> 在全局模式下的例子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var str = `</div><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span>`</div><div class="line"></div><div class="line">var regexp = new RegExp(/<span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>[\s\S]*?<span class="comment">&lt;!--\s*end\s*--&gt;</span>/g)</div><div class="line">var matches</div><div class="line">while((matches = regexp.exec(str)) != null) &#123;</div><div class="line">  str = str.replace(matches[0], '<span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span>')</div><div class="line">&#125;</div><div class="line">console.log(str)</div></pre></td></tr></table></figure></p>
<p>我们希望代码执行匹配替换后，输出结果是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span>&gt;<span class="keyword">test</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;<span class="keyword">div</span>&gt;<span class="keyword">test</span>&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>但是实际上输出结果是：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure></p>
<p>显然是第二次匹配替换出问题了。有了前面的经验，我们很快就知道，是全局模式匹配的问题，第一次全局匹配后，正则对象的 <code>lastIndex</code> 属性值发生变化，影响了第二次正则匹配，我们只需去掉全局匹配 <code>g</code> 即可解决问题。</p>
<p>🏗 至此，我们终于可以得到如下的正则表达式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(<span class="comment">&lt;!--\s*)(css|js):([\w-\/\.]+)(\s*--&gt;</span>)([\s\S]*?)(<span class="comment">&lt;!--\s*end\s*--&gt;</span>)/</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="附录一-常用方法"><a href="#附录一-常用方法" class="headerlink" title="[附录一] 常用方法"></a>[附录一] 常用方法</h2><p>RegExp 对象方法：<code>test</code>, <code>exec</code></p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RegExpObj.test(string)</code></td>
<td>用于检测一个字符串是否匹配某个模式</td>
<td>匹配返回 true，否则返回 false</td>
</tr>
<tr>
<td><code>RegExpObj.exec(string)</code></td>
<td>用于检索字符串中的正则表达式的匹配</td>
<td>返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</td>
</tr>
</tbody>
</table>
<p>String 对象方法：<code>match</code>, <code>replace</code></p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stringObj.match( regexp/substr )</code></td>
<td>在字符串内检索指定的值，或找到一个或多个正则表达式的匹配</td>
<td>返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</td>
</tr>
<tr>
<td><code>stringObj.replace( regexp/substr, replacement )</code></td>
<td>根据 regexp/substr 进行正则匹配,把匹配结果替换为 replacement</td>
<td>一个新的字符串</td>
</tr>
</tbody>
</table>
<h2 id="附录二-正则表达式语法"><a href="#附录二-正则表达式语法" class="headerlink" title="[附录二] 正则表达式语法"></a>[附录二] 正则表达式语法</h2><p>学习正则表达式，首先要了解其语法规则，以下规则来自：<strong>MSDN 正则表达式语法:</strong> <a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx</a></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。</strong>例如，“n” 匹配字符 “n”。“\n” 匹配换行符。序列 “\” 匹配 “\”，“(” 匹配 “(”。</td>
</tr>
<tr>
<td><code>^</code></td>
<td><strong>匹配输入字符串开始的位置。</strong>如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 “\n” 或 “\r” 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td><strong>匹配输入字符串结尾的位置。</strong>如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 “\n” 或 “\r” 之前的位置匹配。</td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>零次或多次匹配前面的字符或子表达式。</strong>例如，zo<em> 匹配 “z” 和 “zoo”。</em> 等效于 {0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td><strong>一次或多次匹配前面的字符或子表达式。</strong>例如，“zo+” 与 “zo” 和 “zoo” 匹配，但与 “z” 不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>零次或一次匹配前面的字符或子表达式。</strong>例如，“do(es)?” 匹配 “do” 或 “does” 中的 “do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td><strong>n 是非负整数。正好匹配 n 次。</strong>例如，“o{2}” 与 “Bob” 中的 “o” 不匹配，但与 “food” 中的两个“o”匹配。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td><strong>n 是非负整数。至少匹配 n 次。</strong>例如，“o{2,}” 不匹配 “Bob” 中的 “o”，而匹配 “foooood” 中的所有 o。“o{1,}” 等效于 “o+”。“o{0,}” 等效于 “o*”。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 是非负整数，其中 n &lt;= m。<strong>匹配至少 n 次，至多 m 次。</strong>例如，“o{1,3}” 匹配 “fooooood” 中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。</strong>例如，在字符串 “oooo” 中，“o+?” 只匹配单个 “o”，而 “o+” 匹配所有 “o”。</td>
</tr>
<tr>
<td><code>.</code></td>
<td><strong>匹配除“\n”之外的任何单个字符。</strong>若要匹配包括 “\n” 在内的任意字符，请使用诸如 “[\s\S]” 之类的模式。</td>
</tr>
<tr>
<td><code>(pattern)</code></td>
<td><strong>匹配 pattern 并捕获该匹配的子表达式。可以使用 $1…$9 属性从结果“匹配”集合中检索捕获的匹配。</strong>若要匹配括号字符 ( )，请使用“(”或者“)”。</td>
</tr>
<tr>
<td><code>(?:pattern)</code></td>
<td>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用 “or” 字符 <code>(│)</code> 组合模式部件的情况很有用。例如，<code>industr(?:y│ies)</code> 是比 <code>industry│industries</code> 更经济的表达式。</td>
</tr>
<tr>
<td><code>(?=pattern)</code></td>
<td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95│98│NT│2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td><code>(?!pattern)</code></td>
<td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95│98│NT│2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td><code>x│y</code></td>
<td><strong>匹配 x 或 y。</strong>例如，’z│food’ 匹配“z”或“food”。’(z│f)ood’ 匹配“zood”或“food”。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td>字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td><strong>字符范围。</strong>匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</td>
</tr>
<tr>
<td><code>[^a-z]</code></td>
<td><strong>反向范围字符。</strong>匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</td>
</tr>
<tr>
<td><code>\cx</code></td>
<td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td><strong>数字字符匹配。</strong>等效于 [0-9]。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td><strong>非数字字符匹配。</strong>等效于 [^0-9]。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td><strong>匹配任何空白字符，包括空格、制表符、换页符等。</strong>与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td><strong>匹配任何非空白字符。</strong>与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td><code>\xn</code></td>
<td>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td><code>\num</code></td>
<td>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td>
</tr>
<tr>
<td><code>\nm</code></td>
<td>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td><code>\nml</code></td>
<td>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td>
</tr>
<tr>
<td><code>\un</code></td>
<td>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody>
</table>
<p>正则表达式从左往右进行计算，运算符的优先级顺序如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>(), (?:), (?=), []</code></td>
<td>括号和中括号</td>
</tr>
<tr>
<td><code>*, +, ?, {n}, {n,}, {n,m}</code></td>
<td>限定符</td>
</tr>
<tr>
<td><code>^, $, \ 任何元字符、任何字符</code></td>
<td>定位点和序列</td>
</tr>
<tr>
<td>│</td>
<td>替换</td>
</tr>
</tbody>
</table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">JavaScript RegExp 对象</a><br><a href="https://segmentfault.com/a/1190000003497780" target="_blank" rel="external">JS 进阶 test, exec, match, replace</a><br><a href="https://regex101.com/" target="_blank" rel="external">正则匹配在线网站</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/regex.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;对正则表达式，我们并不陌生。在很多地方都会用到，尤其是字符串处理，正则表达式更是一把利器。本文通过一个例子来学习总结一下正则表达式的一些知识内容 🤓&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="正则表达式" scheme="http://objcer.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中的 UnhandledPromiseRejectionWarning 问题</title>
    <link href="http://objcer.com/2017/12/27/unhandled-promise-rejections-in-node-js/"/>
    <id>http://objcer.com/2017/12/27/unhandled-promise-rejections-in-node-js/</id>
    <published>2017-12-27T09:25:07.000Z</published>
    <updated>2017-12-27T09:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>问题引入：</em>今天在 Gulp 构建任务中出现一个 html 解析错误，但是并没有报错，也没有中断 gulp 构建任务的执行，而是出现 <code>UnhandledPromiseRejectionWarning</code> 的警告，所以会误以为构建成功，这篇文章将对此进行探究并解决该问题。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="string">node:</span><span class="number">24866</span>) <span class="string">UnhandledPromiseRejectionWarning:</span> Unhandled promise rejection (rejection <span class="string">id:</span> <span class="number">2</span>): Error <span class="keyword">in</span> plugin <span class="string">'gulp-posthtml'</span></div><div class="line"><span class="string">Message:</span></div><div class="line">  Parse <span class="string">Error:</span> &lt;img id=<span class="string">"titleIcon"</span> <span class="class"><span class="keyword">class</span>$="&#123;</span>&#123;getStypeType_(info.stype)&#125;&#125;<span class="string">" src$="</span>&#123;&#123;getTitleIcon_(<span class="keyword">in</span></div><div class="line">  ...</div><div class="line">(<span class="string">node:</span><span class="number">24866</span>) [DEP0018] <span class="string">DeprecationWarning:</span> Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="关于-Unhandled-Rejection"><a href="#关于-Unhandled-Rejection" class="headerlink" title="关于 Unhandled Rejection"></a>关于 Unhandled Rejection</h2><p>一个 Promise 是一个异步操作的状态机，其可能处于这三种状态之一</p>
<ul>
<li><code>pending</code>：异步操作还在执行中</li>
<li><code>fulfilled</code>：异步操作已经完成</li>
<li><code>rejected</code>：异步操作执行失败</li>
</ul>
<blockquote>
<p>Node.js 6.6.0 added a sporadically useful bug/feature: <strong>logging unhandled promise rejections to the console by default.</strong></p>
</blockquote>
<p>在 Node.js 6.6.0 中增加了一个特性：对 Promise 中未处理的 rejection 默认会输出 <code>UnhandledPromiseRejectionWarning</code> 提示</p>
<p>例如：<code>test.js</code> 中有如下代码：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="string">'woops'</span>), <span class="number">500</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>node test.js</code> 执行：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47122</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">1</span>): error</div><div class="line">(<span class="keyword">node</span><span class="title">:47122</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code</div></pre></td></tr></table></figure></p>
<p>另一种情况是直接在 Promise 中抛出异常：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception!'</span>); &#125;);</div></pre></td></tr></table></figure></p>
<p>执行后也会有 <code>UnhandledPromiseRejectionWarning</code> 的警告：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47657</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">1</span>): Error: exception!</div><div class="line">(<span class="keyword">node</span><span class="title">:47657</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code.</div></pre></td></tr></table></figure></p>
<p>Promise API 中有 <code>.catch()</code> 这个方法，可以用来处理捕捉 rejection 进行处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="string">'error'</span>), <span class="number">500</span>);</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'caught'</span>, error))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception!'</span>); &#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'caught'</span>, error.message))</div></pre></td></tr></table></figure></p>
<p>但是注意：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'caught'</span>, err.message); &#125;);</div></pre></td></tr></table></figure></p>
<p>这个例子中虽然用 <code>.catch()</code> 捕捉处理了 Promise 中的 rejection；但是注意在 <code>err.message</code> 中的 <code>err</code> 是未定义的，代码执行时会抛出错误，由于没有后续的处理，所以也会输出 <code>UnhandledPromiseRejectionWarning</code> 的警告</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47918</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">2</span>): ReferenceError: err is not <span class="keyword">defined</span></div><div class="line">(<span class="keyword">node</span><span class="title">:47918</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code.</div></pre></td></tr></table></figure>
<p>所以稍不注意就会引起 Promise 中的 <strong>unhandled rejections</strong> 😨</p>
<h2 id="unhandledRejection-事件"><a href="#unhandledRejection-事件" class="headerlink" title="unhandledRejection 事件"></a><code>unhandledRejection</code> 事件</h2><p>在 node <code>process</code> 中有一个 <code>unhandledRejection</code> 事件，当没有对 Promise 的 rejection 进行处理就会抛出这个事件（这只对原生 Promise 有效）</p>
<blockquote>
<p>The <strong>unhandledrejection</strong> event is fired when a JavaScript Promise is rejected but there is no rejection handler to deal with the rejection.</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// Will print "unhandledRejection err is not defined"</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'unhandledRejection'</span>, error.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'caught'</span>, err.message); &#125;);</div></pre></td></tr></table></figure>
<p>此时执行后，就没有 <code>UnhandledPromiseRejectionWarning</code> 的警告输出了，只输出：<code>unhandledRejection err is not defined</code></p>
<p>如果我们不想监听 <code>unhandledRejection</code> 事件，也不想看到 <code>UnhandledPromiseRejectionWarning</code> 的警告输出，怎么办呢？<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">Promise</span>((<span class="literal">_</span>, reject) =&gt; reject(<span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.<span class="keyword">catch</span>(<span class="keyword">new</span> <span class="type">Function</span>());</div></pre></td></tr></table></figure></p>
<p>我们可以在 <code>.catch()</code> 中传入一个空函数，假装对 rejection 进行了处理，这样也没有触发 <code>unhandledRejection</code> 事件</p>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>关于 Async/Await，可以参考文章：<a href="https://objcer.com/2017/10/11/Async-Await/">ES7 中的 async await</a>，在这篇文章中详细介绍了 Async/Await 并且和 Promise 进行了对比，Async/Await 在处理异步操作上的优势更明显。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// No unhandled rejection!</span></div><div class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// (node:54358) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 3): Error: test</span></div><div class="line"><span class="comment">// (node:54358) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span></div><div class="line"></div><div class="line">test().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error.message));</div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// test</span></div></pre></td></tr></table></figure>
<p>async 异步函数返回的是 Promise，所以执行异步函数后，统一需要用 <code>.catch()</code> 对可能出现的 rejection 进行捕捉处理，否则统一也是会出现 <code>UnhandledPromiseRejectionWarning</code> 的警告</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后解决一下文章开头的问题：构建任务中 html 解析错误，出现了一个 Unhandled Rejection，所以我们可以添加一个 <code>unhandledRejection</code> 事件监听，直接退出：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'unhandledRejection'</span>, error =&gt; &#123;</div><div class="line">  console.error(<span class="string">'unhandledRejection'</span>, error);</div><div class="line">  process.<span class="keyword">exit</span>(<span class="number">1</span>) <span class="regexp">//</span> To <span class="keyword">exit</span> with a <span class="string">'failure'</span> code</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://thecodebarbarian.com/unhandled-promise-rejections-in-node.js.html" target="_blank" rel="external">Unhandled Promise Rejections in Node.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;问题引入：&lt;/em&gt;今天在 Gulp 构建任务中出现一个 html 解析错误，但是并没有报错，也没有中断 gulp 构建任务的执行，而是出现 &lt;code&gt;UnhandledPromiseRejectionWarning&lt;/code&gt; 的警告，所以会误以为构建成功，这篇文章将对此进行探究并解决该问题。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;string&quot;&gt;node:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24866&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;UnhandledPromiseRejectionWarning:&lt;/span&gt; Unhandled promise rejection (rejection &lt;span class=&quot;string&quot;&gt;id:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;): Error &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; plugin &lt;span class=&quot;string&quot;&gt;&#39;gulp-posthtml&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;Message:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Parse &lt;span class=&quot;string&quot;&gt;Error:&lt;/span&gt; &amp;lt;img id=&lt;span class=&quot;string&quot;&gt;&quot;titleIcon&quot;&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;$=&quot;&amp;#123;&lt;/span&gt;&amp;#123;getStypeType_(info.stype)&amp;#125;&amp;#125;&lt;span class=&quot;string&quot;&gt;&quot; src$=&quot;&lt;/span&gt;&amp;#123;&amp;#123;getTitleIcon_(&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;string&quot;&gt;node:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24866&lt;/span&gt;) [DEP0018] &lt;span class=&quot;string&quot;&gt;DeprecationWarning:&lt;/span&gt; Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Promise" scheme="http://objcer.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>探究数据绑定（2）ES6 Proxy</title>
    <link href="http://objcer.com/2017/10/31/Data-Binding-with-ES6-Proxies/"/>
    <id>http://objcer.com/2017/10/31/Data-Binding-with-ES6-Proxies/</id>
    <published>2017-10-31T07:25:45.000Z</published>
    <updated>2017-10-31T07:27:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/data-binding-with-es6-proxy.png" alt=""><br>在上一篇文章：<a href="https://objcer.com/2017/10/27/Data-binding-introduction/">探究数据绑定（1）脏检查和存取器方法</a> 中，探究了 ES5 中实现数据绑定的两种方式；而在本文中，将会探究使用 ES6 Proxy 实现数据绑定。</p>
<a id="more"></a>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>Proxy 方式实现数据绑定中涉及到 Proxy、Reflect、Set、Map 和 WeakMap，这些都是 ES6 的新特性。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 对象代理，在目标对象之前架设一层拦截，外部对目标对象的操作，都会通过这层拦截，我们可以定制拦截行为，每一个被代理的拦截行为都对应一个处理函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let p = <span class="keyword">new</span> Proxy(<span class="keyword">target</span>, <span class="keyword">handler</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> handler = &#123;</div><div class="line">  get: (target, name, recevier) =&gt; &#123;</div><div class="line">    return <span class="string">'proxy'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = new Proxy(&#123;&#125;, handler)</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.a</span> = <span class="number">1</span></div><div class="line"></div><div class="line">console.log(<span class="selector-tag">p</span><span class="selector-class">.a</span>, <span class="selector-tag">p</span>.c) <span class="comment">// -&gt; proxy proxy</span></div></pre></td></tr></table></figure>
<p>Proxy 构造函数接收两个参数：</p>
<ul>
<li>第一个参数是要代理的目标对象</li>
<li>第二个参数是配置对象，每一个被代理的操作都对应一个处理函数</li>
</ul>
<p>在这个例子中，目标对象是一个空对象，配置对象中有一个 <code>get</code> 函数，用来拦截外部对目标对象属性的访问，可以看到，<code>get</code> 函数始终返回 <code>proxy</code>。</p>
<p>Proxy 支持拦截的操作一共有13种：</p>
<ul>
<li>get(target, propKey, receiver)</li>
<li>set(target, propKey, value, receiver)</li>
<li>has(target, propKey)</li>
<li>deleteProperty(target, propKey)</li>
<li>ownKeys(target)</li>
<li>getOwnPropertyDescriptor(target, propKey)</li>
<li>defineProperty(target, propKey, propDesc)</li>
<li>preventExtensions(target)</li>
<li>getPrototypeOf(target)</li>
<li>isExtensible(target)</li>
<li>setPrototypeOf(target, proto)</li>
<li>apply(target, object, args)</li>
<li>construct(target, args)</li>
</ul>
<blockquote>
<p>👉 更详细介绍参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">MDN·Proxy</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="external">Proxy</a></p>
</blockquote>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>Reflect 对象同 Proxy 对象一样，也是 ES6 为了操作对象而提供的新特性。</p>
<p>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的静态方法（Reflect 对象没有构造函数，不能使用 new 创建实例）。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> handler = &#123;</div><div class="line">  get: (target, name, recevier) =&gt; &#123;</div><div class="line">    console.log(<span class="string">'get: '</span>, name)</div><div class="line">    Reflect.get(target, name)</div><div class="line">  &#125;,</div><div class="line">  set: (target, name, value, recevier) =&gt; &#123;</div><div class="line">    console.log(<span class="string">'set: '</span>, name)</div><div class="line">    Reflect.get(target, name, value)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = new Proxy(&#123;&#125;, handler)</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.a</span> = <span class="number">1</span></div><div class="line"></div><div class="line">console.log(<span class="selector-tag">p</span><span class="selector-class">.a</span>, <span class="selector-tag">p</span>.c)</div></pre></td></tr></table></figure></p>
<p>代码执行结果，输出：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>:  <span class="keyword">a</span></div><div class="line"><span class="built_in">get</span>:  <span class="keyword">a</span></div><div class="line"><span class="built_in">get</span>:  c</div></pre></td></tr></table></figure></p>
<p>上面代码中，Proxy 拦截目标对象的 <code>get</code> 和 <code>set</code>方法，在其中定制拦截行为，最后采用 <code>Reflect.get</code> 和 <code>Reflect.set</code> 分别完成目标对象默认的属性获取和设置行为。</p>
<blockquote>
<p>👉 更详细介绍参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="external">MDN·Reflect</a><br><a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">Reflect</a></p>
</blockquote>
<h3 id="Set-WeakSet-和-Map-WeakMap"><a href="#Set-WeakSet-和-Map-WeakMap" class="headerlink" title="Set/WeakSet 和 Map/WeakMap"></a>Set/WeakSet 和 Map/WeakMap</h3><p><strong>Set</strong></p>
<ul>
<li>类似 Array 数组</li>
<li>Set 允许你存储任何类型的唯一值，无论是原始值或者是对象引用</li>
<li>Set 成员的值都是唯一的，没有重复值</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li>类似 Set，也是不重复元素的集合</li>
<li>WeakSet 对象中只能存放对象值, 不能存放原始值, 而 Set 对象都可以</li>
<li>WeakSet 对象中存储的<strong>对象值都是被弱引用的</strong>, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>类似 Object 对象，保存键值对</li>
<li>Map 任何值(对象或者原始值) 都可以作为一个键(key)或一个值(value)，而 Object 对象的 key 键值只能是字符串</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li>类似 Map，也是一组键值对的集合</li>
<li>WeakMap 对象中的<strong>键是弱引用的</strong>。键必须是对象，值可以是任意值</li>
<li>由于这样的弱引用，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用，原理同 WeakSet</li>
<li>WeakMap 的 key 是非枚举的</li>
</ul>
<h2 id="Proxy-实现数据绑定"><a href="#Proxy-实现数据绑定" class="headerlink" title="Proxy 实现数据绑定"></a>Proxy 实现数据绑定</h2><p>先上完整代码 👉<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听对象集合</span></div><div class="line"><span class="keyword">var</span> observers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="comment">// 待执行监听函数集合，Set 可以避免重复</span></div><div class="line"><span class="keyword">var</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line"><span class="comment">// 当前监听函数</span></div><div class="line"><span class="keyword">var</span> currentObserver</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  observers.set(obj, <span class="keyword">new</span> <span class="built_in">Map</span>())</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123; get, set &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">  <span class="comment">// get 方法默认行为</span></div><div class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver)</div><div class="line">  <span class="comment">// 当前监听函数中，监听使用了该属性，</span></div><div class="line">  <span class="comment">// 那么把该 监听函数 存放到该属性对应的 对象属性监听函数集合 Set</span></div><div class="line">  <span class="keyword">if</span> (currentObserver) &#123;</div><div class="line">    registerObserver(target, key, currentObserver)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerObserver</span>(<span class="params">target, key, observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> observersForKey = observers.get(target).get(key)</div><div class="line">  <span class="comment">// 为每一个对象属性都创建一个 Set 集合，存放监听了该属性的监听函数</span></div><div class="line">  <span class="keyword">if</span> (!observersForKey) &#123;</div><div class="line">    observersForKey = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">    observers.get(target).set(key, observersForKey)</div><div class="line">  &#125;</div><div class="line">  observersForKey.add(observer)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> observersForKey = observers.get(target).get(key)</div><div class="line">  <span class="comment">// 修改对象属性，即对象属性值发生变更时，</span></div><div class="line">  <span class="comment">// 判断 对象属性监听函数集合 Set 是否存在，将其中的所有监听函数都添加到 待执行监听函数集合</span></div><div class="line">  <span class="keyword">if</span> (observersForKey) &#123;</div><div class="line">    observersForKey.forEach(queueObserver)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// set 方法默认行为</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  queueObserver(fn)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将监听函数添加到 待执行监听函数集合 Set 中</span></div><div class="line"><span class="comment">// 如果 待执行监听函数集合 Set 为空，那么在添加后立即执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueObserver</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (queuedObservers.size === <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 异步执行</span></div><div class="line">    <span class="built_in">Promise</span>.resolve().then(runObservers)</div><div class="line">  &#125;</div><div class="line">  queuedObservers.add(observer)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 执行 待执行监听函数集合 Set 中的监听函数</span></div><div class="line"><span class="comment">// 执行完毕后，进行清理工作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runObservers</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    queuedObservers.forEach(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">      currentObserver = observer</div><div class="line">      observer()</div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    currentObserver = <span class="literal">undefined</span></div><div class="line">    queuedObservers.clear()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对外暴露的 <code>observable(obj)</code> 和 <code>observe(fn)</code> 方法二者分别用于创建 observable 监听对象和 observer 监听回调函数。当 observable 监听对象发生属性变化时，observer 函数将自动执行。</p>
<p>测试用例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;</div><div class="line"><span class="comment">// observable object</span></div><div class="line"><span class="keyword">var</span> person = observable(obj)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`监听属性发生变化：<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// observer function</span></div><div class="line">observe(print)</div></pre></td></tr></table></figure></p>
<h3 id="分析接口方法"><a href="#分析接口方法" class="headerlink" title="分析接口方法"></a>分析接口方法</h3><p>关于 <code>observable(obj)</code> 和 <code>observe(fn)</code>：<br><strong><code>observable(obj)</code> 方法中，通过 ES6 Proxy 为目标对象 <code>obj</code> 创建代理，拦截 <code>get</code> 和 <code>set</code> 操作</strong></p>
<ul>
<li>当前监听函数：<code>currentObserver</code></li>
<li>待执行监听函数集合 Set：<code>var queuedObservers = new Set()</code></li>
<li>监听对象集合 WeakMap：<code>var observers = new WeakMap()</code> 键值为监听对象</li>
<li>对象属性监听函数集合 Set：监听了对象属性的监听函数，都保存到对象属性监听函数集合 Set 中，方便在对象属性发生变更时，执行监听函数</li>
<li>拦截方法 <code>get</code>：使用 <code>obj.property</code> 获取对象属性，即会被拦截方法 <code>get</code> 拦截<br>👉 查看 <code>get</code> 中的注释</li>
<li>拦截方法 <code>set</code>：使用 <code>obj.property = value</code> 设置对象属性，即会被拦截方法 <code>set</code> 拦截<br>👉 查看 <code>set</code> 中的注释</li>
</ul>
<p><strong><code>observe(fn)</code> 方法中，添加对象属性监听函数</strong><br>  监听函数中使用 <code>obj.property</code> 获取对象属性，即表明监听函数监听了该属性，那么就会触发拦截方法 <code>get</code> 中对监听属性的逻辑处理，为其创建对象属性监听函数集合 Set，并将当前的监听函数添加进其中</p>
<h3 id="分析测试用例"><a href="#分析测试用例" class="headerlink" title="分析测试用例"></a>分析测试用例</h3><p>下面通过流程图讲解一下测试用例的执行过程<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/es6-proxy-observables-code.png" alt=""></p>
<ul>
<li>通过 <code>observable</code> 方法创建代理对象 <code>person</code></li>
<li><code>observe</code> 方法设置监听函数，此时待执行监听函数集合 Set 为空，监听函数添加到 Set 中后执行待执行监听函数集合 Set 中的监听函数</li>
<li>在 <code>runObservers</code> 方法中当前监听函数 <code>currentObserver</code> 被设为 <code>print</code></li>
<li><code>print</code> 开始执行</li>
<li>在 <code>print</code> 内部检索到 <code>person.name</code></li>
<li>在 <code>person</code> 上触发拦截方法 <code>get</code></li>
<li><code>observers.get(person).get(&#39;name&#39;)</code> 检索到 <code>(person, name)</code> 组合的对象属性监听函数集 Set</li>
<li>当前监听函数 <code>print</code> 被添加到对象属性监听函数集 Set 中</li>
<li>对于 <code>person.age</code>，同理，执行前面在 <code>print</code> 内部检索到 <code>person.name</code> 的流程</li>
<li><code>${person.name}, ${person.age}</code> 打印出来；</li>
<li><code>print</code> 函数执行结束；</li>
<li>当前监听函数 <code>currentObserver</code> 变为 <code>undefined</code></li>
</ul>
<p>当调用 <code>person.age = 22</code> 修改对象属性时：</p>
<ul>
<li><code>person</code> 上触发拦截方法 <code>set</code></li>
<li><code>observers.get(person).get(&#39;age&#39;)</code> 检索到 <code>(person, age)</code> 组合的对象属性监听函数集 Set</li>
<li>对象属性监听函数集 Set 中的监听函数（包括 <code>print</code>）入待执行监听函数集合，准备执行</li>
<li>再次执行 <code>print</code></li>
</ul>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="动态-observable-tree"><a href="#动态-observable-tree" class="headerlink" title="动态 observable tree"></a>动态 observable tree</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'John'</span>,</div><div class="line">  age: <span class="number">20</span>,</div><div class="line">  teacher: &#123;</div><div class="line">    name: <span class="string">'Tom'</span>,</div><div class="line">    age: <span class="number">30</span></div><div class="line">&#125;&#125;</div><div class="line"><span class="comment">// observable object</span></div><div class="line"><span class="selector-tag">var</span> person = observable(obj)</div><div class="line"></div><div class="line">function print () &#123;</div><div class="line">  console.log(`监听属性发生变化：$&#123;person<span class="selector-class">.teacher</span><span class="selector-class">.name</span>&#125;, $&#123;person<span class="selector-class">.teacher</span><span class="selector-class">.age</span>&#125;`)</div><div class="line">&#125;</div><div class="line"><span class="comment">// observer function</span></div><div class="line"><span class="function"><span class="title">observe</span><span class="params">(print)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; &#123;person<span class="selector-class">.teacher</span><span class="selector-class">.name</span> = <span class="string">'Jack'</span>&#125;)</div></pre></td></tr></table></figure>
<p>到目前为止，单层对象的数据绑定监听是正常工作的。但是在这个例子中，我们监听的对象值又是对象，这个时候监听就失效了，我们需要将：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">observable</span>(&#123;<span class="attribute">data</span>: &#123;name: <span class="string">'John'</span>&#125;&#125;)</div></pre></td></tr></table></figure></p>
<p>替换成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">observable</span>(&#123;<span class="attribute">data</span>: <span class="built_in">observable</span>(&#123;name: <span class="string">'John'</span>&#125;)&#125;)</div></pre></td></tr></table></figure></p>
<p>这样就能正常运行了 😋</p>
<p>显然，这样使用不方便，可以做拦截方法 <code>get</code> 中修改一下，在返回值是对象时，对返回值对象也调用 <code>observable(obj)</code> 为其创建监听对象。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function <span class="built_in">get</span>(target, <span class="built_in">key</span>, receiver) &#123;</div><div class="line">  <span class="keyword">const</span> result = Reflect.<span class="built_in">get</span>(target, <span class="built_in">key</span>, receiver)</div><div class="line">  <span class="keyword">if</span> (currentObserver) &#123;</div><div class="line">    registerObserver(target, <span class="built_in">key</span>, currentObserver)</div><div class="line">    <span class="keyword">if</span> (typeof result === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">const</span> observableResult = observable(result)</div><div class="line">      Reflect.<span class="built_in">set</span>(target, <span class="built_in">key</span>, observableResult, receiver)</div><div class="line">      <span class="keyword">return</span> observableResult</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>对于 Proxy 拦截操作也可以在原型链中被继承，例如：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let proto = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get(target, propertyKey, receiver) &#123;</div><div class="line">    console.log('GET ' + propertyKey);</div><div class="line">    return Reflect.get(target, propertyKey, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">let obj = Object.create(proto);</div><div class="line">obj.foo // <span class="string">"<span class="keyword">GET</span> foo"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，拦截操作 <code>get</code> 定义在原型对象上面，所以如果读取 <code>obj</code> 对象属性时，拦截会生效。</p>
<p>同理，通过 Proxy 实现的数据绑定也能与原型继承搭配工作，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const parent = observable(&#123;greeting: <span class="string">'Hello'</span>&#125;)</div><div class="line">const child = observable(&#123;subject: <span class="string">'World!'</span>&#125;)</div><div class="line">Object.setPrototypeOf(child, parent)</div><div class="line"></div><div class="line">function print () &#123;</div><div class="line">  console.log(`$&#123;child.greeting&#125; $&#123;child.subject&#125;`)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hello World!'</span></div><div class="line"><span class="function"><span class="title">observe</span><span class="params">(print)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hello There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; child<span class="selector-class">.subject</span> = <span class="string">'There!'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hey There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; parent<span class="selector-class">.greeting</span> = <span class="string">'Hey'</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Look There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; child<span class="selector-class">.greeting</span> = <span class="string">'Look'</span>, <span class="number">200</span>)</div></pre></td></tr></table></figure></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文中通过简单的代码展示了 Proxy 实现数据绑定，更加完整的实现，参考：<a href="https://github.com/nx-js/observer-util" target="_blank" rel="external">nx-js/observer-util</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/" target="_blank" rel="external">Writing a JavaScript Framework - Data Binding with ES6 Proxies</a><br><a href="http://www.zcfy.cc/article/writing-a-javascript-framework-data-binding-with-es6-proxies-risingstack-1655.html" target="_blank" rel="external">使用 ES6 Proxy 实现数据绑定</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/data-binding-with-es6-proxy.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在上一篇文章：&lt;a href=&quot;https://objcer.com/2017/10/27/Data-binding-introduction/&quot;&gt;探究数据绑定（1）脏检查和存取器方法&lt;/a&gt; 中，探究了 ES5 中实现数据绑定的两种方式；而在本文中，将会探究使用 ES6 Proxy 实现数据绑定。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="数据绑定" scheme="http://objcer.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
      <category term="Proxy" scheme="http://objcer.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>探究数据绑定（1）脏检查和存取器方法</title>
    <link href="http://objcer.com/2017/10/27/Data-binding-introduction/"/>
    <id>http://objcer.com/2017/10/27/Data-binding-introduction/</id>
    <published>2017-10-27T02:30:21.000Z</published>
    <updated>2017-10-27T02:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Data binding is a general technique that binds data sources from the provider and consumer together and synchronizes them.</strong></p>
</blockquote>
<p>在前端组件化框架中，基本都有<strong>数据绑定</strong>这一特性，数据绑定是将生产者的数据源绑定到消费者，并负责数据同步。本文将探究数据绑定的不同实现方式。🤓</p>
<p>目前主要有以下几种实现方案：</p>
<ul>
<li><strong>脏检查（dirty check）</strong></li>
<li><strong>存取器方法（accessor method）</strong>: <code>Object.defineProperty</code> ES5</li>
<li><code>Proxy</code>: ES6 支持较差【Proxies are one of the few non polyfillable additions.（babel不支持转换）】</li>
<li><code>Object.observe</code>: ES7，已经移出草案，不支持</li>
<li><code>object.watch</code>: 目前只有基于gecko的浏览器如火狐支持,官方建议仅供调试用</li>
</ul>
<p>其中前两种方式是主流，angular、Polymer 使用的就是脏检查，Vue 使用的就是存取器方法。</p>
<a id="more"></a>
<h2 id="脏检查（dirty-check）"><a href="#脏检查（dirty-check）" class="headerlink" title="脏检查（dirty check）"></a>脏检查（dirty check）</h2><p>通过一个例子来阐述脏检查的原理：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> provider = &#123;</div><div class="line">  message: <span class="string">'Hello World'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> consumer = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</div><div class="line"></div><div class="line">observe(provider, <span class="string">'message'</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</div><div class="line">  consumer.innerHTML = message</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>定义一个 <code>provider</code> 对象作为生产者，DOM 节点 <code>consumer</code> 作为消费者，通过 <code>observe</code> 监听，生产者数据的变更会反映到消费者上，这样也就简单的实现了数据绑定，即生产者数据绑定到了消费者上。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> <span class="params">(provider, prop, handler)</span> </span>&#123;</div><div class="line">  provider._handlers[prop] = handler</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而其中监听函数 <code>observe</code> 只是将对某一个属性的监听回调 <code>handler</code> 保存起来，方便在该属性值发生变化时，执行该回调。</p>
<p>接下来就是监听变化过程了，脏检查之所以称之为<em>脏</em>，是因为其不是直接监听属性是否发生了变更，而是通过一个定时器轮询检查，不断的遍历检查对象的新值和旧值，判断是否发生了变化，若是，则调用会回调函数 <code>handler</code> 将生产者的数据同步到消费者上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">digest</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  providers.forEach(digestProvider)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">digestProvider</span> (<span class="params">provider</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> provider._handlers) &#123;</div><div class="line">    <span class="keyword">if</span> (provider._prevValues[prop] !== provider[prop]) &#123;</div><div class="line">      provider._prevValues[prop] = provider[prop]</div><div class="line">      handler(provider[prop])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>所以对于 <code>digest</code> 方法就需要循环进行调用</strong>，譬如使用 <code>setInterval</code> 或者 <code>requestAnimationFrame</code> 方法，显然这个过程会对性能产生影响，当监听的对象越来越多时尤其明显。</p>
<p>在 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 1.0 版本中的数据绑定也是使用脏检查的解决方案，在其 <code>observe-js-behavior.html</code> 文件中我们就发现了通过定时器轮询脏检查的代码：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Poll observe-js all the time</span></div><div class="line">setInterval(<span class="keyword">Platform</span>.performMicrotaskCheckpoint, <span class="number">125</span>);</div></pre></td></tr></table></figure></p>
<p>而 angular 就对此也进行了优化，其并不使用定时轮询脏检查，而是对常用的 DOM 事件， XHR 事件等进行封装，在里面触发进入脏检查。</p>
<p>脏检查应该是实现对象监听比较成熟和完整的解决方案。可以参考以下两个项目:</p>
<ul>
<li><a href="https://github.com/Polymer/observe-js" target="_blank" rel="external">Polymer/observe-js</a></li>
<li><a href="https://github.com/MaxArt2501/object-observe" target="_blank" rel="external">MaxArt2501/object-observe</a></li>
</ul>
<p>而对于前者，也是 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 框架中使用的监听方案，</p>
<h2 id="存取器方法（accessor-method）"><a href="#存取器方法（accessor-method）" class="headerlink" title="存取器方法（accessor method）"></a>存取器方法（accessor method）</h2><p>这种方式是通过重写对象（<code>Object</code>类型）属性的 <code>set</code> 和 <code>get</code> 方法，在 <code>setter</code> 方法中执行相应的监听回调（callback）来实现的。</p>
<p>对对象的监听需要考虑 <code>Object</code> 类型和 <code>Array</code> 类型这两种类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一：obj1 只包含 `Object` 类型</span></div><div class="line"><span class="selector-tag">var</span> obj1 = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: <span class="number">2</span>,</div><div class="line">  c: &#123;</div><div class="line">   d: <span class="number">3</span>,</div><div class="line">   e: <span class="number">4</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 情况二：obj2 包含 `Object` 类型和 `Array` 类型</span></div><div class="line"><span class="selector-tag">var</span> obj2 = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: <span class="number">2</span>,</div><div class="line">  c: [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>首先我们考虑情况一，对象中不包含 <code>Array</code> 类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">obj, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    <span class="comment">// Object</span></div><div class="line">    <span class="keyword">if</span>(type === <span class="string">'[object Object]'</span>) &#123;</div><div class="line">     observeObject(obj, path);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="comment">// for...in 可以遍历对象的实例属性和原型属性，而 Object.keys 只遍历实例属性</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">      <span class="comment">// 注意这里不要用 var</span></div><div class="line">      <span class="keyword">let</span> value = obj[prop],</div><div class="line">        _path = path.slice(); <span class="comment">// 主要对 path 数组进行一次拷贝</span></div><div class="line">        _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">      <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">          callback(_path, newVle, value);</div><div class="line">          value = newVle;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      <span class="comment">// 递归</span></div><div class="line">      observe(value, _path);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  observe(obj, []);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>📌注意</strong></p>
<ul>
<li><code>for...in</code> 和 <code>Object.keys</code> 的区别，<a href="http://objcer.com/2017/02/22/js-enumerable/">参考链接</a></li>
<li><code>for...in</code> 循环中，变量定义不能使用 <code>var</code>，需要使用 <code>let</code> 或者用闭包，如下<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = obj[prop],</div><div class="line">        _path = path.slice();</div><div class="line">    _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">      <span class="attribute">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">        callback(_path, newVle, value);</div><div class="line">        value = newVle;</div><div class="line">      &#125;,</div><div class="line">      <span class="attribute">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 递归</span></div><div class="line">    observe(value, _path);</div><div class="line">  &#125;)()</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>测试代码：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></div><div class="line"><span class="attr">  a:</span> <span class="number">1</span><span class="string">,</span></div><div class="line"><span class="attr">  b:</span> <span class="number">2</span><span class="string">,</span></div><div class="line"><span class="attr">  c:</span> <span class="string">&#123;</span></div><div class="line"><span class="attr">   d:</span> <span class="number">3</span><span class="string">,</span></div><div class="line"><span class="attr">   e:</span> <span class="number">4</span></div><div class="line">  <span class="string">&#125;</span></div><div class="line"><span class="string">&#125;;</span></div><div class="line"><span class="string">new</span> <span class="string">Observer(obj,</span> <span class="string">(path,</span> <span class="string">newVle,</span> <span class="string">oldVle)</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></div><div class="line">  <span class="string">console.log(`path:</span> <span class="string">$&#123;path&#125;,</span> <span class="attr">newValue:</span> <span class="string">$&#123;newVle&#125;,</span> <span class="attr">oldValue:</span> <span class="string">$&#123;oldVle&#125;`)</span></div><div class="line"><span class="string">&#125;);</span></div><div class="line"></div><div class="line"><span class="string">obj.a</span> <span class="string">=</span> <span class="number">5</span><span class="string">;</span> <span class="string">//</span> <span class="attr">log:</span> <span class="attr">path:</span> <span class="string">a,</span> <span class="attr">newValue:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">oldValue:</span> <span class="number">1</span></div><div class="line"><span class="string">obj.c.d</span> <span class="string">=</span> <span class="number">6</span><span class="string">;</span> <span class="string">//</span> <span class="attr">log:</span> <span class="attr">path:</span> <span class="string">c,d,</span> <span class="attr">newValue:</span> <span class="number">6</span><span class="string">,</span> <span class="attr">oldValue:</span> <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p><strong>💣 局限性</strong><br>通过 <code>Object.defineProperty</code> 实现对对象的监听，我们是在 <code>set</code> 方法中做文章，那么监听的情况也就只限于对象属性的修改（modify），如果对对象属性的增删（add/delete），那么就无能为力了。</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>接着我们考虑情况二，对象中包含 <code>Object</code> 类型和 <code>Array</code> 类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">obj, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    <span class="keyword">if</span>(type === <span class="string">'[object Object]'</span> || type== <span class="string">'[object Array]'</span>) &#123;</div><div class="line">      observeObject(obj, path);</div><div class="line">      <span class="keyword">if</span> (type === <span class="string">'[object Array]'</span>) &#123;</div><div class="line">        observeArrayPreparation(obj, path);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="comment">// for...in 可以遍历对象的实例属性和原型属性，而 Object.keys 只遍历实例属性</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">      <span class="comment">// 注意：不能用 var</span></div><div class="line">      <span class="keyword">let</span> value = obj[prop],</div><div class="line">        _path = path.slice(); <span class="comment">// 主要对 path 数组进行一次拷贝</span></div><div class="line">        _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">      <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">          callback(_path, newVle, value);</div><div class="line">          value = newVle;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">       <span class="comment">// 递归</span></div><div class="line">       observe(value, _path);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeArrayPreparation = <span class="function"><span class="keyword">function</span> (<span class="params">arr, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _props = [<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>];</div><div class="line">    <span class="keyword">var</span> _newProto = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype);</div><div class="line">    _props.forEach(<span class="function">(<span class="params">prop</span>) =&gt;</span> &#123;</div><div class="line">      <span class="built_in">Object</span>.defineProperty(_newProto, prop, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 注意：数组方法的参数个数不确定，所以此处暂不处理</span></div><div class="line">          <span class="keyword">var</span> _path = path.slice();</div><div class="line">          _path.push(prop);</div><div class="line">          <span class="comment">// 注意：此处只返回 path</span></div><div class="line">          callback(_path);</div><div class="line">          <span class="built_in">Array</span>.prototype[prop].apply(arr, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;);</div><div class="line">    arr.__proto__ = _newProto;</div><div class="line">  &#125;</div><div class="line">  observe(obj, []);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>涉及到数组类型，解决的方法是，重新封装一下数组的操作方法 <code>[&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;]</code>，在其中调用相应的监听回调</p>
<p>测试代码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="type">1</span>,</div><div class="line">  b: <span class="type">2</span>,</div><div class="line">  c: <span class="type"></span>[<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> <span class="type">Observer</span>(obj, (path, <span class="keyword">new</span><span class="type">Vle</span>, oldVle) =&gt; &#123;</div><div class="line">  console.log(`path: <span class="type"></span>$&#123;path&#125;, <span class="keyword">new</span><span class="type">Value</span>: $&#123;<span class="keyword">new</span><span class="type">Vle</span>&#125;, oldValue: <span class="type"></span>$&#123;oldVle&#125;`)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.c[<span class="number">1</span>] = <span class="number">33</span> <span class="comment">// path: c,1, newValue: 33, oldValue: 4</span></div><div class="line"></div><div class="line">obj.c.push(<span class="number">5</span>); <span class="comment">// path: c,push, newValue: undefined, oldValue: undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>📌注意</strong></p>
<ul>
<li>由于数组不同操作方法的参数个数不同，所以在重新定义时需要对此进行判断处理，此处暂不处理，监听回调也只返回 path 路径</li>
<li>上述对数组的处理还存在很多问题，譬如测试代码中，新添加的 <code>5</code> 这个值并没有进行监听，如果此时对 <code>obj.c[2]</code> 进行修改，那么发现并没有回调监听函数；所以此处只提供一个思路。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/" target="_blank" rel="external">Writing a JavaScript Framework - Introduction to Data Binding, beyond Dirty Checking</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Data binding is a general technique that binds data sources from the provider and consumer together and synchronizes them.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前端组件化框架中，基本都有&lt;strong&gt;数据绑定&lt;/strong&gt;这一特性，数据绑定是将生产者的数据源绑定到消费者，并负责数据同步。本文将探究数据绑定的不同实现方式。🤓&lt;/p&gt;
&lt;p&gt;目前主要有以下几种实现方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏检查（dirty check）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存取器方法（accessor method）&lt;/strong&gt;: &lt;code&gt;Object.defineProperty&lt;/code&gt; ES5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxy&lt;/code&gt;: ES6 支持较差【Proxies are one of the few non polyfillable additions.（babel不支持转换）】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.observe&lt;/code&gt;: ES7，已经移出草案，不支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.watch&lt;/code&gt;: 目前只有基于gecko的浏览器如火狐支持,官方建议仅供调试用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中前两种方式是主流，angular、Polymer 使用的就是脏检查，Vue 使用的就是存取器方法。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="数据绑定" scheme="http://objcer.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
      <category term="脏检查" scheme="http://objcer.com/tags/%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    
      <category term="存取器方法" scheme="http://objcer.com/tags/%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web Components</title>
    <link href="http://objcer.com/2017/10/20/Web-Components/"/>
    <id>http://objcer.com/2017/10/20/Web-Components/</id>
    <published>2017-10-20T08:35:02.000Z</published>
    <updated>2017-10-20T08:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/web-components.png" alt=""></p>
<p>组件是构建现代网页应用的基础。组件化给前端开发带来了极大的效率提升，提高了代码的重用性；组件化的 UI 框架也层出不穷，React, Vue 等等。但是这些框架缺乏标准，代码层面可能存在很大的差异，如何对前端组件标准化就显得尤为重要。<br>Web Components 作为面向未来的 Web 组件化标准，包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分，浏览器原生支持，所以 Web Components 是最彻底的组件化解决方案。</p>
<a id="more"></a>
<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><p>Web Components 包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分， 需要浏览器支持，但是目前为止，未被所有浏览器完整实现。<br>参考 <a href="https://www.webcomponents.org/" target="_blank" rel="external">https://www.webcomponents.org/</a> 给出的浏览器支持情况：</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/web-component-browser-support.png" alt=""></p>
<p>基于 Web Components，Google 推出了 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 框架，作为应用层框架，使用 Polymer 相较于直接使用 Web Components 接口，开发网页应用更加方便简洁，提高效率。Polymer 在今年 5 月份，推出 <a href="https://www.polymer-project.org/blog/2017-05-15-time-for-two.html" target="_blank" rel="external">Polymer 2.0</a>，使用 Shadow DOM v1 和 Custom elements v1，对于不兼容的浏览器，也提供了 polyfill。而在今年 Polymer Summit 大会上，推出了最新 <a href="https://www.polymer-project.org/blog/2017-08-22-npm-modules.html" target="_blank" rel="external">Polymer 3.0 preview</a>，也指明了 Polymer 最新的发展方向，其中主要变化是：① 从 bower 转向 npm ② 使用 ES6 modules，弃用 HTML Imports</p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/" target="_blank" rel="external">Building Components</a> 系列文章中详细介绍了 Custom Elements 和 Shadow DOM，阅读后整理如下：</p>
<ul>
<li><a href="https://objcer.com/2017/10/20/Custom-Elements/">Custom Elements</a></li>
<li><a href="https://objcer.com/2017/10/20/Shadow-DOM/">Shadow DOM</a></li>
</ul>
<p>通过 Web Components 开发自定义组件就是用 Custom Elements 做外壳，其中建立 Shadow DOM 提供 DOM 封装，作用域 CSS 等特性，通过 template 模板构建 DOM，每一个组件都是一个 html 文件，使用时通过 HTML Import引入。</p>
<p>关于 Web Components 网上也有很多讨论质疑的声音：<br><a href="https://github.com/dt-fe/weekly/issues/15" target="_blank" rel="external">精读《Web Components 的困境》</a></p>
<h2 id="Polymer"><a href="#Polymer" class="headerlink" title="Polymer"></a>Polymer</h2><p>Polymer 是基于 Web Components 的组件化框架，了解 Web Components 对于理解使用 Polymer 有很大的帮助。Polymer 可以划分为以下四大部分内容：</p>
<ul>
<li>Custom elements</li>
<li>Shadow DOM</li>
<li>Events</li>
<li>Data system</li>
</ul>
<p>关于 Polymer 的学习会通过下一个系列文章进行记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/web-components.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;组件是构建现代网页应用的基础。组件化给前端开发带来了极大的效率提升，提高了代码的重用性；组件化的 UI 框架也层出不穷，React, Vue 等等。但是这些框架缺乏标准，代码层面可能存在很大的差异，如何对前端组件标准化就显得尤为重要。&lt;br&gt;Web Components 作为面向未来的 Web 组件化标准，包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分，浏览器原生支持，所以 Web Components 是最彻底的组件化解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Web Components" scheme="http://objcer.com/tags/Web-Components/"/>
    
  </entry>
  
  <entry>
    <title>Shadow DOM</title>
    <link href="http://objcer.com/2017/10/20/Shadow-DOM/"/>
    <id>http://objcer.com/2017/10/20/Shadow-DOM/</id>
    <published>2017-10-20T08:08:02.000Z</published>
    <updated>2017-10-20T08:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/shadow-dom.png" alt=""><br>Shadow DOM 是四大网络组件标准之一，提供 CSS 作用域、DOM 封装和组合(Composition) 等优势，构建自定义元素。</p>
<a id="more"></a>
<h2 id="什么是-Shadow-DOM"><a href="#什么是-Shadow-DOM" class="headerlink" title="什么是 Shadow DOM"></a>什么是 Shadow DOM</h2><p>浏览器在解析网页文档的时候，会将 HTML 标签转换成节点，为了保持页面的层次结构，这些节点构成一个节点树，这个结构就是 DOM（文档对象模型）。DOM 将文档作为一个结构化的节点组以及包含属性和方法的对象，是 HTML 的编程接口，我们通常会使用 JavaScript 来访问操纵 DOM。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</div><div class="line"><span class="keyword">const</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</div><div class="line">h1.textContent = <span class="string">'Hello world!'</span>;</div><div class="line">header.appendChild(h1);</div><div class="line"><span class="built_in">document</span>.body.appendChild(header);</div></pre></td></tr></table></figure></p>
<p>这段 JavaScript 代码执行后会生成如下的 DOM 结构：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello DOM<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那什么是 Shadow DOM 呢❓<br>Shadow DOM 为 Web 组件中的 DOM 和 CSS 提供了封装。Shadow DOM 使得这些东西与主文档的 DOM 保持分离。Shadow DOM 与普通的 DOM 的区别是：<br>👉 通常创建新的 DOM 节点附加到其他 DOM 元素上，就会成为其子节点（元素）；但借助 Shadow DOM，可以创建一个  DOM 树附加到其他元素上，这个 DOM 树并非其子节点（元素），其拥有自身的作用域范围，这个 DOM 树称为：<strong><code>shadwo tree</code></strong>。被附加的元素称为 <strong><code>shadow host</code></strong>，这个 DOM 树称为 <strong><code>shadow root</code></strong>。</p>
<blockquote>
<p>You can think of shadow DOM as a scoped subtree inside your element.</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</div><div class="line"><span class="keyword">const</span> shadowRoot = header.attachShadow(&#123;mode: <span class="string">'open'</span>&#125;);</div><div class="line">shadowRoot.innerHTML = <span class="string">'&lt;h1&gt;Hello Shadow DOM&lt;/h1&gt;'</span>; <span class="comment">// Could also use appendChild().</span></div><div class="line"></div><div class="line"><span class="comment">// header.shadowRoot === shadowRoot</span></div><div class="line"><span class="comment">// shadowRoot.host === header</span></div></pre></td></tr></table></figure>
<ul>
<li>为元素创建 shadow DOM，调用 <code>element.attachShadow()</code></li>
<li>通过 <code>shadowRoot</code> 属性获取元素附加的 Shadow DOM</li>
<li>通过 shadow root 的 <code>host</code> 属性获取其附属的元素</li>
</ul>
<p>❗️<strong>注意：</strong>并非所有元素都可以调用 <code>element.attachShadow()</code> 为其创建添加 Shadow DOM，因为有些元素浏览器已经为其添加了 Shadow DOM，例如 <code>&lt;textarea&gt;</code> <code>&lt;input&gt;</code>；而还有些元素为其添加 Shadow DOM 是没有意义的，例如 <code>&lt;img&gt;</code>。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">document</span><span class="selector-class">.createElement</span>(<span class="string">'input'</span>)<span class="selector-class">.attachShadow</span>(&#123;<span class="attribute">mode</span>: <span class="string">'open'</span>&#125;);</div><div class="line"><span class="comment">// Error. `&lt;input&gt;` cannot host shadow dom.</span></div></pre></td></tr></table></figure>
<p>在创建自定义元素时，Shadow DOM 尤其有用。使用 Shadow DOM 来分隔元素的 HTML、CSS 和 JS，从而生成一个组件。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    shadowRoot.innerHTML = `</div><div class="line">    &lt;style&gt;</div><div class="line">    b &#123;</div><div class="line">      color: red;</div><div class="line">    &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;b&gt;<span class="type">Hello</span> world&lt;/b&gt;</div><div class="line">    `</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>注意 Shadow DOM 中的 CSS 规则的作用域仅限于 <code>&lt;x-tag&gt;</code>。</p>
<h2 id="组合和-slot"><a href="#组合和-slot" class="headerlink" title="组合和 slot"></a>组合和 slot</h2><p>组合是 shadow DOM 最难理解的功能之一，但可以说是最重要的功能。</p>
<h3 id="light-DOM-和-shadow-DOM"><a href="#light-DOM-和-shadow-DOM" class="headerlink" title="light DOM 和 shadow DOM"></a>light DOM 和 shadow DOM</h3><p><strong>light DOM</strong><br>使用组件的用户编写的标记，DOM 元素的实际子元素，该子元素不在组件的 shadow DOM 之内，这就是 light DOM。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"better-button"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- the image and span are better-button's light DOM --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"gear.svg"</span> <span class="attr">slot</span>=<span class="string">"icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Settings<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中 <code>image</code> 和 <code>span</code> 即是 <code>button</code> 的 light DOM。</p>
<p><strong>shadow DOM</strong><br>组件作者编写的标记，它定义组件的内部结构，作用域 CSS 等<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">...</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>Flattened DOM tree</strong><br>浏览器将用户的 light DOM 分布到 shadow DOM 中，渲染成一颗 DOM 树，这个过程称为 <strong><code>flattening the tree</code></strong>，这棵树称为扁平树 <strong><code>Flattened DOM tree</code></strong>。 扁平树也是我们在 DevTools 中最终看到的树以及在页面上渲染的结果。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/FF183E44-E19D-4B24-918B-2DE5067699A4.png" alt=""></p>
<h3 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><slot> 元素</slot></h3><p>Shadow DOM 使用 <code>&lt;slot&gt;</code> 元素将 light DOM 树组合到 shadow DOM 中，形成一颗 DOM 树。</p>
<p>Slot 相当于是组件内部的占位符，通过定义一个或者多个 <code>&lt;slot&gt;</code>，可以将外部的标记引入到组件 shadow DOM 中进行渲染，相当于“跨域”了 shadow DOM 的边界，这些引入到 shadow DOM 中的元素被称为分布式节点 <strong><code>distributed nodes</code></strong>。注意：slot 实际上并不移动这些分布式节点，它们在 shadow DOM 内部的其他位置进行渲染。</p>
<p>组件可在其 shadow DOM 中定义零个或多个 slot。Slot 可以为空，或者提供回退内容(fallback content)，如果用户不提供 light DOM 内容，slot 会将对其备用内容进行渲染。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Default slot. If there's more than one default slot, the first is used. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>Fancy button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- default slot with fallback content --&gt;</span></div></pre></td></tr></table></figure>
<p>还可以创建命名 slot (named slots)，使用组件的用户通过名称找到特定的 slot。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">x-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Custom Elements<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">x-tag</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">b</span> &#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="设定样式"><a href="#设定样式" class="headerlink" title="设定样式"></a>设定样式</h2><p>shadow DOM 最有用的功能是作用域 CSS：</p>
<ul>
<li>外部页面中的 CSS 选择器不会应用于组件内部。</li>
<li>组件内部定义的样式也不会渗出，它们的作用域仅限于宿主元素(shadow host)</li>
</ul>
<h3 id="通过选择器设定样式"><a href="#通过选择器设定样式" class="headerlink" title="通过选择器设定样式"></a>通过选择器设定样式</h3><p><strong>使用 <code>:host</code> 为组件为自身设定样式</strong><br>需要注意：外部页面中为组件设定的样式比 <code>:host</code> 规则具有更高的优先级，也就是说，对于组件自身，外部样式优先，用户可以在外部设置组件自身的样式。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 外部样式比 :host 优先</div><div class="line">x-tag &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">:host</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用 <code>:host(&lt;selector&gt;)</code> 匹配组件自身不同状态</strong><br>通过 <code>:host(&lt;selector&gt;)</code> 匹配不同状态，对组件自身或者内部节点设定不同的样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">:host(</span><span class="selector-pseudo">:hover)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.red_bg)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.green_bg)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.disable)</span> <span class="selector-tag">button</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用 <code>:host-context(&lt;selector&gt;)</code> 匹配任意父级</strong><br>使用 <code>:host-context(&lt;selector&gt;)</code> 主要用于根据组件所在的环境进行主题化（基于情境设定样式），例如设置白天模式，夜晚模式，我们在 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 设定不同的 class，而组件通过 <code>:host-context(&lt;selector&gt;)</code> 就可以匹配到</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;body class="darktheme"&gt;</span></div><div class="line">  <span class="params">&lt;fancy-tabs&gt;</span></div><div class="line">    ...</div><div class="line">  <span class="params">&lt;/fancy-tabs&gt;</span></div><div class="line"><span class="params">&lt;/body&gt;</span></div><div class="line"></div><div class="line"><span class="meta">#shadow-root</span></div><div class="line">  :host-context(.darktheme) &#123;</div><div class="line"><span class="symbol">    color:</span> white;</div><div class="line"><span class="symbol">    background:</span> black;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>使用 <code>::slotted(&lt;compound-selector&gt;)</code> 匹配分布到 <slot> 中的节点</slot></strong><br>使用 <code>::slotted(&lt;compound-selector&gt;)</code> 为分布式节点设定样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">name-badge</span>&gt;</span></div><div class="line">  #shadow-root</div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Eric Bidelman<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></div><div class="line">      Digital Jedi, <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"company"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">name-badge</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>组件的 shadow DOM 可为用户的 <code>&lt;h2&gt;</code> 和 <code>.title</code> 设定样式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">::slotted(h2)</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">::slotted(.title)</span> &#123;</div><div class="line">     <span class="attribute">color</span>: orange;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* DOESN'T WORK (can only select top-level nodes).</span></div><div class="line">  ::slotted(.company),</div><div class="line">  ::slotted(.title .company) &#123;</div><div class="line">    text-transform: uppercase;</div><div class="line">  &#125;</div><div class="line">  */</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是：<br>① 使用 <code>::slotted(&lt;compound-selector&gt;)</code> 只能为分布节点的<strong>顶级节点</strong>设置样式。<br>② slot 并不会移动 light DOM，light DOM 节点分布到 shadow DOM 中后，slot 会对其 DOM 进行渲染，样式设置，但是节点实际还是留在原处。如果外部对 light DOM 设置了样式，那么外部样式将会覆盖 shadow DOM 中通过 <code>::slotted(&lt;compound-selector&gt;)</code> 设置的样式，具有较高优先级。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">  x-tag p &#123;</div><div class="line">    color: red; // 外部样式，具有较高优先级</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">x-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Custom Elements<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">x-tag</span>&gt;</span></div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">::slotted(p)</span> &#123;</div><div class="line">    <span class="attribute">color</span>: green;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="从外部为组件设定样式"><a href="#从外部为组件设定样式" class="headerlink" title="从外部为组件设定样式"></a>从外部为组件设定样式</h3><p>有几种方法可从外部为组件设定样式：最简单的方法是使用标记名称作为选择器</p>
<p><strong>为组件自身设定样式</strong><br>从外部为组件自身设定样式最简单的方法，就是使用组件标签名称作为选择器，设置 CSS 样式。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x-<span class="keyword">tag</span> <span class="title">&#123;</span></div><div class="line"></div><div class="line">&#125;</div><div class="line">x-tag:hover &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<strong>外部样式总是优先于在 shadow DOM 中定义的样式。</strong>例如，如果用户在组件外部编写：<code>fancy-tabs { width: 500px; }</code>，它将优先于组件的规则：<code>:host { width: 650px;}</code>。</p>
<p><strong>为组件内部元素设定样式</strong><br>在组件外部，我们不能直接通过选择器对组件内的元素设置样式。组件提供自定义属性 <strong>custom properties</strong>，相当于是样式占位符，外部通过对自定义属性 <strong>custom properties</strong> 来调整组件内部元素的样式。</p>
<p>例如，<code>&lt;fancy-tabs&gt;</code> 可让用户替换背景颜色：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- main page --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">fancy-tabs</span> &#123;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">--fancy-tabs-bg</span>: black;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">fancy-tabs</span> <span class="attr">background</span>&gt;</span>...<span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在其 shadow DOM 内部：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:host(</span><span class="selector-attr">[background]</span>) &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--fancy-tabs-bg, #9E9E9E);</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中，该组件将使用 <code>black</code> 作为背景值，因为用户指定了该值。 否则背景颜色将采用默认值 <code>#9E9E9E</code>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="避免在组件中创建-closed-shadow-root"><a href="#避免在组件中创建-closed-shadow-root" class="headerlink" title="避免在组件中创建 closed shadow root"></a>避免在组件中创建 closed shadow root</h3><p>shadow DOM 的另一情况称为<strong>闭合</strong>模式。创建closed shadow DOM tree 后，在外部无法通过 JavaScript 访问组件的内部 DOM。这与 <code>&lt;video&gt;</code> 等原生元素工作方式类似，JavaScript 无法访问 <code>&lt;video&gt;</code> 的 shadow DOM，因为浏览器使用closed shadow root来实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">const</span> shadowRoot = div.attachShadow(&#123;mode: <span class="string">'closed'</span>&#125;); <span class="comment">// close shadow tree</span></div><div class="line"><span class="comment">// div.shadowRoot === null</span></div><div class="line"><span class="comment">// shadowRoot.host === div</span></div></pre></td></tr></table></figure>
<h3 id="关于-slot-的-API"><a href="#关于-slot-的-API" class="headerlink" title="关于 slot 的 API"></a>关于 slot 的 API</h3><p><strong><code>slotchange</code> 事件</strong></p>
<p>当 slot 的分布式节点发生变化时，<code>slotchange</code> 事件会触发。例如，当用户从 light DOM 中添加/移除子项时。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> slot = <span class="keyword">this</span>.shadowRoot.querySelector(<span class="string">'#slot'</span>);</div><div class="line">slot.addEventListener(<span class="string">'slotchange'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'light dom children changed!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注：当组件的实例首次初始化时，<code>slotchange</code> 不触发。</p>
<p><strong>查看 slot 中渲染的元素</strong><br>调用 <code>slot.assignedNodes()</code> 可查看 slot 正在渲染哪些元素；该方法中传入 <code>{flatten: true}</code> 选项将返回 slot 的备用内容fallbcak content（前提是没有分布任何节点）。</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>调用</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;My button&lt;/button&gt;</code></td>
<td>slot.assignedNodes();</td>
<td>[text]</td>
</tr>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;&lt;/button&gt;</code></td>
<td>slot.assignedNodes();</td>
<td>[]</td>
</tr>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;&lt;/button&gt;</code></td>
<td>slot.assignedNodes({flatten: true});</td>
<td>[<b>fallback content</b>]</td>
</tr>
</tbody>
</table>
<p><strong>查看元素渲染在哪个 slot 中</strong><br><code>element.assignedSlot</code> 将告诉您元素分配到组件的哪个 slot。</p>
<h3 id="Shadow-DOM-事件模型"><a href="#Shadow-DOM-事件模型" class="headerlink" title="Shadow DOM 事件模型"></a>Shadow DOM 事件模型</h3><p>当事件从 shadow DOM 中触发时，其目标 target 为维持 shadow DOM 的封装，不暴露 shadow DOM 中的内容元素，会进行重置 retarget，看起来事件是来自组件本身，而不是组件中 shadow DOM 中的内容元素。</p>
<p>大部分事件都会跨过 shadow DOM 边界，向外传播：</p>
<ul>
<li>聚焦事件：blur、focus、focusin、focusout</li>
<li>鼠标事件：click、dblclick、mousedown、mouseenter、mousemove，等等</li>
<li>滚轮事件：wheel</li>
<li>输入事件：beforeinput、input</li>
<li>键盘事件：keydown、keyup</li>
<li>组合事件：compositionstart、compositionupdate、compositionend</li>
<li>拖放事件：dragstart、drag、dragend、drop，等等</li>
</ul>
<p>对于 <code>mode</code> 为 <code>open</code> 的 shadow DOM，事件回调中，调用 <code>event.composedPath()</code> 将返回事件向上传播经过的节点路径。</p>
<p>对于组件内的自定义事件，不会传播出 shadow DOM，除非事件创建时指定 <code>composed: true</code><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inside &lt;fancy-tab&gt; custom element class definition:</span></div><div class="line">selectTab() &#123;</div><div class="line">  <span class="keyword">const</span> tabs = <span class="keyword">this</span>.shadowRoot.<span class="built_in">querySelector</span>(<span class="string">'#tabs'</span>);</div><div class="line">  tabs.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'tab-select'</span>, &#123;bubbles: <span class="keyword">true</span>, composed: <span class="keyword">true</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 <code>composed: false</code>（默认值），用户无法在组件外部侦听到这个自定义事件。<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">fancy-tabs</span>&gt;</span><span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> tabs = <span class="built_in">document</span>.querySelector(<span class="string">'fancy-tabs'</span>);</div><div class="line">  tabs.addEventListener(<span class="string">'tab-select'</span>, e =&gt; <span class="template-variable">&#123;</span></div><div class="line">    // won't fire <span class="keyword">if</span> `tab-<span class="keyword">select</span>` wasn't created with `composed: true`.</div><div class="line">  &#125;<span class="xml"><span class="undefined">);</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文主要是阅读 <strong>Shadow DOM v1: Self-Contained Web Components</strong> 后，理解整理而来。<br>英文原文：<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom" target="_blank" rel="external">Shadow DOM v1: Self-Contained Web Components</a><br>中文翻译：<a href="https://developers.google.com/web/fundamentals/web-components/best-practices?hl=zh-cn" target="_blank" rel="external">Shadow DOM v1：独立的网络组件</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/shadow-dom.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Shadow DOM 是四大网络组件标准之一，提供 CSS 作用域、DOM 封装和组合(Composition) 等优势，构建自定义元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Shadow DOM" scheme="http://objcer.com/tags/Shadow-DOM/"/>
    
  </entry>
  
  <entry>
    <title>Custom Elements</title>
    <link href="http://objcer.com/2017/10/20/Custom-Elements/"/>
    <id>http://objcer.com/2017/10/20/Custom-Elements/</id>
    <published>2017-10-20T08:07:56.000Z</published>
    <updated>2017-10-20T08:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/custom-elements.png" alt=""></p>
<p>Custom Elements 为开发者提供了创建新 HTML 标记，扩展现有 HTML 标记的能力，创建自定义新的元素，将 JS 逻辑行为和元素 DOM 关联起来，代码模块化，提供重用性。</p>
<a id="more"></a>
<h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p><strong>创建自定义元素包括两个步骤：</strong></p>
<ul>
<li><p>通过 class <strong>定义</strong>自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="comment">// If you define a ctor, always call super() first!</span></div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>向浏览器<strong>注册</strong>该自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;...&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">AppDrawer</span>);</div><div class="line"></div><div class="line"><span class="comment">// 匿名类</span></div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>创建自定义元素几点注意：</strong></p>
<ul>
<li>自定义元素定义类中的构造函数中，总是需要调用 <code>super()</code></li>
<li>自定义元素名称必须要包含一个短横线(-)，浏览器以次来区分自定义元素和常规元素。例如 <code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code> 为有效名称；而 <code>&lt;tabs&gt;</code> 和 <code>&lt;foo_bar&gt;</code> 则为无效名称</li>
<li><p>不能多次注册同一自定义元素，否则会抛出 <code>DOMException</code> 异常</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">A</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">B</span>); <span class="comment">// ❗️DOMException</span></div></pre></td></tr></table></figure>
</li>
<li><p>自定义元素不能自闭合(self-closing)，所以需要写结束标签，例如 <code>&lt;x-tags&gt;&lt;/x-tags&gt;</code></p>
</li>
</ul>
<p><strong>定义新的自定义元素，class 类继承 <code>HTMLElement</code>；也可以扩展已有的元素，包括：</strong></p>
<ul>
<li><p>扩展自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyDrawer</span> <span class="keyword">extends</span> <span class="title">AppDrawer</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>扩展 HTML 原生元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">customElements.define(<span class="symbol">'fancy</span>-button', <span class="type">FancyButton</span>, &#123;<span class="keyword">extends</span>: <span class="symbol">'butto</span>n'&#125;);</div></pre></td></tr></table></figure>
<p>扩展 HTML 原生元素时，对 <code>define()</code> 的调用会稍有不同，需要传入第三个参数告知浏览器要扩展的标记。</p>
</li>
</ul>
<p>使用自定义元素与 <code>&lt;div&gt;</code> 或任何其他元素的使用没有区别。可以在页面上声明，也可也通过 JavaScript 动态创建实例，也可添加事件侦听器，诸如此类。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;app-drawer&gt;&lt;/app-drawer&gt;</div><div class="line"><span class="keyword">let</span> drawer = <span class="keyword">new</span> AppDrawer()</div><div class="line"></div><div class="line"><span class="comment">// ❗️自定义 HTML 原生元素需要在原生标记上添加 is="" 属性来声明</span></div><div class="line">&lt;button <span class="keyword">is</span>=<span class="string">"fancy-button"</span>&gt;Fancy button!&lt;/button&gt;</div><div class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> FancyButton()</div><div class="line"></div><div class="line"><span class="comment">// customElements.get 方法通过传入自定义元素标记名称，获取元素的构造函数</span></div><div class="line"><span class="keyword">let</span> Drawer = customElements.<span class="keyword">get</span>(<span class="string">'app-drawer'</span>);</div><div class="line"><span class="keyword">let</span> drawer = <span class="keyword">new</span> Drawer();</div></pre></td></tr></table></figure></p>
<h2 id="自定义元素的响应"><a href="#自定义元素的响应" class="headerlink" title="自定义元素的响应"></a>自定义元素的响应</h2><p>自定义元素提供了一些响应方法，表征其生命周期的不同时刻，我们可以在这些响应方法（回调方法）中执行相关的逻辑。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>创建或升级元素的一个实例。用于初始化状态、设置事件侦听器或创建 Shadow DOM</td>
</tr>
<tr>
<td>connectedCallback</td>
<td>元素每次插入到 DOM 时都会调用</td>
</tr>
<tr>
<td>disconnectedCallback</td>
<td>元素每次从 DOM 中移除时都会调用</td>
</tr>
<tr>
<td>attributeChangedCallback(attrName, oldVal, newVal)</td>
<td>属性添加、移除、更新或替换时调用；创建元素或者升级时，也会调用它来获取初始值</td>
</tr>
<tr>
<td>adoptedCallback</td>
<td>自定义元素被移入新的 document （例如，有人调用了 document.adoptNode(el)）</td>
</tr>
</tbody>
</table>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the ctor.</span></div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  connectedCallback() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  disconnectedCallback() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  attributeChangedCallback(attrName, oldVal, newVal) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>attributeChangedCallback</code> 响应仅针对 <code>observedAttributes</code> 属性中列出的，对于 class, style 等属性的修改并不会调用该响应，这也是处于性能考虑</li>
<li><code>disconnectedCallback()</code> 响应主要用于清理工作，例如移除事件侦听器等。但是如果用户关闭了标签，<code>disconnectedCallback()</code> 响应将无法调用</li>
<li><strong>响应是同步的</strong>，例如移除自定义元素后，会立即收到 <code>disconnectedCallback()</code> 响应</li>
</ul>
<h2 id="自定义元素升级-upgrades"><a href="#自定义元素升级-upgrades" class="headerlink" title="自定义元素升级(upgrades)"></a>自定义元素升级(upgrades)</h2><p><strong>自定义元素可以在其定义注册之前使用。</strong></p>
<p>HTML 解析标签容错能力强，对于页面上声明的 <code>&lt;asdfasdf&gt;</code> 这类未知的标签，浏览器也能接受，因为 HTML 规范允许这类未知标签，它把这类未知标签生成的元素当成 <code>HTMLUnknownElement</code> 进行解析。而当页面中存在符合自定义元素命名规则（包含短横线’-‘）的标签，但是还未定义注册时，浏览器将其视为潜在的自定义元素，解析成 <code>HTMLElement</code></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> <span class="string">"tabs"</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid custom element name</div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'tabs'</span>) <span class="keyword">instanceof</span> HTMLUnknownElement === <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="regexp">//</span> <span class="string">"x-tabs"</span> <span class="keyword">is</span> a valid custom element name</div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'x-tabs'</span>) <span class="keyword">instanceof</span> HTMLElement === <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>所以我们可以在页面中先声明使用自定义元素，其后再调用 <code>customElements.define</code> 注册自定义元素，在自定义元素注册完成后，将页面中已声明使用的升级（upgrades）为自定义元素，这个过程称之为元素升级（element upgrades）</p>
<p>要了解标记名称何时注册定义，可以使用 <code>window.customElements.whenDefined()</code>。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">customElements.whenDefined(<span class="string">'app-drawer'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'app-drawer defined'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="自定义元素的状态-state"><a href="#自定义元素的状态-state" class="headerlink" title="自定义元素的状态 (state)"></a>自定义元素的状态 (state)</h2><p>自定义元素的状态包括：<strong><code>undefined</code>, <code>failed</code>, <code>uncustomized</code>, <code>custom</code></strong>，其中 <strong><code>uncustomized</code>, <code>custom</code></strong> 都表已定义 <strong><code>defined</code></strong>；对于类似 <code>div</code> 的内置元素状态始终为已定义 <strong><code>defined</code></strong></p>
<p>在元素升级之前，处于未定义状态，我们可以过 <code>:defined</code> 伪类预设置未注册元素的样式，避免在获得定义时产生布局跳动或者 FOUC</p>
<blockquote>
<p>FOUC: Flash of Unstyled Content 文档样式短暂失效，指 HTML 页面在打开过程中，内容先于样式展示，导致页面样式在瞬间出现剧变，并且人眼可见</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">app-drawer</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:defined)</span> &#123;</div><div class="line">  <span class="comment">/* Pre-style, give layout, replicate app-drawer's eventual styles, etc. */</span></div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease-in-out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>&lt;app-drawer&gt;</code> 获得定义后，选择器 <code>app-drawer:not(:defined)</code> 不再匹配。</p>
<h2 id="设置自定义元素的内容"><a href="#设置自定义元素的内容" class="headerlink" title="设置自定义元素的内容"></a>设置自定义元素的内容</h2><h3 id="通过-innerHTML-设置元素内容"><a href="#通过-innerHTML-设置元素内容" class="headerlink" title="通过 innerHTML 设置元素内容"></a>通过 <code>innerHTML</code> 设置元素内容</h3><p>自定义元素在 <code>connectedCallback</code> 响应中，使用 DOM API 来设置元素的内容，但这不是好的做法，不推荐使用，更好的方式是使用 Shadow DOM。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  connectedCallback() &#123;</div><div class="line">    <span class="keyword">this</span>.innerHTML = '&lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt; <span class="type">Custom</span> <span class="type">Element</span>'</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="通过-Shadow-DOM-设置元素内容"><a href="#通过-Shadow-DOM-设置元素内容" class="headerlink" title="通过 Shadow DOM 设置元素内容"></a>通过 Shadow DOM 设置元素内容</h3><blockquote>
<p>关于 Shadow DOM 的详细介绍，参考：<a href=""></a></p>
</blockquote>
<p>Shadow DOM 提供了一种方法，可让设置的元素以独立于页面其余部分的方式拥有和渲染 DOM 并设置其样式。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;x-tag&gt;<span class="type">Custom</span> <span class="type">Element</span>&lt;/x-tag&gt;</div><div class="line"></div><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    shadowRoot.innerHTML = `</div><div class="line">    &lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt;</div><div class="line">    &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    `</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在这个例子中，Shadow DOM 是通过 <code>innerHTML</code> 来创建 DOM 元素；我们还可以通过 <code>&lt;template&gt;</code> 元素来创建 DOM。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;x-tag&gt;<span class="type">Custom</span> <span class="type">Element</span>&lt;/x-tag&gt;</div><div class="line">&lt;template id=<span class="string">"tmpl"</span>&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">  <span class="comment">/*scoped styles*/</span></div><div class="line">  &lt;/style&gt;</div><div class="line">  &lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt;</div><div class="line">  &lt;slot&gt;&lt;/slot&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    let tmpl = document.querySelector('#tmpl')</div><div class="line">    shadowRoot.appendChild(tmpl.content.cloneNode(<span class="literal">true</span>))</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="属性-property-映射为特性-attribute"><a href="#属性-property-映射为特性-attribute" class="headerlink" title="属性 (property) 映射为特性 (attribute)"></a>属性 (property) 映射为特性 (attribute)</h2><p>对 DOM 元素属性 (property) 修改，其值会以特性 (attribute) 的形式映射到 DOM，例如通过 JS 修改 DOM 元素的 id，hidden 属性：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">div</span>.<span class="built_in">id</span> = '<span class="keyword">my</span>-<span class="built_in">id</span>';</div><div class="line"><span class="keyword">div</span>.hidden = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>DOM 节点会变成：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"my-id"</span> hidden&gt;</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文主要是阅读 <strong>Custom Elements v1: Reusable Web Components</strong> 后，理解整理而来。<br>英文原文：<a href="https://developers.google.com/web/fundamentals/web-components/customelements" target="_blank" rel="external">Custom Elements v1: Reusable Web Components</a><br>中文翻译：<a href="https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn" target="_blank" rel="external">自定义元素 v1：可重用网络组件</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/custom-elements.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Custom Elements 为开发者提供了创建新 HTML 标记，扩展现有 HTML 标记的能力，创建自定义新的元素，将 JS 逻辑行为和元素 DOM 关联起来，代码模块化，提供重用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Custom Elements" scheme="http://objcer.com/tags/Custom-Elements/"/>
    
  </entry>
  
  <entry>
    <title>0.1+0.2=0.30000000000000004❓</title>
    <link href="http://objcer.com/2017/10/16/floating-point-arithmetic/"/>
    <id>http://objcer.com/2017/10/16/floating-point-arithmetic/</id>
    <published>2017-10-16T08:31:42.000Z</published>
    <updated>2017-10-17T01:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-brjYnVlXwM3j_SWXImT0Rg.png" alt=""><br>JavaScript中所有的数字，无论是整数还是小数，其类型都是 Number，遵循 <a href="http://grouper.ieee.org/groups/754/" target="_blank" rel="external">IEEE 754</a> 程序内部用一个 64 位固定长度的二进制进行存储表示。JavaScript 中的浮点数进行运算时，经常会遇到计算精度问题，例如经典的 <code>0.1+0.2=0.30000000000000004</code>，本文将探究 JavaScript 的浮点数，并解释为何 <code>0.1+0.2=0.30000000000000004</code></p>
<a id="more"></a>
<h2 id="浮点数的二进制表示"><a href="#浮点数的二进制表示" class="headerlink" title="浮点数的二进制表示"></a>浮点数的二进制表示</h2><p>JavaScript 里的数字是采用 <a href="http://grouper.ieee.org/groups/754/" target="_blank" rel="external">IEEE 754</a> 标准的 64 位 double 双精度浮点数（与之相关的还有 32 位 float 单精度浮点数）。该规范定义了浮点数的格式。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/5F33F675-2DF0-472F-9F2E-98066AE91720.png" alt=""></p>
<p>对于 32 位的浮点数，最高的 1 位是符号位 S，接着的 8 位是指数 E，剩下的 23 位为尾数位 M<br>对于 64 位的浮点数，最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为尾数位 M</p>
<ul>
<li>符号位 S：0 表示正数，1 表示负数</li>
<li>指数 E：表示次方</li>
<li>尾数位 M：表示有效数字（小数部分）</li>
</ul>
<p>实际数字的计算公式为：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V = (-<span class="number">1</span>)<span class="symbol">^S</span> * M * <span class="number">2</span><span class="symbol">^E</span></div></pre></td></tr></table></figure></p>
<p>接下来只对 64 位浮点数的二进制表示进行分析：</p>
<p>该计算公式遵循科学计数法的规范，对于十进制表示而言，尾数的范围是 <code>0&lt;M&lt;10</code>；对于二进制表示而言，尾数的范围是 <code>0&lt;M&lt;2</code>。浮点数二进制表示，所以此处尾数的范围是：<code>0&lt;M&lt;2</code>，也就是说 M 的整数位始终是 1，所以可以舍去，只保留后面的小数部分，这样就能表示 53 位了。</p>
<p>指数位 E 是一个无符号整数，64 位浮点数中，指数位长度是 11 位，取值范围是 <code>[0~2047]</code>，由于科学计数法中指数可正可负，所以，中间数 1023，<code>[0,1022]</code> 表示为负，<code>[1024,2047]</code> 表示为正</p>
<p>最终的公式变成：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V = (<span class="number">-1</span>)^S * (M + <span class="number">1</span>) * <span class="number">2</span>^(E - <span class="number">1023</span>)</div></pre></td></tr></table></figure></p>
<h3 id="十进制转换为二进制"><a href="#十进制转换为二进制" class="headerlink" title="十进制转换为二进制"></a>十进制转换为二进制</h3><p><strong>十进制整数转换为二进制整数：</strong>采用”除2取余，逆序排列”法。具体做法是：用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>
<p><strong>十进制小数转换成二进制小数：</strong>采用”乘2取整，顺序排列”法。具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/58DF62FC-51A3-4F01-A3C6-0E75DF916261.png" alt=""></p>
<p>（173.8125）10＝（❓）2</p>
<ul>
<li>（173）10＝（10101101）2</li>
<li>（0.8125）10＝（0.1101）2</li>
</ul>
<p>把整数部分和小数部分合并得：（173.8125）10＝（10101101.1101）2</p>
<h3 id="64-位浮点数的二进制表示"><a href="#64-位浮点数的二进制表示" class="headerlink" title="64 位浮点数的二进制表示"></a>64 位浮点数的二进制表示</h3><blockquote>
<p>十进制数和 64 位浮点数二进制相互转换可以访问该网站进行：<br><a href="http://www.binaryconvert.com/convert_double.html" target="_blank" rel="external">http://www.binaryconvert.com/convert_double.html</a></p>
</blockquote>
<p>下面以 0.1 为例，对其进行 64 位二进制表示</p>
<p>0.1 转换成二进制：0.0001100110011001100(1100循环)，即 <code>1.100110011001100x2^-4</code>，得到:</p>
<ul>
<li>指数位 E = -4 + 1023 = 1019 (<code>1019</code> 11 位二进制表示为：01111111011)</li>
<li>尾数位 M = 100110011001100… (舍去首位 1)</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/000D23FF-1ECD-45D1-9BC3-09908A10787B.png" alt=""></p>
<p>所以十进制 0.1 转换成 64 位浮点数二进制表示为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0011111110111001100110011001100110011001100110011001100110011010</span></div></pre></td></tr></table></figure></p>
<p>而将 64 位浮点数二进制的 0.1 转换回十进制时，得到：<code>1.00000000000000005551115123126E-1</code>。</p>
<p>但是：此时输出 <code>x</code> 为啥能得到 0.1 呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0.1</span></div><div class="line"><span class="built_in">console</span>.log(x) <span class="comment">// -&gt; 0.1</span></div></pre></td></tr></table></figure></p>
<p><strong>分析：</strong>尾数位固定长度 52 位，加上省略的整数位 1，就再加上一位，那么尾数最多能表示的数为：2^53=9007199254740992，对应的十进制科学计数尾数是 9.007199254740992，这也是 JavaScript 最多能表示的精度，长度是 16，所以用 <code>toPrecision(16)</code>  来做精度运算，于是：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.10000000000000000555</span>.toPrecision(<span class="number">16</span>) <span class="comment">// -&gt; 0.1</span></div></pre></td></tr></table></figure></p>
<p>如果使用更高精度，那么可能得到的就不是 0.1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0.1</span></div><div class="line"><span class="built_in">console</span>.log(x.toPrecision(<span class="number">21</span>)) <span class="comment">// -&gt; 0.100000000000000005551</span></div></pre></td></tr></table></figure></p>
<p>注意：<code>toPrecision</code> 方法最大指定精度为 21。对于 0.1 而言，64 位二进制表示，最多能表示的精度为 16 位；转换成十进制后 <code>0.100000000000000005551</code>，默认的 JavaScript 使用 16 位进行截取，我们最多能使用 21 位进行截取，注意二者的区别。</p>
<h3 id="toPrecision-和-toFixed"><a href="#toPrecision-和-toFixed" class="headerlink" title="toPrecision 和 toFixed"></a>toPrecision 和 toFixed</h3><ul>
<li><code>toPrecision</code> 方法以指定的精度返回该数值对象的字符串表示，精度是从左至右第一个不为0的数开始数起</li>
<li><code>toFixed</code> 方法使用定点表示法来格式化一个数，是小数点后指定位数取整，从小数点开始数起</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var x = <span class="number">0.12345</span></div><div class="line">x.toPrecision(<span class="number">3</span>) <span class="comment">// -&gt; "0.123"</span></div><div class="line"></div><div class="line">var y = <span class="number">1.234</span></div><div class="line">y.toFixed(<span class="number">3</span>) <span class="comment">// -&gt; "1.234"</span></div></pre></td></tr></table></figure>
<p>这两个方法在截取数字时，都有进行四舍五入处理，但是都存在 BUG，使用要谨慎❗️<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x = <span class="number">0.3456</span></div><div class="line"><span class="function"><span class="title">x</span>.toPrecision(3) // -&gt;</span> <span class="string">"0.346"</span></div><div class="line"><span class="function"><span class="title">x</span>.toFixed(3) // -&gt;</span> <span class="string">"0.346"</span></div><div class="line"></div><div class="line"><span class="comment">// BUG</span></div><div class="line">var y = <span class="number">1.005</span></div><div class="line"><span class="function"><span class="title">y</span>.toPrecision(3) // -&gt;</span> <span class="string">"1.00"</span></div><div class="line"><span class="function"><span class="title">y</span>.toFixed(2) // -&gt;</span> <span class="string">"1.00"</span></div></pre></td></tr></table></figure></p>
<p>原因是：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去了</p>
<h2 id="0-1-0-2-0-30000000000000004"><a href="#0-1-0-2-0-30000000000000004" class="headerlink" title="0.1+0.2=0.30000000000000004"></a>0.1+0.2=0.30000000000000004</h2><p>在计算 <code>0.1+0.2</code> 的时候，现将其转换为二进制，得到的结果也是二进制，然后再将其转换为十进制<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</div><div class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</div><div class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></div></pre></td></tr></table></figure></p>
<p>计算结果 <code>0.0100110011001100110011001100110011001100110011001100111</code> 转换成十进制，就是 <code>0.30000000000000004</code>，这就导致出现了误差。</p>
<p>遇到浮点数误差问题时可以直接使用 <a href="https://github.com/dt-fe/number-precision/blob/master/src/index.js" target="_blank" rel="external">dt-fe/number-precision</a> 完美支持浮点数的加减乘除、四舍五入等运算。</p>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据浮点数算术标准，指数位最大值为 2047，E = 2047 -1023 = 1024，所以 <strong>JavaScript 能表示的数值范围是：<code>[-(2^1024-1), +(2^1024-1)]</code>，即：正负1.7976931348623157乘以10的308次方</strong>，注意：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.pow<span class="function"><span class="params">(<span class="number">2</span>, <span class="number">1023</span>)</span></span></div><div class="line">-&gt; <span class="number">8.98846567431158e+307</span></div><div class="line"></div><div class="line">Math.pow<span class="function"><span class="params">(<span class="number">2</span>, <span class="number">1024</span>)</span></span></div><div class="line">-&gt; Infinity</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ul>
<li><code>Number.MIN_VALUE</code> 属性表示在 JavaScript 中所能表示的最小的正值<ul>
<li>值为 5e-324</li>
<li>MIN_VALUE 属性是 JavaScript 里最接近 0 的正值，而不是最小的负值</li>
<li>小于 MIN_VALUE 的值将会转换为 0</li>
</ul>
</li>
<li><code>Number.MAX_VALUE</code> 属性表示在 JavaScript 里所能表示的最大数值<ul>
<li>值为 1.7976931348623157e+308</li>
<li>大于 MAX_VALUE 的值代表 “Infinity”</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 规定能安全的表示数字(进行精确算术运算)的范围在 ：<code>[-2^53, +2^53]</code>，即正负2的53次方</strong>；对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的准确性，这也是 JavaScript 中安全整数的两个边界：<code>Number.MIN_SAFE_INTEGER</code> 和 <code>Number.MAX_SAFE_INTEGER</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.MIN_SAFE_INTEGER</div><div class="line"><span class="meta">-&gt;</span><span class="bash"> -9007199254740991</span></div><div class="line"></div><div class="line">Number.MAX_SAFE_INTEGER</div><div class="line"><span class="meta">-&gt;</span><span class="bash"> 9007199254740991</span></div></pre></td></tr></table></figure></p>
<p>超过安全整数范围的，计算不保证正确，例如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>)</div><div class="line">-&gt; <span class="number">9007199254740992</span></div><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></div><div class="line">-&gt; <span class="number">9007199254740992</span></div><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></div><div class="line">-&gt; <span class="number">9007199254740994</span></div></pre></td></tr></table></figure></p>
<p>对于不在 <code>[-2^53, +2^53]</code> 范围中的数字，例如 (2^53, 2^63) 之间的数会出现什么情况呢？</p>
<ul>
<li>(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数</li>
<li>(2^54, 2^55) 之间的数会四个选一个，只能精确表示4的倍数</li>
<li>… 依次跳过更多2的倍数</li>
</ul>
<p>下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系，我们常用的 <code>[-2^53, 2^53]</code> 只是最中间非常小的一部分，越往两边越稀疏越不精确。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/real-numbers-floating-point-numbers.jpeg" alt=""></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="external">JavaScript 浮点数陷阱及解法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-brjYnVlXwM3j_SWXImT0Rg.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;JavaScript中所有的数字，无论是整数还是小数，其类型都是 Number，遵循 &lt;a href=&quot;http://grouper.ieee.org/groups/754/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IEEE 754&lt;/a&gt; 程序内部用一个 64 位固定长度的二进制进行存储表示。JavaScript 中的浮点数进行运算时，经常会遇到计算精度问题，例如经典的 &lt;code&gt;0.1+0.2=0.30000000000000004&lt;/code&gt;，本文将探究 JavaScript 的浮点数，并解释为何 &lt;code&gt;0.1+0.2=0.30000000000000004&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="float-point" scheme="http://objcer.com/tags/float-point/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中何时加分号❓</title>
    <link href="http://objcer.com/2017/10/13/hacking-semicolons/"/>
    <id>http://objcer.com/2017/10/13/hacking-semicolons/</id>
    <published>2017-10-13T02:06:47.000Z</published>
    <updated>2017-10-16T09:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读 medium 上的文章 <a href="https://codeburst.io/javascript-async-await-with-foreach-b6ba62bbf404" target="_blank" rel="external">JavaScript: async/await with forEach()</a> 时，作者用了如下一个例子来阐述：async/await 和 forEach 之间的问题。但是仔细琢磨这段代码，发现不对劲啊 😤 明显和我之前的认知不同啊。本文将分析一下其中的蹊跷。</p>
<blockquote>
<p>关于 async/await 和 forEach，我在 <a href="https://objcer.com/2017/10/12/async-await-with-forEach/">当 async/await 遇上 forEach</a> 文中进行了详细分析，读者若对此不熟悉，请先前往了解 👉</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>当 async/await 遇上 forEach，无非就是将回调的异步函数，全部并行执行了，而非我们期望的串行执行。那么对于这段代码，正常的输出结果是：输出：<code>Done</code>，间隔 50 毫秒，输出：1，2，3；但是实际却只输出了 <code>Done</code>，所以我们可以断定这段代码有问题。</p>
<h3 id="考虑箭头函数的问题"><a href="#考虑箭头函数的问题" class="headerlink" title="考虑箭头函数的问题"></a>考虑箭头函数的问题</h3><p>一开始我把目光放到箭头函数上，箭头函数 <code>waitFor</code> 返回一个 Promise 对象， 把箭头函数返回改造成如下，发现，执行结果正确了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms))&#125;</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure></p>
<p>然后，在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">MDN - Arrow functions</a> 发现：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Parenthesize the <span class="keyword">body</span> <span class="keyword">of</span> <span class="keyword">function</span> <span class="title">to</span> <span class="keyword">return</span> <span class="type">an</span> object literal expression:</div><div class="line">params =&gt; (&#123;foo: bar&#125;)</div></pre></td></tr></table></figure></p>
<p>指箭头函数返回对象字面量时，需要用括号包起来。对于如下函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        square: n * n</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以改写成箭头函数如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; &#123; squa<span class="symbol">re:</span> <span class="built_in">n</span> * <span class="built_in">n</span> &#125;</div></pre></td></tr></table></figure></p>
<p>此时调用 <code>square</code> 函数，会发现，无论传入什么参数都没有任何输出，为啥呢？</p>
<p>JavaScript 在解析 <code>square</code> 函数时，遇到 <code>{ square: n * n }</code>，并不是认为其是一个对象字面量，而把它解析成 <code>Labelled Block Statement</code>，label 为 <code>square</code>，statement 为 <code>n * n</code>；由于没有返回值，执行 <code>square</code> 函数会一直返回 undefined，如果返回 <code>n * n</code> 那么代码也可正常执行<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; &#123; squa<span class="symbol">re:</span> return <span class="built_in">n</span> * <span class="built_in">n</span> &#125;</div></pre></td></tr></table></figure></p>
<p>显然这样的代码太奇怪了，最简单的方式是用括号将对象字面量包起来，这样，JavaScript 在解析的时候遇到括号，就不会将 <code>{ square: n * n }</code> 认为是 <code>Labelled Block Statement</code> 了，而是对象字面量，如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; (&#123; squa<span class="symbol">re:</span> <span class="built_in">n</span> * <span class="built_in">n</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>但是，但是，我们分析的这段代码中 <code>waitFor</code> 箭头函数返回的是 Promise 对象，并非对象字面量，所以并不是箭头函数的锅啊。</p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>我们看到如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="string">'b'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div><div class="line">[<span class="string">'b'</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(v)&#125;)  <span class="comment">// 输出： 1, 2, 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;</div><div class="line">[<span class="string">'b'</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(v)&#125;) <span class="comment">// 出错：Uncaught TypeError: &#123;(intermediate value)&#125;.b.forEach is not a function</span></div></pre></td></tr></table></figure></p>
<p>显然 JavaScript 在代码解析的时候，第一行和第二行没有分开啊，我们可以加上分号，这样代码就正常执行了。<br>我们分析的这段代码，在 <code>waitFor</code> 箭头函数后加上分号，代码也就正确执行了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms));</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure></p>
<p>这是为啥呢？似乎在我们的印象中，JavaScript 是可以忽略分号的，莫非有特殊情况。在知乎问题： <a href="https://www.zhihu.com/question/20298345/answer/49551142" target="_blank" rel="external">JavaScript 语句后应该加分号么？</a> 中，我们发现：</p>
<blockquote>
<p>👉 <strong>真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。</strong>我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：<strong>一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。</strong></p>
</blockquote>
<p>也即是在 <code>+ - [ ( /</code> 这五个字符开头时，需要在上一行或者当前行首加上分号，避免 JavaScript 上下行解析出错。</p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>medium 的作者不小心踩了一个坑，少写了一个分号，导致 JavaScript 上下文解析出错，写了一个不恰当的例子，通过一步步分析，还是找到了问题的本质，也算是涨姿势了😋</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.mariusschulz.com/2015/06/09/returning-object-literals-from-arrow-functions-in-javascript" target="_blank" rel="external">Returning Object Literals from Arrow Functions in JavaScript</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读 medium 上的文章 &lt;a href=&quot;https://codeburst.io/javascript-async-await-with-foreach-b6ba62bbf404&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript: async/await with forEach()&lt;/a&gt; 时，作者用了如下一个例子来阐述：async/await 和 forEach 之间的问题。但是仔细琢磨这段代码，发现不对劲啊 😤 明显和我之前的认知不同啊。本文将分析一下其中的蹊跷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 async/await 和 forEach，我在 &lt;a href=&quot;https://objcer.com/2017/10/12/async-await-with-forEach/&quot;&gt;当 async/await 遇上 forEach&lt;/a&gt; 文中进行了详细分析，读者若对此不熟悉，请先前往了解 👉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; waitFor = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;ms&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(r, ms))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].forEach(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (num) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; waitFor(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Done&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>当 async/await 遇上 forEach</title>
    <link href="http://objcer.com/2017/10/12/async-await-with-forEach/"/>
    <id>http://objcer.com/2017/10/12/async-await-with-forEach/</id>
    <published>2017-10-12T08:28:38.000Z</published>
    <updated>2017-10-12T08:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章 <a href="https://objcer.com/2017/10/11/Async-Await/">ES7 中的 async await</a> 中介绍了 async/await。本文将分析介绍当 async/await 遇上 <code>forEach</code> 出现的一些问题和解决方案。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-pWGJIKats-zuumA3RQNEWQ.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getNumbers = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> multi = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (num) &#123;</div><div class="line">        resolve(num * num)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'num not specified'</span>))</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  nums.forEach(<span class="keyword">async</span> x =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test()</div></pre></td></tr></table></figure>
<p>在这个例子中，通过 <code>forEach</code> 遍历的将每一个数字都执行 <code>multi</code> 操作。代码执行的结果是：1 秒后，一次性输出1，4，9。这个结果和我们的预期有些区别，我们是希望每间隔 1 秒，然后依次输出 1，4，9；所以当前代码应该是并行执行了，而我们期望的应该是串行执行。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="JavaScript-中的循环数组遍历"><a href="#JavaScript-中的循环数组遍历" class="headerlink" title="JavaScript 中的循环数组遍历"></a>JavaScript 中的循环数组遍历</h3><p>在 JavaScript 中提供了如下四种循环遍历数组元素的方式：</p>
<ul>
<li><p><code>for</code><br>这是循环遍历数组元素最简单的方式</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">  console.log(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>for-in</code><br><code>for-in</code> 语句以任意顺序遍历一个对象的可枚举属性，对于数组即是数组下标，对于对象即是对象的 key 值。注意 <code>for-in</code> 遍历返回的对象属性都是字符串类型，即使是数组下标，也是字符串 “0”, “1”, “2” 等等。<em>[不推荐使用 <code>for-in</code> 语句]</em></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">index</span> <span class="keyword">in</span> myArray) &#123;</div><div class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>forEach</code><br><code>forEach</code> 方法用于调用数组的每个元素，并将元素传递给回调函数；注意在回调函数中无法使用 <code>break</code> 跳出当前循环，也无法使用 <code>return</code> 返回值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myArray.forEach(<span class="function"><span class="keyword">function</span></span> (<span class="keyword">value</span>) &#123;</div><div class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>for-of</code><br><code>for-of</code> 语句为各种 collection 集合对象专门定制的，遍历集合对象的属性值，注意和 <code>for-in</code> 的区别</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">value</span> <span class="keyword">of</span> myArray) &#123;</div><div class="line">  console.log(<span class="keyword">value</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>在本例中 <code>forEach</code> 的回调函数是一个异步函数，异步函数中包含一个 <code>await</code> 等待 Promise 返回结果，我们期望数组元素串行执行这个异步操作，但是实际却是并行执行了。</p>
<p><code>forEach</code> 的 polyfill 参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">MDN-Array.prototype.forEach()</a>，简单点理解：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Array.prototype.forEach = function (callback) &#123;</div><div class="line">  <span class="comment">// this represents our array</span></div><div class="line">  <span class="keyword">for</span> (let <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="keyword">this</span>.length; <span class="keyword">index</span>++) &#123;</div><div class="line">    <span class="comment">// We call the callback for each entry</span></div><div class="line">    callback(<span class="keyword">this</span>[<span class="keyword">index</span>], <span class="keyword">index</span>, <span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于 <code>for</code> 循环执行了这个异步函数，所以是并行执行，导致了一次性全部输出结果：1，4，9<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line"><span class="comment">//   nums.forEach(async x =&gt; &#123;</span></div><div class="line"><span class="comment">//     var res = await multi(x)</span></div><div class="line"><span class="comment">//     console.log(res)</span></div><div class="line"><span class="comment">//   &#125;)</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; nums.length; index++) &#123;</div><div class="line">    (<span class="keyword">async</span> x =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">      <span class="built_in">console</span>.log(res)</div><div class="line">    &#125;)(nums[index])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>我们可以改造一下 <code>forEach</code>，确保每一个异步的回调执行完成后，才执行下一个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncForEach</span>(<span class="params">array, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</div><div class="line">    <span class="keyword">await</span> callback(array[index], index, array)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  asyncForEach(nums, <span class="keyword">async</span> x =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用 <code>for-of</code> 替代 <code>for-each</code>。</p>
<p><code>for-of</code> 可以遍历各种集合对象的属性值，要求被遍历的对象需要实现迭代器 (iterator) 方法，例如 <code>myObject[Symbol.iterator]()</code> 用于告知 JS 引擎如何遍历该对象。一个拥有 <code>[Symbol.iterator]()</code> 方法的对象被认为是可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zeroesForeverIterator = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如上就是一个最简单的迭代器对象；<code>for-of</code> 遍历对象时，先调用遍历对象的迭代器方法 <code>[Symbol.iterator]()</code>，该方法返回一个迭代器对象(迭代器对象中包含一个 <code>next</code> 方法)；然后调用该迭代器对象上的 <code>next</code> 方法。</p>
<p>每次调用 <code>next</code> 方法都返回一个对象，其中 <code>done</code> 和 <code>value</code> 属性用来表示遍历是否结束和当前遍历的属性值，当 <code>done</code> 的值为 <code>true</code> 时，遍历就停止了。</p>
<figure class="highlight cal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">VAR</span> <span class="keyword">of</span> ITERABLE) &#123;</div><div class="line">  STATEMENTS</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var</span> <span class="variable">$iterator</span> = ITERABLE[Symbol.iterator]();</div><div class="line"><span class="attribute">var</span> <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</div><div class="line"><span class="attribute">while</span> (!<span class="variable">$result</span>.done) &#123;</div><div class="line">  <span class="attribute">VAR</span> = <span class="variable">$result</span>.value;</div><div class="line">  <span class="attribute">STATEMENTS</span></div><div class="line">  <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可以知道 <code>for-of</code> 和 <code>forEach</code> 遍历元素时处理的方式是不同的。使用 <code>for-of</code> 替代 <code>for-each</code> 后代码为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> nums) &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://codeburst.io/understand-async-await-better-7a03aeba60fe" target="_blank" rel="external">Understand async/await better</a><br><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">ES6 In Depth: Iterators and the for-of loop</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章 &lt;a href=&quot;https://objcer.com/2017/10/11/Async-Await/&quot;&gt;ES7 中的 async await&lt;/a&gt; 中介绍了 async/await。本文将分析介绍当 async/await 遇上 &lt;code&gt;forEach&lt;/code&gt; 出现的一些问题和解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-pWGJIKats-zuumA3RQNEWQ.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="async" scheme="http://objcer.com/tags/async/"/>
    
      <category term="await" scheme="http://objcer.com/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>ES7 中的 async await</title>
    <link href="http://objcer.com/2017/10/11/Async-Await/"/>
    <id>http://objcer.com/2017/10/11/Async-Await/</id>
    <published>2017-10-11T06:36:46.000Z</published>
    <updated>2017-10-11T09:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中处理异步操作的回调 (callback) 通常会导致多嵌套的代码块，俗称回调地狱 (callback hell)，这样的代码复杂，可读性，可维护性非常不友好；直达 ES6，Promise 出现，使得我们能够扁平化回调函数，告别回调地狱，写出优雅的代码；但是在实践中发现，Promise 并不完美，如果 Promise 的回调中出现嵌套，依旧会出现回调地狱；而如今，async await 出现了，它提供了一种新的编写异步代码方式，使得异步代码看起来像是同步代码，这正式它的魔力所在。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-ko3KtcVSlzpe3RnTRgJaHw.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// async <span class="function"><span class="keyword">function</span></span> statement：async <span class="function"><span class="keyword">function</span></span> 声明语句</div><div class="line">async <span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>([param[, param[, ... param]]]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div><div class="line"></div><div class="line">// async <span class="function"><span class="keyword">function</span></span> expression：async <span class="function"><span class="keyword">function</span></span> 表达式</div><div class="line">async <span class="function"><span class="keyword">function</span></span> [<span class="keyword">name</span>]([param1[, param2[, ..., paramN]]]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，可以通过 async function 声明语句或者表达式来定义一个异步函数，返回一个 <code>AsyncFunction</code> 对象，二者的区别在于在于函数名称，async function 表达式可以省略函数名称来创建一个匿名的函数。</p>
<p><strong>调用异步函数时会返回一个 promise 对象</strong></p>
<ul>
<li>当这个异步函数返回一个值时，promise 的 resolve 方法将会处理这个返回值</li>
<li>当异步函数抛出异常或者非法值时，promise 的 reject 方法将处理这个异常值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ok'</span></div><div class="line">  <span class="comment">// throw new Error('error')</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error)</div></pre></td></tr></table></figure>
<h2 id="AsyncFunction"><a href="#AsyncFunction" class="headerlink" title="AsyncFunction"></a><code>AsyncFunction</code></h2><blockquote>
<p>注意，<code>AsyncFunction</code> 并不是一个全局对象，我们可以这样获得 <code>AsyncFunction</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).constructor</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>AsyncFunction</code> 构造函数用于创建一个新的 async function 对象，在 JavaScript 中，每一个异步函数都是一个 <code>AsyncFunction</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.constructor)</div><div class="line"><span class="comment">// -&gt; ƒ AsyncFunction() &#123; [native code] &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.__proto__)</div><div class="line"><span class="comment">// -&gt; AsyncFunction &#123;Symbol(Symbol.toStringTag): "AsyncFunction", constructor: ƒ&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> AsyncFunction = <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).constructor</div><div class="line"><span class="keyword">var</span> asyncFun = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(asyncFun <span class="keyword">instanceof</span> AsyncFunction) <span class="comment">// -&gt; true</span></div></pre></td></tr></table></figure></p>
<p>通过 <code>AsyncFunction</code> 构造函数创建异步函数的语法如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new AsyncFunction(<span class="comment">[arg1<span class="comment">[, arg2<span class="comment">[, ...argN]</span>]</span>,]</span> functionBody)</div></pre></td></tr></table></figure></p>
<p>把 <code>AsyncFunction</code> 当成函数调用（省略 <code>new</code> 操作符）也可创建异步函数，如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var AsyncFunction = Object.getPrototypeOf(async function () &#123;&#125;).constructor<span class="comment">;</span></div><div class="line">// var <span class="function"><span class="keyword">func</span> = <span class="title">new</span> <span class="title">AsyncFunction</span><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>)</span></span></div><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">AsyncFunction</span><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>.<span class="title">then</span><span class="params">(console.log)</span> // -&gt; 3</span></div></pre></td></tr></table></figure>
<p>👉 通过 <code>AsyncFunction</code> 构造函数创建的异步函数 在当前上下文不创建闭包；而是在全局作用域创建的。而且只需效率比用 async function 声明语句或者表达式来定义一个异步函数要低，所以一般情况使用 async function 声明语句或者表达式来定义一个异步函数。</p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a><code>await</code></h2><p><code>await</code> 操作符用于等待一个 Promise 返回结果或者某个直接的值，且 <code>await</code> 必须在异步函数 (async function) 上下文中使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnPromise</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    resolve(a)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnValue</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// var a = await returnPromise(2)</span></div><div class="line">  <span class="keyword">var</span> a = <span class="keyword">await</span> returnValue(<span class="number">3</span>)</div><div class="line">  <span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error)</div></pre></td></tr></table></figure></p>
<p>异步函数中执行 <code>await</code> 表达式，这将会使异步函数暂停执行并等待 promise 解析传值后，继续执行异步函数并返回解析值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">second</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, second * <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</div><div class="line">  <span class="keyword">await</span> sleep(<span class="number">3</span>)</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</div><div class="line">&#125;</div><div class="line"></div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>代码执行结果：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Wed Oct <span class="number">11</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">32</span> GMT+<span class="number">0800</span> (CST)</div><div class="line">Promise &#123;<span class="string">[[PromiseStatus]]</span>: <span class="string">"pending"</span>, <span class="string">[[PromiseValue]]</span>: undefined&#125;</div><div class="line">Wed Oct <span class="number">11</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">35</span> GMT+<span class="number">0800</span> (CST)</div></pre></td></tr></table></figure></p>
<p><code>await</code> 串行，并行执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve.bind(<span class="literal">null</span>, a * a), <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 串行执行</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> x = <span class="keyword">await</span> multi(<span class="number">2</span>)</div><div class="line">   <span class="keyword">var</span> y = <span class="keyword">await</span> multi(<span class="number">3</span>)</div><div class="line">   <span class="keyword">return</span> [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 并行执行</span></div><div class="line"><span class="comment">// async function test () &#123;</span></div><div class="line"><span class="comment">//    var res = await Promise.all([multi(2), multi(3)])</span></div><div class="line"><span class="comment">//    return res</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log)</div></pre></td></tr></table></figure></p>
<h2 id="async-await-的优势"><a href="#async-await-的优势" class="headerlink" title="async await 的优势"></a>async await 的优势</h2><p>Promise 有了 async await 的辅助，使其发挥更大的威力，通过 async await 终于可以彻底摆脱回调地狱，以同步方式编写异步代码，代码简洁，十分友好，下面举几个例子 👇</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>try-catch</code> 处理同步，异步错误。如下代码片段一中，<code>try-catch</code> 并不能捕捉 <code>then</code> 方法中 <code>JSON.parse</code> 异常出错；但是在代码片段二中，使用了 async await，使得 <code>try-catch</code> 能捕捉 <code>JSON.parse</code> 可能的异常出错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码块一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    getJSON().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(res) <span class="comment">// 此处可能出错</span></div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代码块二</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON())</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="中间值"><a href="#中间值" class="headerlink" title="中间值"></a>中间值</h3><p>有时会遇到这样的情形：promise1 返回值 value1；promise2 依赖 value1，返回value2；promise3 依赖 value1 和 value2。最简单的做法是通过嵌套解决 promise 间的依赖：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> test () &#123;</div><div class="line">  <span class="keyword">return</span> promise<span class="number">1</span>()</div><div class="line">      .<span class="keyword">then</span>(<span class="keyword">value</span><span class="number">1</span> =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> promise<span class="number">2</span>(valu<span class="number">1</span>)</div><div class="line">          .<span class="keyword">then</span>(<span class="keyword">value</span><span class="number">2</span> =&gt; &#123;</div><div class="line">              <span class="keyword">return</span> promise<span class="number">3</span>(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)</div><div class="line">          &#125;)</div><div class="line">      &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这种简单粗暴的处理方式使我们又掉进回调地狱了；我们可以通过中间变量来抹平这个回调嵌套：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> test () &#123;</div><div class="line">  var <span class="keyword">value</span><span class="number">1</span></div><div class="line">  var <span class="keyword">value</span><span class="number">2</span></div><div class="line">  <span class="keyword">return</span> promise<span class="number">1</span>()</div><div class="line">    .<span class="keyword">then</span>(vle =&gt; &#123;</div><div class="line">        <span class="keyword">value</span><span class="number">1</span> = vle</div><div class="line">        <span class="keyword">return</span> promise<span class="number">2</span>(<span class="keyword">value</span><span class="number">1</span>)</div><div class="line">    &#125;)</div><div class="line">    .<span class="keyword">then</span>(vle =&gt; &#123;</div><div class="line">        <span class="keyword">value</span><span class="number">2</span> = vle</div><div class="line">        <span class="keyword">return</span> promise<span class="number">3</span>(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而通过 async await，可以最优，最简洁的解决这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value1 = <span class="keyword">await</span> promise1()</div><div class="line">  <span class="keyword">var</span> value2 = <span class="keyword">await</span> promise2(value1)</div><div class="line">  <span class="keyword">return</span> promise3(value1, value2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>❗️注意，在上面代码的返回语句 promise3 并没有 <code>await</code>，因为异步函数的会将其返回值隐式封装在 <code>Promise.resolve</code> 中。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="external">MDN-AsyncFunction</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">MDN-async function</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="external">MDN-await</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中处理异步操作的回调 (callback) 通常会导致多嵌套的代码块，俗称回调地狱 (callback hell)，这样的代码复杂，可读性，可维护性非常不友好；直达 ES6，Promise 出现，使得我们能够扁平化回调函数，告别回调地狱，写出优雅的代码；但是在实践中发现，Promise 并不完美，如果 Promise 的回调中出现嵌套，依旧会出现回调地狱；而如今，async await 出现了，它提供了一种新的编写异步代码方式，使得异步代码看起来像是同步代码，这正式它的魔力所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-ko3KtcVSlzpe3RnTRgJaHw.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="async" scheme="http://objcer.com/tags/async/"/>
    
      <category term="await" scheme="http://objcer.com/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X 环绕刘海滚动列表</title>
    <link href="http://objcer.com/2017/10/10/iPhone-X-notch-surround-list/"/>
    <id>http://objcer.com/2017/10/10/iPhone-X-notch-surround-list/</id>
    <published>2017-10-10T07:33:27.000Z</published>
    <updated>2017-10-10T09:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>iPhone X 面市后，其异形屏给交互设计提供了更多想象的空间。在 Twitter 上，这位推友就针对刘海设计了列表环绕刘海滚动的效果。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/4E124A83-5DD5-44C1-AA71-9394E34E8C57.png" alt=""></p>
<p>最近在 codepen 上看到已经有人实现了这个 demo：<a href="https://codepen.io/davvidbaker/pen/KXgPyG" target="_blank" rel="external">https://codepen.io/davvidbaker/pen/KXgPyG</a>，本文将图文结合分析一下实现这个效果的逻辑。</p>
<a id="more"></a>
<h2 id="DOM-结构"><a href="#DOM-结构" class="headerlink" title="DOM 结构"></a>DOM 结构</h2><p><img src="http://7vikhl.com1.z0.glb.clouddn.com/D75661B5-C160-4906-826D-E7908AA9B237.png" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"notch"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>DOM 结构比较简单，主要包括列表 <code>ul</code>，其滚动容器为 <code>class=&quot;inner&quot;</code> 的 DIV；刘海是 <code>class=&quot;notch&quot;</code> 的 DIV。</p>
<h2 id="滚动逻辑"><a href="#滚动逻辑" class="headerlink" title="滚动逻辑"></a>滚动逻辑</h2><p>为了实现列表环绕刘海滚动，需要在滚动事件中，计算处理每一行列表 X 轴方向的位置移动。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/840F60D8-1D25-4B1C-BF50-C9F79DCC2AC9.png" alt=""></p>
<p>如上图列表向下滚动，上方的列表需要向右位移 <code>notch</code> 宽度；对应的，下方的列表需要向左位移 <code>notch</code> 宽度。我们需要对移动进行相应的计算处理，使位移线性变化，从而在滚动时，环绕效果自然。</p>
<h3 id="distFromTop-和-distFromBottom"><a href="#distFromTop-和-distFromBottom" class="headerlink" title="distFromTop 和 distFromBottom"></a><code>distFromTop</code> 和 <code>distFromBottom</code></h3><p>列表在上下滚动过程中分为两部分：</p>
<ul>
<li>向下滚动：上方列表向右移动进入刘海区域，下方列表向左移动离开刘海区域</li>
<li>向上滚动：上方列表向左移动离开刘海区域，下方列表向右移动进入刘海区域</li>
</ul>
<p>这两部分刚好是相对应的，此处我们只分析<strong>上方列表移动进入/离开刘海区域</strong>，即可以了解滚动过程中的逻辑处理。首先介绍两个变量：<code>distFromTop</code> 和 <code>distFromBottom</code></p>
<blockquote>
<p><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置，返回值是一个 <code>DOMRect</code> 对象。<code>DOMRect</code> 对象包含了一组用于描述边框的只读属性 —— left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的，如下图：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/F772D60E-E17B-434F-A970-053BB77E53BB.png" alt=""></p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notchRect = notch.getBoundingClientRect()</div><div class="line"><span class="keyword">let</span> itemRect = item.getBoundingClientRect()</div><div class="line"><span class="keyword">let</span> distFromTop = itemRect.<span class="built_in">bottom</span> - notchRect.<span class="built_in">top</span></div><div class="line"><span class="keyword">let</span> distFromBottom = itemRect.<span class="built_in">top</span> - notchRect.<span class="built_in">bottom</span></div></pre></td></tr></table></figure>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/CB366BB3-C658-4514-96F7-103F5B712AD6.png" alt=""></p>
<p>这两个变量表征当前这一行列表距离上下刘海边界的位置，在滚动过程中根据 <code>distFromTop</code> 和 <code>distFromBottom</code> 变量触发不同的位移逻辑。</p>
<h3 id="位移逻辑"><a href="#位移逻辑" class="headerlink" title="位移逻辑"></a>位移逻辑</h3><p>分析<strong>上方列表移动进入/离开刘海区域</strong>时，列表位移的逻辑。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/7B8867D1-1A5E-4DE6-A6CB-5B64209808F2.png" alt=""><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/E875669C-BEBE-4B6E-A883-EACF4CF29D63.png" alt=""></p>
<p>1️⃣ <strong>阈值：<code>Threshold</code></strong><br>在刘海边界上下 <code>Threshold</code> 区域定义为位移区域，列表进入这一区域即需要进行计算位移量，检测是否进入这一区域的逻辑判断为：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.<span class="keyword">abs</span>(distFromTop) &lt;= Threshold</div></pre></td></tr></table></figure></p>
<p>2️⃣ <strong>计算位移量</strong><br>考虑两个边界情况：</p>
<ul>
<li>当 <code>distFromTop</code> 等于 <code>- Threshold</code>，即列表开始进入刘海区域<br>此时位移量为 0</li>
<li>当 <code>distFromTop</code> 等于 <code>+ Threshold</code>，即列表完全进入刘海区域<br>此时位移量为刘海宽度 <code>NotchWidth</code></li>
</ul>
<p>这个变换过程可以通过线性插值来完成，根据 <code>distFromTop</code> 变量计算在 Y 轴方向的比例关系，从而得到 X 轴方向的位移量。</p>
<blockquote>
<p>关于线性插值参考：<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC" target="_blank" rel="external">维基百科：线性插值</a></p>
</blockquote>
<p>在此处，我们可以简化理解，如下图<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/94A6750A-B927-4B11-8446-8F92DCFA7747.png" alt=""></p>
<p>计算公式如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let lerp = (<span class="name">v0</span>, v1, <span class="literal">t</span>) =&gt; v0 + (<span class="name">v1</span> - v0) * <span class="literal">t</span></div></pre></td></tr></table></figure></p>
<p>在我们分析的这个情形：上方列表向右移动进入刘海区域，对应的调用为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = lerp(<span class="number">0</span>, NotchWidth, (<span class="name">distFromTop</span> + Threshold) / (<span class="name">Threshold</span> * 2))</div></pre></td></tr></table></figure></p>
<p>其他情况，位移量计算分别为：</p>
<ul>
<li>在刘海区域内滚动<br>判断条件：<code>distFromTop &gt; 0 &amp;&amp; distFromBottom &lt; - Threshold</code><br>位移量始终为：刘海宽度 <code>NotchWidth</code></li>
<li>下方列表移动进入/离开刘海区域<br>判断条件：<code>Math.abs(distFromBottom) &lt;= Threshold</code><br>位移量始终为：<code>x = lerp(NotchWidth, 0, (distFromBottom + Threshold) / (Threshold * 2))</code></li>
<li>其他<br>位移量始终为：0</li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>最终实现效果：<a href="https://codepen.io/yingshandeng/pen/JrJRBR?editors=1010" target="_blank" rel="external">https://codepen.io/yingshandeng/pen/JrJRBR?editors=1010</a></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/iPhone%20X%20list.gif" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">html</span>,</div><div class="line">  <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">display</span>: flex;</div><div class="line">      <span class="attribute">justify-content</span>: center;</div><div class="line">      <span class="attribute">align-items</span>: center;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#E3F3FD</span>;</div><div class="line">      <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>, Helvetica, Arial, sans-serif;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.outer</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">640px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">310px</span>;</div><div class="line">    <span class="attribute">min-width</span>: <span class="number">640px</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">310px</span>;</div><div class="line">    <span class="attribute">background-color</span>: white;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">45px</span>;</div><div class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.10),</div><div class="line">      inset <span class="number">0</span> -<span class="number">5px</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.08);</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.10),</div><div class="line">      inset <span class="number">0</span> -<span class="number">5px</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.08);</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.inner</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">610px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">280px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#EBEBEB</span>;</div><div class="line">    <span class="attribute">overflow-x</span>: hidden;</div><div class="line">    <span class="attribute">overflow-y</span>: scroll;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.notch</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">15px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">79px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">22px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">152px</span>;</div><div class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">17px</span>;</div><div class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">17px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#dadada</span>;</div><div class="line">    <span class="attribute">transform-origin</span>: center left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  *<span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</div><div class="line">    <span class="attribute">visibility</span>: hidden;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>天津<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>山西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>内蒙古<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>辽宁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>吉林<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>江苏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>浙江省<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>福建<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>江西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>山东<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>湖北<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>湖南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>广西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>海南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>重庆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>四川<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>贵州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>云南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>西藏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>陕西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>甘肃省<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>青海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>宁夏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>新疆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>台湾<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>香港特别行政区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>澳门<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notch"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">let</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>)</div><div class="line">  <span class="keyword">let</span> items = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</div><div class="line">  <span class="keyword">let</span> notch = <span class="built_in">document</span>.querySelector(<span class="string">'.notch'</span>)</div><div class="line">  <span class="keyword">let</span> notchRect = notch.getBoundingClientRect()</div><div class="line"></div><div class="line">  inner.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">window</span>.requestAnimationFrame(scrollDection)</div><div class="line">  &#125;)</div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</div><div class="line">    notchRect = notch.getBoundingClientRect()</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Threshold = <span class="number">10</span></div><div class="line">  <span class="keyword">const</span> NotchWidth = <span class="number">30</span></div><div class="line">  <span class="keyword">let</span> scrollDection = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> item</div><div class="line">    <span class="keyword">for</span> (item <span class="keyword">of</span> items) &#123;</div><div class="line">      <span class="keyword">let</span> itemRect = item.getBoundingClientRect()</div><div class="line">      <span class="keyword">let</span> distFromTop = itemRect.bottom - notchRect.top</div><div class="line">      <span class="keyword">let</span> distFromBottom = itemRect.top - notchRect.bottom</div><div class="line">      <span class="keyword">let</span> x</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(distFromTop) &lt;= Threshold) &#123;</div><div class="line">        x = lerp(<span class="number">0</span>, NotchWidth, (distFromTop + Threshold) / (Threshold * <span class="number">2</span>))</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distFromTop &gt; <span class="number">0</span> &amp;&amp; distFromBottom &lt; - Threshold) &#123;</div><div class="line">        x = NotchWidth</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(distFromBottom) &lt;= Threshold) &#123;</div><div class="line">        x = lerp(NotchWidth, <span class="number">0</span>, (distFromBottom + Threshold) / (Threshold * <span class="number">2</span>))</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        x = <span class="number">0</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      item.style.transform = <span class="string">`translateX(<span class="subst">$&#123;x&#125;</span>px)`</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> lerp = <span class="function">(<span class="params">v0, v1, t</span>) =&gt;</span> v0 + (v1 - v0) * t</div><div class="line"></div><div class="line">  scrollDection()</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iPhone X 面市后，其异形屏给交互设计提供了更多想象的空间。在 Twitter 上，这位推友就针对刘海设计了列表环绕刘海滚动的效果。&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/4E124A83-5DD5-44C1-AA71-9394E34E8C57.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在 codepen 上看到已经有人实现了这个 demo：&lt;a href=&quot;https://codepen.io/davvidbaker/pen/KXgPyG&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://codepen.io/davvidbaker/pen/KXgPyG&lt;/a&gt;，本文将图文结合分析一下实现这个效果的逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="DEMO" scheme="http://objcer.com/tags/DEMO/"/>
    
  </entry>
  
  <entry>
    <title>实现一个字数限制的输入框</title>
    <link href="http://objcer.com/2017/10/10/implement-a-word-limit-input-box/"/>
    <id>http://objcer.com/2017/10/10/implement-a-word-limit-input-box/</id>
    <published>2017-10-10T07:24:25.000Z</published>
    <updated>2017-10-10T07:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/twitter-input-box.png" alt=""><br>在 Twitter 发推输入框中，有一个字数限制的逻辑，超出字数限制部分的文字会设置背景颜色提示，以便用户进行调整。这是一个很好的交互设计，在 <a href="https://ant.design/docs/spec/feature-cn" target="_blank" rel="external">Ant Design</a> 中也有提到这一点。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/ant-design-input.png" alt=""></p>
<p>本文将介绍如何实现这一字数限制输入框，效果访问：<a href="https://codepen.io/yingshandeng/pen/boRNLx" target="_blank" rel="external">Codepen</a><br><a id="more"></a></p>
<h2 id="超出限制文字设置背景提示"><a href="#超出限制文字设置背景提示" class="headerlink" title="超出限制文字设置背景提示"></a>超出限制文字设置背景提示</h2><p>实现这个输入框关键在于如何实现对超出字数限制部分的文字设置背景颜色，对于输入框一般有两种选择：</p>
<ul>
<li><code>textarea</code> 多行文本输入</li>
<li><code>div</code> 设置 <code>contenteditable=&quot;true&quot;</code></li>
</ul>
<p><code>contenteditable=&quot;true&quot;</code> 的 DIV 节点可以操作其中的 DOM 节点，那么我们可以监听输入区域，用户输入时，获取其中的 <code>innerText</code>，然后进行字数限制判断，设置其 <code>innerHTML</code>，划分两部分，超出部分设置背景颜色，代码大致如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  文字，文字...</div><div class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>超出的文字...<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> editorArea = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-area'</span>)</div><div class="line"></div><div class="line">  editorArea.addEventListener(<span class="string">'input'</span>, (evt) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> normalText;</div><div class="line">    <span class="keyword">var</span> exceedText;</div><div class="line"></div><div class="line">    editorArea.innerHTML = normalText + <span class="string">'&lt;em&gt;'</span> + exceedText + <span class="string">'&lt;/em&gt;'</span></div><div class="line">  &#125;)</div><div class="line">&lt;<span class="regexp">/script</span></div></pre></td></tr></table></figure></p>
<p>在每次输入后，都重新设置 <code>innerHTML</code>，会导致每次输入后，光标位置都跑到输入框起始位置了，看来这种方式不可行 😤</p>
<p>👉 解决方案：用两层 DIV 重叠</p>
<ul>
<li>上层 DIV 节点用于文字输入，背景颜色透明</li>
<li>下层 DIV 节点用于高亮超出部分文字，文字颜色设置为透明，超出部分节点设置背景颜色</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/rich-input.png" alt=""></p>
<h2 id="输入框-placeholder"><a href="#输入框-placeholder" class="headerlink" title="输入框 placeholder"></a>输入框 placeholder</h2><p><code>contenteditable=&quot;true&quot;</code> 的 DIV 设置 placeholder 可以通过 CSS 来解决：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.editor-area</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</div><div class="line">  <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过选择器 <code>:empty</code> 判断输入框中内容是否为空，其实存在一些问题。点击回车的时候，会插入 <code>&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code> 或者 <code>&lt;br&gt;</code>，这部分会影响 <code>:empty</code> 的判断，譬如 DIV 中没有文字，但是存在一个换行时，这样 <code>:empty</code> 的判断就不会生效，placeholder 也就没有显示，所以我们可以通过另一种方式进行判断，通过 JS 手动添加、移除 class 类处理 placeholder 的显示和隐藏：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-class">.editor-area</span><span class="selector-class">.is-showPlaceholder</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: attr(placeholder);</div><div class="line">  <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JS</span></div><div class="line"><span class="selector-tag">editorArea</span><span class="selector-class">.addEventListener</span>(<span class="string">'input'</span>, (evt) =&gt; &#123;</div><div class="line">  <span class="selector-tag">if</span> (editorArea.innerHTML === <span class="string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> ||</div><div class="line">    editorArea.innerHTML === <span class="string">'&lt;br&gt;'</span> ||</div><div class="line">    editorArea.innerHTML === <span class="string">''</span>) &#123;</div><div class="line">    <span class="selector-tag">editorArea</span><span class="selector-class">.classList</span><span class="selector-class">.add</span>(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">  &#125; <span class="selector-tag">else</span> &#123;</div><div class="line">    <span class="selector-tag">editorArea</span><span class="selector-class">.classList</span><span class="selector-class">.remove</span>(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>还有一种解决方式，第一层输入 DIV 节点使用 <code>textarea</code> 替换，<code>textarea</code> 中有 <code>placeholder</code> 属性</p>
<h2 id="中文输入字数统计"><a href="#中文输入字数统计" class="headerlink" title="中文输入字数统计"></a>中文输入字数统计</h2><p>在中文输入是，中文还未输入到输入框，字数就在统计了；合理的是，中文输入 composing 组合过程中不应进行字数统计，在中文输入到输入框后，才进行字数统计。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/CCCDB51D-C8BD-4014-884B-C69A097F35C5.png" alt=""></p>
<p>解决这个问题需要用到 <code>compositionstart</code> 和 <code>compositionend</code> 这两个事件；前者表示输入组合开始，后者表示输入组合结束，在 <code>compositionend</code> 事件中就是我们字数统计的合理时机。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isComposing = <span class="literal">false</span></div><div class="line"></div><div class="line">editorArea.addEventListener(<span class="string">'compositionstart'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  isComposing = <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">editorArea.addEventListener(<span class="string">'compositionend'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  isComposing = <span class="literal">false</span></div><div class="line">  <span class="comment">// 字数统计</span></div><div class="line">  <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">  setCounter(limitCnt - text.length)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>🎏 如需考虑 emoji 字符长度计算的话，参考：<a href="https://objcer.com/2017/07/20/explore-emoji-length/">探究 emoji 字符长度</a></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>效果访问：<a href="https://codepen.io/yingshandeng/pen/boRNLx" target="_blank" rel="external">Codepen</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">html</span>,</div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">display</span>: flex;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#E3F3FD</span>;</div><div class="line">      <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>,Helvetica,Arial,sans-serif;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.rich-editor</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">508px</span>;</div><div class="line">      <span class="attribute">height</span>: auto;</div><div class="line">     <span class="comment">/* max-height: 134px;</span></div><div class="line">      overflow-y: scroll;*/</div><div class="line">      <span class="attribute">margin</span>: auto;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">8px</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#fff</span>;</div><div class="line">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</div><div class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#A4D9F9</span>;</div><div class="line">      <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">#A4D9F9</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.wrapper</span> &#123;</div><div class="line">      <span class="attribute">position</span>: relative;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">min-height</span>: <span class="number">116px</span>;</div><div class="line">      <span class="attribute">z-index</span>: <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span>, <span class="selector-class">.editor-backer</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: auto;</div><div class="line">      <span class="attribute">min-height</span>: <span class="number">116px</span>;</div><div class="line"></div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">word-wrap</span>: break-word;</div><div class="line">      <span class="attribute">background</span>: transparent;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span> &#123;</div><div class="line">      <span class="attribute">outline</span>: none;</div><div class="line">      <span class="attribute">border</span>: none;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span><span class="selector-class">.is-showPlaceholder</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">      <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</div><div class="line">      <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">      <span class="attribute">position</span>: absolute;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-backer</span> &#123;</div><div class="line">      <span class="attribute">position</span>: absolute;</div><div class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">color</span>: transparent;</div><div class="line">      <span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-backer</span> <span class="selector-tag">em</span> &#123;</div><div class="line">      <span class="attribute">background-color</span>: <span class="number">#ffb8c2</span>;</div><div class="line">      <span class="attribute">font-style</span>: normal;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">white-space</span>: pre-wrap;</div><div class="line">      <span class="attribute">word-wrap</span>: break-word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.counter</span> &#123;</div><div class="line">      <span class="attribute">float</span>: right;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#657786</span>;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">text-align</span>: right;</div><div class="line">      <span class="attribute">user-select</span>: none;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.counter</span><span class="selector-class">.max-reached</span> &#123;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#e0245e</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rich-editor"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editor-area"</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">placeholder</span>=<span class="string">"Enter text here..."</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editor-backer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"counter"</span>&gt;</span>140<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="keyword">var</span> editorArea = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-area'</span>)</div><div class="line">      <span class="keyword">var</span> editorBacker = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-backer'</span>)</div><div class="line">      <span class="keyword">var</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>)</div><div class="line">      <span class="keyword">var</span> limitCnt = <span class="number">140</span></div><div class="line">      <span class="keyword">var</span> isComposing = <span class="literal">false</span></div><div class="line"></div><div class="line">      editorArea.addEventListener(<span class="string">'compositionstart'</span>, () =&gt; &#123;</div><div class="line">        isComposing = <span class="literal">true</span></div><div class="line">      &#125;)</div><div class="line">      editorArea.addEventListener(<span class="string">'compositionend'</span>, () =&gt; &#123;</div><div class="line">        isComposing = <span class="literal">false</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">        setCounter(limitCnt - text.length)</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setCounter</span> (<span class="params">cnt</span>) </span>&#123;</div><div class="line">        counter.innerHTML = cnt</div><div class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</div><div class="line">          counter.classList.add(<span class="string">'max-reached'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          counter.classList.remove(<span class="string">'max-reached'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">var</span> inputCompose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (editorArea.innerHTML === <span class="string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> ||</div><div class="line">          editorArea.innerHTML === <span class="string">'&lt;br&gt;'</span> ||</div><div class="line">          editorArea.innerHTML === <span class="string">''</span>) &#123;</div><div class="line">          editorArea.classList.add(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          editorArea.classList.remove(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">        <span class="keyword">let</span> remainingCnt = limitCnt - text.trim().length</div><div class="line">        <span class="keyword">if</span> (remainingCnt &lt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">let</span> allowedText = text.substring(<span class="number">0</span>, limitCnt)</div><div class="line">          <span class="keyword">let</span> refusedText = text.substring(limitCnt)</div><div class="line"></div><div class="line">          editorBacker.innerHTML = allowedText + <span class="string">'&lt;em&gt;'</span> + refusedText + <span class="string">'&lt;/em&gt;'</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          editorBacker.innerHTML = <span class="string">''</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isComposing) &#123;</div><div class="line">          setCounter(remainingCnt)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      inputCompose();</div><div class="line">      editorArea.oninput = inputCompose</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/twitter-input-box.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在 Twitter 发推输入框中，有一个字数限制的逻辑，超出字数限制部分的文字会设置背景颜色提示，以便用户进行调整。这是一个很好的交互设计，在 &lt;a href=&quot;https://ant.design/docs/spec/feature-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ant Design&lt;/a&gt; 中也有提到这一点。&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/ant-design-input.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍如何实现这一字数限制输入框，效果访问：&lt;a href=&quot;https://codepen.io/yingshandeng/pen/boRNLx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="DEMO" scheme="http://objcer.com/tags/DEMO/"/>
    
  </entry>
  
  <entry>
    <title>动态文本自适应绘制到指定大小的 Canvas</title>
    <link href="http://objcer.com/2017/10/10/auto-size-dynamic-text-to-fill-fixed-size-canvas/"/>
    <id>http://objcer.com/2017/10/10/auto-size-dynamic-text-to-fill-fixed-size-canvas/</id>
    <published>2017-10-10T07:15:11.000Z</published>
    <updated>2017-10-10T07:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-UGtq-cSfbuekV8aHalVIAw.png" alt=""><br>本文将探究动态文本如何自适应绘制到指定大小的 Canvas 🎏</p>
<a id="more"></a>
<h2 id="CanvasRenderingContext2D-fillText"><a href="#CanvasRenderingContext2D-fillText" class="headerlink" title="CanvasRenderingContext2D.fillText()"></a><code>CanvasRenderingContext2D.fillText()</code></h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ctx.fillText(<span class="built_in">text</span>, x, y [, maxWidth]);</div></pre></td></tr></table></figure>
<p>在 (x, y) 位置填充文本。如果第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度。如果绘制的文本实际宽度超过 <code>maxWidth</code>，那么会在水平方向上进行缩放，文字可能被压缩变形。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/fillText.png" alt=""></p>
<h2 id="限制宽度"><a href="#限制宽度" class="headerlink" title="限制宽度"></a>限制宽度</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.measureText(text)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>传入要绘制的文本内容，返回绘制到当前 Canvas 时文本的宽度。我们可以设置一个较大的字体，然后递减字体大小，直到绘制的文本宽度满足 Canvas 宽度限制，由此得到文本绘制到 Canvas 中合适的字体大小<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function dynamicFitTextOnCanvas (text, fontface, desiredWidth) &#123;</div><div class="line">  <span class="selector-tag">var</span> <span class="selector-tag">canvas</span> = document.createElement(<span class="string">'canvas'</span>)</div><div class="line">  <span class="selector-tag">var</span> context = <span class="selector-tag">canvas</span>.getContext(<span class="string">'2d'</span>)</div><div class="line">  <span class="comment">// start with a large font size</span></div><div class="line">  <span class="selector-tag">var</span> fontsize = <span class="number">500</span></div><div class="line">  do &#123;</div><div class="line">    context<span class="selector-class">.font</span> = `$&#123;fontsize&#125;px $&#123;fontface&#125;`</div><div class="line">    fontsize --</div><div class="line">  &#125; while (context.measureText(text)<span class="selector-class">.width</span> &gt; desiredWidth)</div><div class="line">  return fontsize</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然字体大小 fontsize 逐次递减一，效率不够好，我们可以通过二分递减来优化这个过程<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function dynamicFitTextOnCanvas (text, fontface, desiredWidth) &#123;</div><div class="line">  <span class="built_in">var</span> canvas = document.createElement('canvas')</div><div class="line">  <span class="built_in">var</span> <span class="built_in">context</span> = canvas.getContext('2d')</div><div class="line">  // start with a large <span class="built_in">font</span> size</div><div class="line">  <span class="built_in">var</span> fontsize = <span class="number">500</span></div><div class="line">  <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, <span class="number">0</span>, fontsize, fontface, desiredWidth)</div><div class="line">&#125;</div><div class="line">function measureTextBinary (<span class="built_in">context</span>, text, <span class="built_in">min</span>, <span class="built_in">max</span>, fontface, desiredWidth) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">max</span> - <span class="built_in">min</span> &lt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">return</span> Math.<span class="built_in">floor</span>(<span class="built_in">min</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">var</span> cur = <span class="built_in">min</span> + (<span class="built_in">max</span> - <span class="built_in">min</span>) / <span class="number">2</span></div><div class="line">  <span class="built_in">context</span>.<span class="built_in">font</span> = `$&#123;cur&#125;px $&#123;fontface&#125;`</div><div class="line">  <span class="built_in">var</span> measureWidth = <span class="built_in">context</span>.measureText(text).<span class="built_in">width</span></div><div class="line">  <span class="keyword">if</span> (measureWidth &gt; desiredWidth) &#123;</div><div class="line">      <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, <span class="built_in">min</span>, cur, fontface, desiredWidth)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, cur, <span class="built_in">max</span>, fontface, desiredWidth)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="限制宽度和高度"><a href="#限制宽度和高度" class="headerlink" title="限制宽度和高度"></a>限制宽度和高度</h2><p>注意到 <code>measureText</code> 方法只能测量绘制文本的宽度，无法得到高度信息；我们可以往 document 中添加一个辅助的 <code>div</code> 节点，设置其 <code>innerText</code> 为要绘制的文本，再设置其字体大小，通过 <code>getBoundingClientRect</code> 方法或者 <code>offsetWidth/offsetHeight</code> 属性就可以得到绘制指定字体大小的文本宽高；同理，通过递减字体大小，使得绘制的文本宽高满足 Canvas 的宽高限制；由于有了前面的经验，我们也用二分递减提高执行效率</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicFitTextOnCanvas</span> (<span class="params">text, fontface, desiredWidth, desiredHeight</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tmpDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.tmp-div'</span>)</div><div class="line">  <span class="keyword">if</span> (!tmpDiv) &#123;</div><div class="line">    tmpDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">    tmpDiv.classList.add(<span class="string">'tmp-div'</span>)</div><div class="line">    tmpDiv.style[<span class="string">'position'</span>] = <span class="string">'absolute'</span></div><div class="line">    tmpDiv.style[<span class="string">'left'</span>] = <span class="string">'-100000px'</span></div><div class="line">    tmpDiv.style[<span class="string">'top'</span>] = <span class="string">'-100000px'</span></div><div class="line">    tmpDiv.style[<span class="string">'visibility'</span>] = <span class="string">'hidden'</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(tmpDiv)</div><div class="line">    tmpDiv.innerText = text</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// start with a large font size</span></div><div class="line">  <span class="keyword">var</span> fontsize = <span class="number">500</span></div><div class="line">  <span class="keyword">return</span> measureDivBinary(tmpDiv, <span class="number">0</span>, fontsize, fontface, desiredWidth, desiredHeight)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">measureDivBinary</span> (<span class="params">tmpDiv, min, max, fontface, desiredWidth, desiredHeight</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (max - min &lt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(min)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> cur = min + (max - min) / <span class="number">2</span></div><div class="line">  tmpDiv.style[<span class="string">'font'</span>] = <span class="string">`<span class="subst">$&#123;cur&#125;</span>px <span class="subst">$&#123;fontface&#125;</span>`</span></div><div class="line">  tmpDiv.style[<span class="string">'line-height'</span>] = <span class="string">`<span class="subst">$&#123;cur&#125;</span>px`</span></div><div class="line">  <span class="keyword">var</span> measureRect = tmpDiv.getBoundingClientRect()</div><div class="line">  <span class="keyword">if</span> (measureRect.width &gt; desiredWidth || measureRect.height &gt; desiredHeight) &#123;</div><div class="line">    <span class="keyword">return</span> measureDivBinary(tmpDiv, min, cur, fontface, desiredWidth, desiredHeight)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> measureDivBinary(tmpDiv, cur, max, fontface, desiredWidth, desiredHeight)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于-line-height"><a href="#关于-line-height" class="headerlink" title="关于 line-height"></a>关于 <code>line-height</code></h3><p><img src="http://7vikhl.com1.z0.glb.clouddn.com/2587037021-55bacfa692fb8.png" alt=""><br>通过上图来理解行高，行距</p>
<ul>
<li><strong>行高</strong> (line-height) 是指文本行基线间的垂直距离，上图中两条红线之间的距离就是行高</li>
<li>上一行的底线和下一行的顶线之间的距离就是<strong>行距</strong>，而同一行顶线和底线之间的距离是 font-size 的大小</li>
<li>行距的一半是半行距: 半行距 = (line-height - font-size) / 2，当 line-height &lt; font-size，半行距为负值，这时候两行之间就会重叠</li>
</ul>
<p>我们发现，font-size 大小即为文字绘制后的实际高度，所以在上面代码中，我们对辅助 <code>div</code> 节点也设置了 <code>line-height = font-size</code>，使得到的文字高度更加精确（去掉了两个半行距）</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>1️⃣ 最小字体大小限制<br>在 Chrome 浏览器中，设定 CSS <code>font-size</code> 小于 12px ，依然会以 12px 进行展示，也就是说 Chrome 浏览器允许设置的最小 <code>font-size</code> 为 12px（Safari 不存在这个问题）。所以如果限制绘制的 Canvas 的宽高小于辅助 <code>div</code> 节点设置 <code>font-size</code> 为 12px 的宽高，那么无法通过计算得到合适绘制的 <code>font-size</code></p>
<p><strong>为了解决这个问题：</strong>只能通过设置一个较大的 <code>font-size</code>，在 Canvas 上进行绘制，然后对这个 Canvas 缩小到限制的宽高</p>
<p>2️⃣ 高清屏绘制文字模糊<br>关于这个问题，解决方案参考：<a href="https://objcer.com/2017/10/10/High-DPI-Canvas-Render/">高清屏中 Canvas 的绘制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-UGtq-cSfbuekV8aHalVIAw.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文将探究动态文本如何自适应绘制到指定大小的 Canvas 🎏&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Canvas" scheme="http://objcer.com/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>高清屏中 Canvas 的绘制</title>
    <link href="http://objcer.com/2017/10/10/High-DPI-Canvas-Render/"/>
    <id>http://objcer.com/2017/10/10/High-DPI-Canvas-Render/</id>
    <published>2017-10-10T07:07:41.000Z</published>
    <updated>2017-10-10T07:11:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/img_html5-canvas-guide2.jpg" alt=""><br>本文将对 Canvas 在高清屏中绘制出现模糊问题进行分析，并给出解决方案 🎏</p>
<a id="more"></a>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><blockquote>
<p>文章：<a href="https://objcer.com/2017/06/19/one-pixel-border/">高清屏一像素边框问题</a> 中对物理像素(physical pixel) 、CSS 像素和 devicePixelRatio 等概念进行了介绍</p>
</blockquote>
<p>在高清屏中，Canvas 绘制时会出现模糊的问题，在文章 <a href="https://www.html5rocks.com/en/tutorials/canvas/hidpi/" target="_blank" rel="external">High DPI Canvas</a> 中对此进行了分析介绍。其中涉及两个概念：<strong>webkitBackingStorePixelRatio</strong> 和 <strong>devicePixelRatio</strong></p>
<p>浏览器绘制 Canvas 渲染到屏幕中分两个过程：</p>
<ul>
<li>绘制过程：<strong>webkitBackingStorePixelRatio</strong><br><code>webkitBackingStorePixelRatio</code> 表示浏览器在绘制 Canvas 到缓存区时的绘制比例，若图片宽高为 <code>200px</code>，<code>webkitBackingStorePixelRatio</code> 为 2，那么 Canvas 绘制这个图片到缓存区时，宽高就为 <code>400px</code></li>
<li>渲染过程：<strong>devicePixelRatio</strong><br>Canvas 显示到屏幕中还需要渲染过程，渲染过程根据 <code>devicePixelRatio</code> 参数将缓存区中的 Canvas 进行缩放渲染到屏幕中</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/canvas-backingstore-device.png" alt=""></p>
<p>分析图片在高清屏中 Canvas 绘制会模糊的原因：<br>1、<code>devicePixelRatio = device pixel / CSS pixel</code><br>如果 <code>devicePixelRatio = 2</code> 那么对于 <code>200px * 200px</code> 的图片要绘制到屏幕中，那么对应的屏幕像素(物理像素) 就是 <code>400px * 400px</code></p>
<p>2、在大部分高清屏中，例如 Macbook Pro 中<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">webkitBackingStorePixelRatio</span> = <span class="number">1</span></div><div class="line"><span class="attr">devicePixelRatio</span> = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>将一个 <code>200px * 200px</code> 的图片 Cavnas 绘制到该屏幕中的流程：</p>
<ul>
<li><code>webkitBackingStorePixelRatio = 1</code><br>绘制到缓存区的大小也为：<code>200px * 200px</code></li>
<li><code>devicePixelRatio = 2</code><br><code>200px * 200px</code> 的图片对应到屏幕像素为 <code>400px * 400px</code>，<code>devicePixelRatio = 2</code> 浏览器就把缓存区的 <code>200px * 200px</code> 宽高分别放大两倍渲染到屏幕中，所以就导致模糊</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li><p>将 Canvas 宽高进行放大，放大比例为：<code>devicePixelRatio / webkitBackingStorePixelRatio</code></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> devicePixelRatio = window.devicePixelRatio || <span class="number">1</span></div><div class="line"><span class="built_in">var</span> backingStoreRatio = <span class="built_in">context</span>.webkitBackingStorePixelRatio ||</div><div class="line">                        <span class="built_in">context</span>.mozBackingStorePixelRatio ||</div><div class="line">                        <span class="built_in">context</span>.msBackingStorePixelRatio ||</div><div class="line">                        <span class="built_in">context</span>.oBackingStorePixelRatio ||</div><div class="line">                        <span class="built_in">context</span>.backingStorePixelRatio || <span class="number">1</span></div><div class="line"></div><div class="line"><span class="built_in">var</span> ratio = devicePixelRatio / backingStoreRatio</div></pre></td></tr></table></figure>
</li>
<li><p>通过 CSS 设置将 Canvas 缩小为原大小</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> oldWidth = canvas.<span class="built_in">width</span>;</div><div class="line"><span class="built_in">var</span> oldHeight = canvas.<span class="built_in">height</span>;</div><div class="line"></div><div class="line">canvas.<span class="built_in">width</span> = oldWidth * ratio;</div><div class="line">canvas.<span class="built_in">height</span> = oldHeight * ratio;</div><div class="line"></div><div class="line">canvas.<span class="built_in">style</span>.<span class="built_in">width</span> = oldWidth + 'px';</div><div class="line">canvas.<span class="built_in">style</span>.<span class="built_in">height</span> = oldHeight + 'px';</div></pre></td></tr></table></figure>
</li>
</ul>
<p>举例分析一下 Canvas 绘制图片，文字的适配方案：<br>1、对于图片绘制 <code>drawImage</code> 方法：<br>由于 Canvas 放大后，相应的绘制图片时也要放大，有两种方式：</p>
<ul>
<li><p><code>drawImage</code> 目标宽高分别乘以 <code>ratio</code></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">context</span>.drawImage(<span class="built_in">image</span>, srcx, srcy, srcw, srch, desx, desy, desw * ratio, desh * ratio);</div></pre></td></tr></table></figure>
</li>
<li><p><code>context.scale</code> 缩放</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">context</span>.<span class="built_in">scale</span>(ratio, ratio)</div><div class="line">// 绘制图片</div><div class="line"><span class="built_in">context</span>.drawImage(...)</div><div class="line"><span class="built_in">context</span>.<span class="built_in">scale</span>(<span class="number">1</span>/ratio, <span class="number">1</span>/ratio)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此种方式在绘制图片之前，调用 <code>scale</code> 设置 Canvas 缩放变换；绘制完成后，需要重置 Canvas 的缩放变换。推荐使用这种方式 👍</p>
<p>2、对于文字绘制 <code>fillText</code> 方法<br>由于 Canvas 放大了，绘制文字时，字体也要放大，绘制完成后，字体再缩小回原大小<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">context</span>.<span class="built_in">font</span> = <span class="built_in">context</span>.<span class="built_in">font</span>.replace(</div><div class="line">  /(\d+)(px|em|<span class="built_in">rem</span>|pt)/g,</div><div class="line">  function(w, m, u) &#123;</div><div class="line">    <span class="built_in">return</span> (m * ratio) + u;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line">// 绘制文字</div><div class="line"><span class="built_in">context</span>.fillText(...)</div><div class="line"><span class="built_in">context</span>.<span class="built_in">font</span> = <span class="built_in">context</span>.<span class="built_in">font</span>.replace(</div><div class="line">  /(\d+)(px|em|<span class="built_in">rem</span>|pt)/g,</div><div class="line">  function(w, m, u) &#123;</div><div class="line">    <span class="built_in">return</span> (m / ratio) + u;</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>关于 Canvas 在高清屏绘制的兼容，github 有一个 polyfill <a href="https://github.com/jondavidjohn/hidpi-canvas-polyfill" target="_blank" rel="external">jondavidjohn/hidpi-canvas-polyfill</a> 但是这仓库并没有考虑 <code>drawImage</code>，如果直接使用这个 polyfill，在绘制图片时，宽高都会变小；我 fork 了这个仓库，并增加了 <code>drawImage</code> 处理：<a href="https://github.com/YingshanDeng/hidpi-canvas-polyfill" target="_blank" rel="external">YingshanDeng/hidpi-canvas-polyfill</a>。更多 Canvas 绘制方法的兼容参考这个仓库的源码。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1️⃣ <code>webkitBackingStorePixelRatio</code> 在 Chrome 中已经废弃，详细参考：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=277205" target="_blank" rel="external">https://bugs.chromium.org/p/chromium/issues/detail?id=277205</a></p>
<p>2️⃣ 现在高清屏中 Canvas 绘制图片 <code>drawImage</code>，不需要经过如上处理也不会出现模糊的情况了（只在 Mackbook Pro, iPhone 6S 上分别测试过），这点在网上并没有找到更多的信息</p>
<p>但是 Canvas 的其他绘制方法例如绘制文字 <code>fillText</code> 不经过处理高清屏中绘制仍然会模糊，所以还是需要这个polyfill：<a href="https://github.com/YingshanDeng/hidpi-canvas-polyfill" target="_blank" rel="external">YingshanDeng/hidpi-canvas-polyfill</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/img_html5-canvas-guide2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文将对 Canvas 在高清屏中绘制出现模糊问题进行分析，并给出解决方案 🎏&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Canvas" scheme="http://objcer.com/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>剖析 iOS 11 网页适配问题</title>
    <link href="http://objcer.com/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11-iPhone-X/"/>
    <id>http://objcer.com/2017/09/21/Understanding-the-WebView-Viewport-in-iOS-11-iPhone-X/</id>
    <published>2017-09-21T07:55:40.000Z</published>
    <updated>2017-11-05T15:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间 9 月 12 日凌晨，苹果在乔布斯剧院发布了 iPhone X。iPhone X 正面的全面屏上方有一条刘海，对于如何适配 iPhone X，苹果的 <a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="external">Human Interface Guidelines</a> 文档已经给出详细的说明。</p>
<p>苹果对于 iPhone X 的设计布局意见如下：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/iphone-x-safe-area.png" alt=""><br>核心内容应该处于 <strong>Safe area</strong> 确保不会被设备圆角(corners)，传感器外壳(sensor housing，齐刘海) 以及底部的 Home Indicator 遮挡。</p>
<p>本文将剖析两则在  iPhone X 异形屏和 iOS 11 网页适配中遇到的问题及解决方案。<br><a id="more"></a></p>
<h2 id="iPhone-X-Safari-横屏显示左右白边问题"><a href="#iPhone-X-Safari-横屏显示左右白边问题" class="headerlink" title="iPhone X Safari 横屏显示左右白边问题"></a>iPhone X Safari 横屏显示左右白边问题</h2><p>iPhone X Safari 在横屏状态下，网页左右两侧可能会出现白边，如下：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/424F6040-3325-4AD5-8683-6D55AE4D9BEA.png" alt=""></p>
<p>因为 iPhone X 会将网页内容显示在 Safe area 导致的，解决这一问题，我们需要将背景颜色填充整个屏幕区域，而网页内容处于 Safe area。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/47C98605-A351-4903-BDC7-C1E6878D0485.png" alt=""></p>
<h3 id="解决方案一：background-color"><a href="#解决方案一：background-color" class="headerlink" title="解决方案一：background-color"></a>解决方案一：<code>background-color</code></h3><p>如果网页设置了一个背景颜色，那么最简单解决方案是，在 <code>body</code> 节点设置 <code>background-color</code>，使背景颜色填充整个屏幕，从而解决横屏显示左右白边的问题</p>
<h3 id="解决方案二：viewport-fit-safe-area-inset"><a href="#解决方案二：viewport-fit-safe-area-inset" class="headerlink" title="解决方案二：viewport-fit + safe-area-inset-*"></a>解决方案二：<code>viewport-fit</code> + <code>safe-area-inset-*</code></h3><p>在 iOS 11 中苹果为 Web 新增两个内容 <code>viewport-fit</code> + <code>safe-area-inset-*</code></p>
<blockquote>
<p>❗️注意：<code>viewport-fit</code> 和 <code>safe-area-inset-*</code> 只对于 WKWebView 有效，在 UIWebView 中无效</p>
</blockquote>
<p>1️⃣、<code>viewport-fit</code> 用于设置网页在可视窗口的布局方式</p>
<blockquote>
<p>文档：<a href="https://drafts.csswg.org/css-round-display/#viewport-fit-descriptor" target="_blank" rel="external">CSS Round Display Spec</a></p>
</blockquote>
<p>这个属性可设置为：</p>
<ul>
<li><code>contain</code>: The viewport should fully contain the web content. 可视窗口完全包含网页内容</li>
<li><code>cover</code>: The web content should fully cover the viewport.  网页内容完全覆盖可视窗口</li>
<li><code>auto</code>: The default value, <code>contain</code></li>
</ul>
<p>对于 iPhone X 之前的 iPhone 设备屏幕为规则的矩形，网页内容都可以完整展示；但是对于 iPhone X 是异形屏幕，通过 <code>viewport-fit</code> 可以设置网页内容在可视窗口中的显示规则，通过下图可以辅助理解<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/viewport-fit.png" alt=""></p>
<p>我们知道默认情况下 <code>viewport-fit=auto</code> 即为 <code>viewport-fit=contain</code>，在 iPhone X 中，相当于网页内容展示在 Safe area，这样也就是横屏显示时出现白边的原因了，所以我们可以设置 <code>viewport-fit=cover</code> 即可解决问题<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="attribute">name</span>=<span class="string">"viewport"</span> <span class="attribute">content</span>=<span class="string">"width=device-width, initial-scale=1.0, viewport-fit=cover"</span>&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/Screen-Shot-2017-09-14-at-14.19.31.png" alt=""></p>
<p>注意到应用 <code>viewport-fit=cover</code> 之后，网页右上角，menu 按键和 in 按键被圆角，传感器外壳（齐刘海）裁剪掉了 😲</p>
<p>2️⃣、<code>safe-area-inset-*</code><br><strong>在设置 <code>viewport-fit=cover</code> 之后</strong>，Web 中会新增四个常量：</p>
<ul>
<li>safe-area-inset-top</li>
<li>safe-area-inset-right</li>
<li>safe-area-inset-left</li>
<li>safe-area-inset-bottom</li>
</ul>
<p>分别表示 Safe area 和可视窗口 viewport 顶部，右边，左边，底部的间距，可以用于设置 <code>margin</code>, <code>padding</code>, 或者绝对定位时 <code>left</code>, <code>top</code></p>
<blockquote>
<p>❗️注意：在横屏和竖屏状态下，<code>safe-area-inset-*</code> 的值不同</p>
</blockquote>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/0C3B9577-094E-411C-9ED3-AA481FA3A50A.png" alt=""></p>
<p>为了解决应用 <code>viewport-fit=cover</code> 之后，有些显示内容被裁剪的问题，我们可以通过添加边距使得网页主要内容处于 Safe area 中不被裁剪，解决方式如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">padding</span>: constant(safe-<span class="meta">area</span>-inset-top) constant(safe-<span class="meta">area</span>-inset-right) constant(safe-<span class="meta">area</span>-inset-<span class="keyword">bottom) </span>constant(safe-<span class="meta">area</span>-inset-left)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/Screen-Shot-2017-09-14-at-14.07.11-1.png" alt=""></p>
<h2 id="iOS-11-WebView-中状态栏问题"><a href="#iOS-11-WebView-中状态栏问题" class="headerlink" title="iOS 11 WebView 中状态栏问题"></a>iOS 11 WebView 中状态栏问题</h2><p><strong>问题描述：</strong><br>在 iOS 11 由于 safe area，状态栏的表现有点不同。如果页面顶部有一个 header bar，设置 <code>position: fixed; top: 0px;</code> 那么页面滚动过程中，会出现如下问题：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/iPhone%206s.gif" alt="iPhone 6S"><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/iPhone%20X.gif" alt="iPhone X"></p>
<p>header bar 没有固定在最顶部，上下滚动过程中，我们可以看到网页内容从 status bar 下方穿过<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/status-bar-problem.png" alt=""></p>
<p><strong>重现问题：</strong><br>创建一个 iOS 项目，视图中添加一个 <code>WKWebView</code>，加载百度首页<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">  [<span class="keyword">super</span> viewDidLoad];</div><div class="line">  <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">  <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</div><div class="line">  [webView loadRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.baidu.com"</span>]]];</div><div class="line">  [<span class="keyword">self</span>.view addSubview:webView];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>剖析问题：</strong><br>1、这个问题同样也是由于 safe area 导致，虽然 header bar 位置信息为 <code>position: fixed; top: 0px;</code>，但这个位置也是相对于 safe area 而言的，所以看到 header bar 并没有位于屏幕最顶部。👉 在 viewport meta 标签，添加 <code>viewport-fit=cover</code> 即可解决此问题<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/2B17E02C-7C0C-4282-9369-F5E6D1C75836.png" alt=""></p>
<p>2、虽然 header bar 固定到屏幕最上方，但是很明显在 iPhone X 中却被圆角和齐刘海裁剪了内容，这怎么办呢？👉 为 header bar 添加 <code>padding-top</code> 即可解决此问题<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">  <span class="comment">/* Status bar height on iOS 10 */</span></div><div class="line">  <span class="attribute">padding-top</span>: <span class="number">20px</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Status bar height on iOS 11+ */</span></div><div class="line">  <span class="attribute">padding-top</span>: <span class="built_in">constant</span>(safe-area-inset-top);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/FCF9D371-F2B5-44FE-9FFC-DC991E39FD2C.png" alt=""></p>
<h2 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h2><blockquote>
<p><strong>Webkit 文档</strong> <a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/" target="_blank" rel="external">Designing Websites for iPhone X</a></p>
</blockquote>
<h3 id="CSS-function-env"><a href="#CSS-function-env" class="headerlink" title="CSS function env()"></a>CSS function <code>env()</code></h3><blockquote>
<p>The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.</p>
</blockquote>
<p><strong>Webkit 在 iOS 11 中新增 CSS function：<code>env()</code> 替代 <code>constant()</code></strong>，文档中推荐使用 <code>env()</code>，而 <code>constant()</code> 从 Safari Technology Preview 41 和 iOS 11.2 beta 开始会被废弃。<code>env()</code> 用法如同 <code>var()</code>，在不支持的 <code>env()</code> 的浏览器中，会自动忽略这一样式规则，不影响网页正常展示：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.post</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">12px</span>;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</div><div class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CSS-function-min-和-max"><a href="#CSS-function-min-和-max" class="headerlink" title="CSS function min() 和 max()"></a>CSS function <code>min()</code> 和 <code>max()</code></h3><p>在 iPhone X 设备设置网页边距的时候，可能会遇到这样的情形：我们通过 <code>env(safe-area-inset-left)</code> 和 <code>env(safe-area-inset-right)</code> 设置了页面展示左右边距：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.post</span> &#123;</div><div class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</div><div class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在横屏状态下显示正常，但是在竖屏状态下，常量 <code>safe-area-inset-left</code> 和 <code>safe-area-inset-right</code> 都为 0，所以会导致页面展示左右边距为 <code>0px</code>，如下图左，正常情况应该是如下图右，竖屏状态下页面左右也有边距。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/css-funciton-min-max.png" alt=""></p>
<p>Webkit 从 Safari Technology Preview 41 和 iOS 11.2 beta 开始，新增 CSS function：<code>min()</code> 和 <code>max()</code>，这两个就可以解决这个问题了。</p>
<blockquote>
<p>Both functions take an arbitrary number of arguments and return the minimum or maximum. They can be used inside of calc(), or nested inside each other, and both functions allow calc()-like math inside of them.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@supports(padding: <span class="built_in">max</span>(0px)) &#123;</div><div class="line">  .post &#123;</div><div class="line">    padding-<span class="keyword">left</span>: <span class="built_in">max</span>(12px, env(safe-area-inset-<span class="keyword">left</span>));</div><div class="line">    padding-<span class="keyword">right</span>: <span class="built_in">max</span>(12px, env(safe-area-inset-<span class="keyword">right</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>❗️此处需要使用 <code>@supports</code> 去检测浏览器是否支持 <code>min()</code> 和 <code>max()</code></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="external">Human Interface Guidelines-iPhone X</a><br><a href="http://stephenradford.me/removing-the-white-bars-in-safari-on-iphone-x/" target="_blank" rel="external">Removing the White Bars in Safari on iPhone X</a><br><a href="https://ayogo.com/blog/ios11-viewport/" target="_blank" rel="external">Understanding the WebView Viewport in iOS 11</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;北京时间 9 月 12 日凌晨，苹果在乔布斯剧院发布了 iPhone X。iPhone X 正面的全面屏上方有一条刘海，对于如何适配 iPhone X，苹果的 &lt;a href=&quot;https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Human Interface Guidelines&lt;/a&gt; 文档已经给出详细的说明。&lt;/p&gt;
&lt;p&gt;苹果对于 iPhone X 的设计布局意见如下：&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/iphone-x-safe-area.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;核心内容应该处于 &lt;strong&gt;Safe area&lt;/strong&gt; 确保不会被设备圆角(corners)，传感器外壳(sensor housing，齐刘海) 以及底部的 Home Indicator 遮挡。&lt;/p&gt;
&lt;p&gt;本文将剖析两则在  iPhone X 异形屏和 iOS 11 网页适配中遇到的问题及解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://objcer.com/categories/CSS/"/>
    
    
      <category term="viewport-fit" scheme="http://objcer.com/tags/viewport-fit/"/>
    
      <category term="iOS 11" scheme="http://objcer.com/tags/iOS-11/"/>
    
  </entry>
  
  <entry>
    <title>Implementing Promise</title>
    <link href="http://objcer.com/2017/09/06/Implementing-Promise/"/>
    <id>http://objcer.com/2017/09/06/Implementing-Promise/</id>
    <published>2017-09-06T14:10:50.000Z</published>
    <updated>2017-09-06T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/Promises:A+.png" alt=""></p>
<a id="more"></a>
<p>本文将剖析 Promise 的内部结构，实现符合 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范的 Promise，并且通过 <a href="https://github.com/promises-aplus/promises-tests#promisesa-compliance-test-suite" target="_blank" rel="external">promises-aplus/promises-tests</a> 测试。</p>
<h2 id="JavaScript-Promise-标准解读"><a href="#JavaScript-Promise-标准解读" class="headerlink" title="JavaScript Promise 标准解读"></a>JavaScript Promise 标准解读</h2><p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 Promise resolve 的终值或者 Promise reject 的原因。</p>
<blockquote>
<p>详细 <strong>Promise A+ 规范</strong> 参考：<a href="https://promisesaplus.com/" target="_blank" rel="external">英文</a>  <a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/" target="_blank" rel="external">中文</a></p>
</blockquote>
<h3 id="Promise-States"><a href="#Promise-States" class="headerlink" title="Promise States"></a>Promise States</h3><ul>
<li>一个 Promise 的当前状态必须为以下三种状态中的一种:<ul>
<li>PENDING</li>
<li>FULFILLED</li>
<li>REJECTED</li>
</ul>
</li>
<li>Promise 的初始状态为 PENDING，由此状态可转换为 FULFILLED 或者 REJECTED，一旦状态确定，就不能再次转换为其他状态，此状态称之为 settle</li>
</ul>
<h3 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a><code>then</code> 方法</h3><ul>
<li><p>一个 Promise 必须提供 <code>then</code> 方法，该方法接收两个参数：</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">promise</span>.<span class="built_in">then</span>(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
</li>
<li><p><code>then</code> 方法必须返回一个 Promise 对象</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">promise2</span> = promise1.then(<span class="literal">on</span>Fulfilled, <span class="literal">on</span>Rejected)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="The-Promise-Resolution-Procedure"><a href="#The-Promise-Resolution-Procedure" class="headerlink" title="The Promise Resolution Procedure"></a>The Promise Resolution Procedure</h3><p>不同实现的 Promise 需要可以无缝相互调用(interoperable)，例如：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> MyPromise 表示自己实现的 Promise</div><div class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="number">1</span>)</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> Promise.reject(<span class="number">2</span>) <span class="regexp">//</span> ES6 Promise</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><h3 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</div><div class="line">  <span class="comment">// The constructor function</span></div><div class="line">  <span class="keyword">constructor</span> (executor) &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._isFunction(executor)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise argument error:'</span> + executor.toString())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._status = PENDING</div><div class="line">    <span class="keyword">this</span>._v = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>._onResolvedCb = []</div><div class="line">    <span class="keyword">this</span>._onRejectedCb = []</div><div class="line"></div><div class="line">    executor(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// 执行操作...</span></div><div class="line">  <span class="comment">// 操作成功：调用 resolve，传入 value</span></div><div class="line">  resolve(value)</div><div class="line">  <span class="comment">// 操作失败: 调用 reject，传入 reason</span></div><div class="line">  reject(reason)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>构造函数中，<code>_onResolvedCb</code> 和 <code>_onRejectedCb</code> 属性分别为 Promise resolved/rejected 的回调函数集，因为在 Promise 结束（settle）之前，可能有多个 <code>then</code> 挂在该 promise 上，即有多个回调事件；</li>
<li>构造函数接收一个 executor 函数，函数中的操作执行结束后，若成功，调用 resolve 并传入 value；若失败，调用 reject 并传入 reason</li>
</ul>
<p>接下来实现 <code>resolve</code> 和 <code>reject</code> 这两个函数，这两个函数类似，首先判断当前 Promise 状态后，变更其状态；并记录 resolved 的终值和 rejected 的原因；最后执行回调函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">resolve (value) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>._status = FULFILLED</div><div class="line">  <span class="keyword">this</span>._v = value</div><div class="line"></div><div class="line">  let fn</div><div class="line">  <span class="keyword">while</span> ((fn = <span class="keyword">this</span>._onResolvedCb.shift())) &#123;</div><div class="line">    fn.call(<span class="keyword">this</span>, value)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">reject (reason) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="then-方法-1"><a href="#then-方法-1" class="headerlink" title="then 方法"></a><code>then</code> 方法</h3><p>Promise 对象的 <code>then</code> 方法用来注册 Promise resolved 或者 rejected 后的回调函数，<code>then</code> 方法返回一个新的 Promise 对象<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">then (onResolved, onRejected) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">PENDING:</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> <span class="string">FULFILLED:</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> <span class="string">REJECTED:</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>then</code> 方法返回的新 Promise 对象中，需要根据前一个 Promise 对象的不同状态来处理：<ul>
<li>若是 FULFILLED，则直接执行 <code>onResolved</code> 回调函数。如果 <code>onResolved</code> 的返回值又是一个 Promise 对象，那么继续通过 <code>then</code> 方法构造 Promise 链；否则，调用 <code>resolve</code> 函数结束新的 Promise 对象</li>
<li>若是 REJECTED，处理逻辑同 FULFILLED</li>
<li>若是 PENDING，则将 <code>onResolved</code> 和 <code>onRejected</code> 回调函数放到回调函数集中</li>
</ul>
</li>
</ul>
<p>最终得到如下简易版本的 <code>then</code> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">then (onResolved, onRejected) &#123;</div><div class="line">  <span class="comment">// Promise 值穿透</span></div><div class="line">  onResolved = <span class="keyword">this</span>._isFunction(onResolved) ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</div><div class="line">  onRejected = <span class="keyword">this</span>._isFunction(onRejected) ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123; <span class="keyword">throw</span> r &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</div><div class="line">      <span class="keyword">case</span> PENDING:</div><div class="line">        <span class="keyword">this</span>._onResolvedCb.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">          <span class="comment">// 执行 onResolved 或者 onRejected 可能出现异常，需要 try-catch</span></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">var</span> x = onResolved(value)</div><div class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line">              x.then(resolve, reject)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              resolve(x)</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">this</span>._onRejectedCb.push(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">var</span> x = onRejected(reason)</div><div class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line">              x.then(resolve, reject)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              resolve(x)</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> FULFILLED:</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">var</span> x = onResolved(<span class="keyword">this</span>._v)</div><div class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line">              x.then(resolve, reject)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              resolve(x)</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> REJECTED:</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">var</span> x = onRejected(<span class="keyword">this</span>._v)</div><div class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line">              x.then(resolve, reject)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              resolve(x)</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            reject(e)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> promise2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>代码剖析注意：</strong><br>1、<code>then</code> 方法的两个回调函数执行过程中可能抛出异常，所以在执行时，需要 <code>try-catch</code> 包起来<br>2、Promise 值穿透<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">  resolve(<span class="number">1</span>)</div><div class="line">&#125;)</div><div class="line">.<span class="keyword">then</span>()</div><div class="line">.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>, value)</div><div class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span>, reason)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如上代码正确的执行结果为输出：1；注意到第一个 <code>then</code> 方法并没有传入回调函数，所以在执行的时候，会抛出异常，提示：<code>TypeError: onResolved is not a function</code>；在添加 <code>try-catch</code> 后，可以正常执行；catch 到异常后，执行 <code>reject(e)</code>，于是第二个 <code>then</code> 方法中的 reject 回调函数执行了。</p>
<p>为了解决这个问题，我们需要判断 <code>then</code> 方法传入的两个参数是否为函数，若不是，直接返回 value 或者抛出 reason。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">onResolved = <span class="keyword">this</span>._isFunction(onResolved) ? onResolved : <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> </span>&#123; <span class="keyword">return</span> v &#125;</div><div class="line">onRejected = <span class="keyword">this</span>._isFunction(onRejected) ? onRejected : <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> </span>&#123; <span class="keyword">throw</span> r &#125;</div></pre></td></tr></table></figure></p>
<h3 id="不同-Promise-的交互"><a href="#不同-Promise-的交互" class="headerlink" title="不同 Promise 的交互"></a>不同 Promise 的交互</h3><p><code>then</code> 方法传入的两个回调函数 <code>onResolved</code> 和 <code>onRejected</code> 执行后，返回值 <code>x</code> 可能是一个 Promise 对象，也即是 <code>thenable</code>，为了确保调用 <code>x</code> 上的 <code>then</code> 方法成功，我们需要实现标准中 <strong><a href="https://promisesaplus.com/#the-promise-resolution-procedure" target="_blank" rel="external">2.3.The Promise Resolution Procedure</a></strong> 的内容，这样即使实现方式不同，但遵循标准，不同实现的 Promise 之间就可以交互使用了。</p>
<p>标准对此说明的非常详细，对照着标准阅读以下代码，有助理解。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The Promise Resolution Procedure</span></div><div class="line"><span class="comment">// https://promisesaplus.com/#the-promise-resolution-procedure</span></div><div class="line"><span class="keyword">static</span> resolvePromise (promise2, x, resolve, reject) &#123;</div><div class="line">  <span class="keyword">var</span> then</div><div class="line">  <span class="comment">// multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored</span></div><div class="line">  <span class="keyword">var</span> hasBeenCalled = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="comment">// 2.3.1 If promise and x refer to the same object</span></div><div class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</div><div class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise!'</span>))</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 2.3.2 If x is a promise</span></div><div class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (x._status === PENDING) &#123; <span class="comment">// 2.3.2.1</span></div><div class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="built_in">Promise</span>.resolvePromise(promise2, v, resolve, reject)</div><div class="line">      &#125;, reject)</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.3.2.2  2.3.2.3</span></div><div class="line">      x.then(resolve, reject)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 2.3.3 Otherwise, if x is an object or function</span></div><div class="line">  <span class="keyword">if</span> ((x !== <span class="literal">null</span>) &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">'object'</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>))) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      then = x.then <span class="comment">// 2.3.3.1</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123; <span class="comment">// 2.3.3.3</span></div><div class="line">        then.call(x, <span class="function"><span class="keyword">function</span> <span class="title">rs</span> (<span class="params">y</span>) </span>&#123; <span class="comment">// 2.3.3.3.1</span></div><div class="line">          <span class="keyword">if</span> (hasBeenCalled) <span class="keyword">return</span> <span class="comment">// 2.3.3.3.3</span></div><div class="line">          hasBeenCalled = <span class="literal">true</span></div><div class="line">          <span class="built_in">Promise</span>.resolvePromise(promise2, y, resolve, reject)</div><div class="line">        &#125;, <span class="function"><span class="keyword">function</span> <span class="title">rj</span> (<span class="params">r</span>) </span>&#123; <span class="comment">// 2.3.3.3.2</span></div><div class="line">          <span class="keyword">if</span> (hasBeenCalled) <span class="keyword">return</span> <span class="comment">// 2.3.3.3.3</span></div><div class="line">          hasBeenCalled = <span class="literal">true</span></div><div class="line">          reject(r)</div><div class="line">        &#125;)</div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.3.3.4</span></div><div class="line">        resolve(x)</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 2.3.3.2</span></div><div class="line">      <span class="keyword">if</span> (hasBeenCalled) <span class="keyword">return</span> <span class="comment">// 2.3.3.3.4.1</span></div><div class="line">      hasBeenCalled = <span class="literal">true</span></div><div class="line">      reject(e) <span class="comment">// 2.3.3.3.4.2</span></div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.3.4</span></div><div class="line">    resolve(x)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>then</code> 方法中需要修改，<code>onResolved</code> 和 <code>onRejected</code> 执行后，调用如上的 <code>resolvePromise (promise2, x, resolve, reject)</code> 方法<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">case</span> FULFILLED:</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> x = onResolved(<span class="keyword">this</span>._v)</div><div class="line">      <span class="built_in">Promise</span>.resolvePromise(promise2, x, resolve, reject)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      reject(e)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">break</span></div><div class="line"><span class="keyword">case</span> REJECTED:</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">var</span> x = onRejected(<span class="keyword">this</span>._v)</div><div class="line">      <span class="built_in">Promise</span>.resolvePromise(promise2, x, resolve, reject)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      reject(e)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">break</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<h2 id="Promises-A-test"><a href="#Promises-A-test" class="headerlink" title="Promises/A+ test"></a>Promises/A+ test</h2><p>Promises/A+ 规范提供了一个测试规范： <a href="https://github.com/promises-aplus/promises-tests#promisesa-compliance-test-suite" target="_blank" rel="external">promises-aplus/promises-tests</a><br>测试需要提供一个 adapter 方法 <code>Promise.deferred</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'./promise.js'</span></div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = &#123;&#125;</div><div class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    dfd.resolve = resolve</div><div class="line">    dfd.reject = reject</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> dfd</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="built_in">Promise</span></div></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight mercury"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promises-aplus-tests dist/<span class="keyword">promise</span>-adapter.js</div></pre></td></tr></table></figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>简易版(没有实现 Promises/A+ 标准 2.3.The Promise Resolution Procedure)<br><a href="https://gist.github.com/YingshanDeng/21ef2abab6cede0ae2bcd00986f762fd" target="_blank" rel="external">YingshanDeng / simple-promise.js</a></li>
<li>完整版(完全通过 Promises/A+ 测试规范)<br><a href="https://github.com/YingshanDeng/Promise" target="_blank" rel="external">YingshanDeng/Promise</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="external">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/Promises:A+.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Promise" scheme="http://objcer.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Javascript DOM 事件模型</title>
    <link href="http://objcer.com/2017/08/14/Introduction-into-Events/"/>
    <id>http://objcer.com/2017/08/14/Introduction-into-Events/</id>
    <published>2017-08-14T11:39:01.000Z</published>
    <updated>2017-08-14T11:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/js-event.jpg" alt=""><br><a id="more"></a></p>
<h2 id="Bubbling-and-capturing"><a href="#Bubbling-and-capturing" class="headerlink" title="Bubbling and capturing"></a>Bubbling and capturing</h2><p>Javascript DOM 事件流存在如下三个阶段：</p>
<ul>
<li>事件捕获阶段 Capturing phase – <strong>the event goes down to the element.</strong></li>
<li>处于目标阶段 Target phase – the event reached the target element.</li>
<li>事件冒泡阶段 Bubbling phase – <strong>the event bubbles up from the element.</strong></li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/eventflow@2x.png" alt=""></p>
<p><strong>Javascript DOM 标准事件流的触发的先后顺序为：先捕获再冒泡。</strong>点击 <code>&lt;td&gt;</code> DOM 节点时，事件传播顺序：首先是事件捕获阶段，从上向下传播；然后到达点击事件目标节点；最后是冒泡阶段，从下向上传播。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addEventListener(<span class="string">type:</span> DOMString, <span class="string">callback:</span> EventListener, capture?: <span class="keyword">boolean</span>)</div></pre></td></tr></table></figure>
<p>DOM 节点添加事件监听方法 <code>addEventListener</code> 中第三个参数可以指定是该监听是添加在事件捕获阶段或者是事件冒泡阶段，默认为 <code>false</code>，即事件冒泡阶段；显式指定为 <code>true</code>，即事件捕获阶段。</p>
<p>实际应用中，为 DOM 元素添加事件监听绝大多数都是添加到事件冒泡阶段，很少会用到事件捕获。我们通过 <code>on&lt;event&gt;-property</code> HTML 属性添加的事件监听默认也是添加到事件冒泡阶段</p>
<p>注意到事件流处理有三个阶段，其中第二个阶段：处于目标阶段，并不单独处理，事件捕获阶段和冒泡阶段的添加的监听处理就包含了这个阶段。</p>
<h3 id="并非所有的事件都支持冒泡"><a href="#并非所有的事件都支持冒泡" class="headerlink" title="并非所有的事件都支持冒泡"></a>并非所有的事件都支持冒泡</h3><blockquote>
<p>❗ <strong>Almost</strong> all events bubble.</p>
</blockquote>
<p>注意关键字 “almost”，所以并不是所有的事件都支持冒泡。在 wiki <a href="https://en.wikipedia.org/wiki/DOM_events#Events" target="_blank" rel="external">DOM_events</a> 中我们就可以找到一些不支持冒泡的事件，例如 <code>focus</code>、<code>blur</code> 等等<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.bubbles) <span class="regexp">//</span> &gt; <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">a.addEventListener(<span class="string">'focus'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.bubbles) <span class="regexp">//</span> &gt; <span class="literal">false</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们可以通过 <code>event.bubbles</code> 来判断是否支持事件冒泡</p>
<h3 id="三个常用方法"><a href="#三个常用方法" class="headerlink" title="三个常用方法"></a>三个常用方法</h3><ul>
<li><p><code>event.stopPropagation</code> 阻止捕获和冒泡阶段中当前事件的进一步传播<br>在事件监听回调中调用此方法，若是捕获阶段，则停止向下传递事件；若是冒泡阶段，则停止向上传递事件。</p>
</li>
<li><p><code>event.stopImmediatePropagation</code> 阻止调用相同事件的其他侦听器<br>如果某个元素有多个相同类型事件的事件监听函数, 则当该类型的事件触发时, 多个事件监听函数将按照顺序依次执行. 如果某个监听函数执行了 <code>event.stopImmediatePropagation()</code> 方法, 则除了该事件的冒泡行为被阻止之外(event.stopPropagation方法的作用), 该元素绑定的后序相同类型事件的监听函数的执行也将被阻止。例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></div><div class="line">    &#123;</div><div class="line">        alert(<span class="string">"我是p元素上被绑定的第一个监听函数"</span>);</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></div><div class="line">    &#123;</div><div class="line">        alert(<span class="string">"我是p元素上被绑定的第二个监听函数"</span>);</div><div class="line">        event.stopImmediatePropagation();</div><div class="line">        <span class="comment">//执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span></div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></div><div class="line">    &#123;</div><div class="line">        alert(<span class="string">"我是p元素上被绑定的第三个监听函数"</span>);</div><div class="line">        <span class="comment">//该监听函数排在上个函数后面,该函数不会被执行.</span></div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></div><div class="line">    &#123;</div><div class="line">        alert(<span class="string">"我是div元素,我是p元素的上层元素"</span>);</div><div class="line">        <span class="comment">//p元素的click事件没有向上冒泡,该函数不会被执行.</span></div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>event.preventDefault</code> 如果事件可取消，则取消该事件，而不停止事件的进一步传播。</p>
<ul>
<li>在事件触发后的任何阶段调用 <code>preventDefault</code> 方法来取消该事件, <strong>意味着该事件的所有默认动作都不会发生.</strong> 例如可以利用 <code>preventDefault()</code> 方法来阻止一个 <code>input</code> 元素内非法字符的输入等等</li>
<li>调用事件的 <code>preventDefault()</code> 方法后,会引起该事件的 <code>event.defaultPrevented</code> 属性值变为 <code>true</code></li>
<li>可以查看 <code>event.cancelable</code> 属性来判断一个事件的默认动作是否可以被取消. 在 <code>cancelable</code> 属性为 <code>false</code> 的事件上调用 <code>preventDefault</code> 方法没有任何效果</li>
<li><code>preventDefault</code> 方法<strong>不会阻止该事件的进一步冒泡</strong>. <code>event.stopPropagation</code> 方法才有这样的功能</li>
</ul>
</li>
</ul>
<h3 id="event-target-和-event-currentTarget"><a href="#event-target-和-event-currentTarget" class="headerlink" title="event.target 和 event.currentTarget"></a><code>event.target</code> 和 <code>event.currentTarget</code></h3><blockquote>
<p>The most deeply nested element that caused the event is called a target element, accessible as event.target.<br>Note the differences from this (=event.currentTarget):</p>
<ul>
<li>event.target – is the “target” element that initiated the event, it doesn’t change through the bubbling process.</li>
<li>this – is the “current” element, the one that has a currently running handler on it.</li>
</ul>
</blockquote>
<ul>
<li><code>event.target</code> – 指向触发事件的元素，在事件冒泡过程中该值不变</li>
<li><code>event.currentTarget</code> = this – 事件绑定的当前元素</li>
</ul>
<p>只有被点击的那个目标元素的 <code>event.target</code> 才会等于 <code>event.currentTarget</code>，看如下例子<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">  outer</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> outerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</div><div class="line">  <span class="keyword">var</span> innerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</div><div class="line"></div><div class="line">  innerEl.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'inner'</span>, event.target, event.currentTarget)</div><div class="line">  &#125;);</div><div class="line">  outerEl.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'outer'</span>, event.target, event.currentTarget)</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>点击 inner 节点，执行结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inner &lt;<span class="keyword">div</span> <span class="built_in">class</span>=​<span class="string">"inner"</span>&gt;​inner​&lt;/<span class="keyword">div</span>&gt;​ &lt;<span class="keyword">div</span> <span class="built_in">class</span>=​<span class="string">"inner"</span>&gt;​inner​&lt;/<span class="keyword">div</span>&gt;​</div><div class="line">outer &lt;<span class="keyword">div</span> <span class="built_in">class</span>=​<span class="string">"inner"</span>&gt;​inner​&lt;/<span class="keyword">div</span>&gt;​ &lt;<span class="keyword">div</span> <span class="built_in">class</span>=​<span class="string">"outer"</span>&gt;​…​&lt;/<span class="keyword">div</span>&gt;​</div></pre></td></tr></table></figure></p>
<h2 id="执行顺序的问题"><a href="#执行顺序的问题" class="headerlink" title="执行顺序的问题"></a>执行顺序的问题</h2><p>我们知道，Javascript DOM 标准事件流的触发的先后顺序为：先捕获再冒泡。如果 DOM 节点同时绑定两个事件监听，一个用于捕获阶段，一个用于冒泡阶段，两个事件的执行顺序真的如此么？<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</div><div class="line">  element1</div><div class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;element2&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-----------------------------------</div><div class="line">|<span class="string"> element1                        </span>|</div><div class="line">|<span class="string">   -------------------------     </span>|</div><div class="line">|<span class="string">   </span>|<span class="string">element2               </span>|<span class="string">     </span>|</div><div class="line">|<span class="string">   -------------------------     </span>|</div><div class="line">|<span class="string">                                 </span>|</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure>
<p>分别为内外两个元素添加两个点击事件，一个用于捕获阶段，一个用于冒泡阶段<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  var outerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</div><div class="line">  var innerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</div><div class="line"></div><div class="line">  innerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child bubble'</span>)</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line">  innerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child capture'</span>)</div><div class="line">  &#125;, <span class="literal">true</span>);</div><div class="line"></div><div class="line">  outerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent bubble'</span>)</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line">  outerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent capture'</span>)</div><div class="line">  &#125;, <span class="literal">true</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>根据前面的知识，当点击 element2 元素和 element1 元素的时候，我们应该会得到：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#点击 element2 元素</span></div><div class="line"><span class="keyword">parent</span> capture</div><div class="line">child capture</div><div class="line">child bubble</div><div class="line"><span class="keyword">parent</span> bubble</div><div class="line"></div><div class="line"><span class="comment">#点击 element1 元素</span></div><div class="line"><span class="keyword">parent</span> capture</div><div class="line"><span class="keyword">parent</span> bubble</div></pre></td></tr></table></figure></p>
<p><strong>❗️但是，</strong>实际上我们点击 element2 和点击 element1 的时候，得到的结果却是（其中都出现了先 bubble 后 capture）：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 点击 element2</span></div><div class="line"><span class="keyword">parent</span> capture</div><div class="line">child bubble</div><div class="line">child capture</div><div class="line"><span class="keyword">parent</span> bubble</div><div class="line"></div><div class="line"><span class="comment"># 点击 element1</span></div><div class="line"><span class="keyword">parent</span> bubble</div><div class="line"><span class="keyword">parent</span> capture</div></pre></td></tr></table></figure></p>
<p>这是为什么呢？这跟前面的结论不符啊 🤔 通过观察我们可以发现：<br>① DOM 元素先添加了用于冒泡阶段的事件监听，后添加了用于捕获阶段的事件监听<br>② 被点击元素先执行了冒泡阶段的事件监听，后执行捕获阶段的事件监听；而点击事件的父节点事件监听执行顺序正常<br>③ 我们猜测是否跟事件监听添加顺序有关系，我们调换一下添加顺序：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  var outerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</div><div class="line">  var innerEl = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</div><div class="line"></div><div class="line">  innerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child bubble'</span>)</div><div class="line">  &#125;, <span class="literal">true</span>);</div><div class="line">  innerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child capture'</span>)</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">  outerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent bubble'</span>)</div><div class="line">  &#125;, <span class="literal">true</span>);</div><div class="line">  outerEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">(event)</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent capture'</span>)</div><div class="line">  &#125;, <span class="literal">false</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>发现执行得到的结果正常</p>
<p><strong>❗️给出结论：</strong></p>
<ul>
<li>绑定在被点击元素的事件是按照代码添加顺序执行，其他元素先捕获后冒泡</li>
<li><strong>所以事件的执行顺序是：父元素的捕获阶段事件 -&gt; 触发事件元素按代码添加顺序的事件 -&gt; 父元素的冒泡阶段事件</strong></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://javascript.info/bubbling-and-capturing" target="_blank" rel="external">Bubbling and capturing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/js-event.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="事件捕获" scheme="http://objcer.com/tags/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/"/>
    
      <category term="事件冒泡" scheme="http://objcer.com/tags/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    
  </entry>
  
  <entry>
    <title>探究 emoji 字符长度</title>
    <link href="http://objcer.com/2017/07/20/explore-emoji-length/"/>
    <id>http://objcer.com/2017/07/20/explore-emoji-length/</id>
    <published>2017-07-20T11:41:38.000Z</published>
    <updated>2017-07-20T11:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/C0E1DEF1-900B-4372-B8CB-B166A1ABBA57.png" alt=""><br>我们注意到在 Twitter，微博，谷歌翻译的输入框中输入 emoji 字符，都不能正确的判断字符个数。🤷‍<br>在阅读本文之前，需要先对 Unicode 编码有所了解，参考: <a href="http://objcer.com/2017/05/21/JavaScript-Unicode/">JavaScript Unicode 编码那些事</a></p>
<a id="more"></a>
<h2 id="String-length-Char-count"><a href="#String-length-Char-count" class="headerlink" title="String length != Char count"></a>String length != Char count</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'😂'</span><span class="selector-class">.length</span> <span class="comment">// 2</span></div><div class="line"><span class="string">'1️⃣'</span><span class="selector-class">.length</span> <span class="comment">// 3</span></div><div class="line"><span class="string">'👨‍👨‍👦'</span><span class="selector-class">.length</span> <span class="comment">// 8</span></div><div class="line"><span class="string">'👨‍👩‍👧‍👦'</span><span class="selector-class">.length</span> <span class="comment">// 11</span></div></pre></td></tr></table></figure>
<h2 id="关于-Unicode"><a href="#关于-Unicode" class="headerlink" title="关于 Unicode"></a>关于 Unicode</h2><p>Unicode 编码范围是从 U+0000 到 U+10FFFF，每一个编码（也称之为码位 code point）表示一个 Unicode 字符；而这么多码位有划分成 17 个平面：</p>
<ul>
<li>第一个平面(U+0000 ~ U+FFFF): 基本平面(Basic Multilingual Plane - <em>BMP</em>)</li>
<li>其他 16 个平面(U+100000 ~ U+10FFFF): 补充平面(Supplementary Planes)</li>
</ul>
<p>其中 emoji 作为一种特殊编码在补充平面，例如：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">'😀'<span class="string">.codePointAt</span><span class="params">(0)</span><span class="string">.toString</span><span class="params">(16)</span> <span class="string">//</span> 0x1f600</div><div class="line">'😂'<span class="string">.codePointAt</span><span class="params">(0)</span><span class="string">.toString</span><span class="params">(16)</span> <span class="string">//</span> 0x1f602</div></pre></td></tr></table></figure></p>
<h2 id="关于-emoji"><a href="#关于-emoji" class="headerlink" title="关于 emoji"></a>关于 emoji</h2><blockquote>
<p>An Emoji as we know it today <strong>is defined by at least one code point</strong> in the Unicode range. This means that there are also several Emoji out there being a combination of several different Emoji and code points. These combinations are called <strong>sequences</strong>.</p>
</blockquote>
<p>一个 emoji 字符至少由一个码位表示，一个 emoji 有多个码位表示的我们称之为序列(sequences)。可以在 <a href="http://unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="external">Full Emoji List</a> 页面查看到所有 emoji 的编码信息<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/5E88BF15-66B7-4A32-9125-B3E019C52E9C.png" alt=""></p>
<p>在 JavaScript 中 <code>String.length</code> 计算字符长度时，认为两个字节为一个字符，所以一个基本平面上的字符长度都为 1；而一个补充平面上的字符使用代理对，由四个字符表示，所以长度为 2；<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a: 0x61</span></div><div class="line"><span class="string">'a'</span><span class="selector-class">.lenght</span> <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">//💩: U+d83d U+dca9</span></div><div class="line"><span class="string">'💩'</span><span class="selector-class">.length</span> <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// '1️⃣': U+0031 U+FE0F U+20E3</span></div><div class="line"><span class="string">'1️⃣'</span><span class="selector-class">.length</span> <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="Modifier-sequences"><a href="#Modifier-sequences" class="headerlink" title="Modifier sequences"></a>Modifier sequences</h3><p><img src="http://7vikhl.com1.z0.glb.clouddn.com/480D3F20-0262-40E4-B7C6-E068A9958692.png" alt=""><br>我们注意部分人类相关的 <strong>Human emoji</strong> 可以选择其他 5 种不同的肤色(<strong>Skin color</strong>)，默认颜色的 emoji 称之为 <strong>neutral emoji</strong>，不同肤色称之为 <strong>modifier</strong>，这些不同肤色的 emoji 我们称之为 <strong>Modifier sequences</strong>。</p>
<blockquote>
<p>These modifiers are called EMOJI MODIFIER FITZPATRICK TYPE-1-2, -3, -4, -5, and -6 (U+1F3FB–U+1F3FF): 🏻 🏼 🏽 🏾 🏿</p>
</blockquote>
<table>
<thead>
<tr>
<th>Code point</th>
<th>default</th>
<th>FITZ-1-2(U+1F3FB)</th>
<th>FITZ-3(U+1F3FC)</th>
<th>FITZ-4(U+1F3FD)</th>
<th>FITZ-5(U+1F3FE)</th>
<th>FITZ-6(U+1F3FF)</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+1F466: BOY</td>
<td>👦</td>
<td>👦🏻</td>
<td>👦🏼</td>
<td>👦🏽</td>
<td>👦🏾</td>
<td>👦🏿</td>
</tr>
<tr>
<td>U+1F467: GIRL</td>
<td>👧</td>
<td>👧🏻</td>
<td>👧🏼</td>
<td>👧🏽</td>
<td>👧🏾</td>
<td>👧🏿</td>
</tr>
<tr>
<td>U+1F468: MAN</td>
<td>👨</td>
<td>👨🏻</td>
<td>👨🏼</td>
<td>👨🏽</td>
<td>👨🏾</td>
<td>👨🏿</td>
</tr>
<tr>
<td>U+1F469: WOMAN</td>
<td>👩</td>
<td>👩🏻</td>
<td>👩🏼</td>
<td>👩🏽</td>
<td>👩🏾</td>
<td>👩🏿</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// U+1F467 + U+1F3FD</div><div class="line">👧 + 🏽</div><div class="line"><span class="meta">&gt;</span><span class="bash"> 👧🏽</span></div></pre></td></tr></table></figure>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/E3F5C223-E3E9-4ECC-AD67-DF09D6D62DD6.png" alt=""></p>
<p>明显的，这类 emoji 的通过 <code>String.length</code> 获取长度为 <strong>4</strong></p>
<h3 id="ZWJ-sequences"><a href="#ZWJ-sequences" class="headerlink" title="ZWJ sequences"></a>ZWJ sequences</h3><p>接下来里了解一下 <strong>family emoji</strong>，譬如我们常见的：三口之家：👪，四口之家：👨‍👩‍👧‍👦，等等；其中值得注意的是：</p>
<ul>
<li>有一个 neutral family emoji (U+1F46A - ‍👪) 由一个码位表示</li>
<li>而其他 family emoji 都是 <strong>Zero-Width-Joiner sequence</strong>；它们由多个 emoji 和 zero-width-joiner (U+200D) 组合而成</li>
</ul>
<p>注：zero-width-joiner (U+200D) 这个码位就如同胶水一般将不同的 emoji 组合成一个 emoji；zero-width-joiner (U+200D) 只占一个长度<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// neutral family</div><div class="line">// U<span class="string">+1</span>F46A</div><div class="line">// length: 2</div><div class="line">&gt; 👪</div><div class="line"></div><div class="line">// ZWJ sequence: family (man, woman, boy)</div><div class="line">// U<span class="string">+1</span>F468 + U<span class="string">+200</span>D + U<span class="string">+1</span>F469 + U<span class="string">+200</span>D + U<span class="string">+1</span>F466</div><div class="line">// 👨‍ + U<span class="string">+200</span>D + 👩‍ + U<span class="string">+200</span>D + 👦</div><div class="line">// length: 8</div><div class="line">&gt; ‍👨‍👩‍👦</div><div class="line"></div><div class="line">// ZWJ sequence: family (woman, woman, girl)</div><div class="line">// U<span class="string">+1</span>F469 + U<span class="string">+200</span>D + U<span class="string">+1</span>F469 + U<span class="string">+200</span>D + U<span class="string">+1</span>F467</div><div class="line">// 👩‍ + U<span class="string">+200</span>D + 👩‍ U<span class="string">+200</span>D + 👧</div><div class="line">// length: 8</div><div class="line">&gt; ‍👩‍👩‍👧</div><div class="line"></div><div class="line">// ZWJ sequence: family (woman, woman, girl, girl)</div><div class="line">// U<span class="string">+1</span>F469 + U<span class="string">+200</span>D + U<span class="string">+1</span>F469 + U<span class="string">+200</span>D + U<span class="string">+1</span>F467 + U<span class="string">+200</span>D + U<span class="string">+1</span>F467</div><div class="line">// 👩‍ + U<span class="string">+200</span>D + 👩‍ + U<span class="string">+200</span>D + 👧‍ + U<span class="string">+200</span>D + 👧</div><div class="line">// length: 11</div><div class="line">&gt; ‍👩‍👩‍👧‍👧</div></pre></td></tr></table></figure></p>
<p>拆分，组合 family emoji：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[...<span class="string">'👨‍👩‍👦'</span>]</div><div class="line">&gt;  [<span class="string">"👨"</span>, <span class="string">"‍"</span>, <span class="string">"👩"</span>, <span class="string">"‍"</span>, <span class="string">"👦"</span>]</div><div class="line"></div><div class="line">var family =  [<span class="string">"👨"</span>, <span class="string">"‍"</span>, <span class="string">"👩"</span>, <span class="string">"‍"</span>, <span class="string">"👦"</span>]</div><div class="line">console.log(family.join(<span class="string">''</span>))</div><div class="line">&gt; <span class="string">"👨‍👩‍👦"</span></div></pre></td></tr></table></figure></p>
<h2 id="解决字符长度终极解决方案"><a href="#解决字符长度终极解决方案" class="headerlink" title="解决字符长度终极解决方案"></a>解决字符长度终极解决方案</h2><p>我们找到一段正则表达式，可以用于匹配 Unicode 字符；然后封装成 <a href="https://github.com/YingshanDeng/EmojiCharString" target="_blank" rel="external">EmojiCharString</a> 类库，详细介绍参考该仓库 README 👉</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mathiasbynens.be/notes/javascript-unicode" target="_blank" rel="external">JavaScript has a Unicode problem</a><br><a href="https://www.contentful.com/blog/2016/12/06/unicode-javascript-and-the-emoji-family/" target="_blank" rel="external">Emoji.prototype.length — a tale of characters in Unicode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/C0E1DEF1-900B-4372-B8CB-B166A1ABBA57.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们注意到在 Twitter，微博，谷歌翻译的输入框中输入 emoji 字符，都不能正确的判断字符个数。🤷‍&lt;br&gt;在阅读本文之前，需要先对 Unicode 编码有所了解，参考: &lt;a href=&quot;http://objcer.com/2017/05/21/JavaScript-Unicode/&quot;&gt;JavaScript Unicode 编码那些事&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Unicode" scheme="http://objcer.com/categories/Unicode/"/>
    
    
      <category term="unicode-emoji" scheme="http://objcer.com/tags/unicode-emoji/"/>
    
  </entry>
  
  <entry>
    <title>Cordova 开发环境 - Android 篇</title>
    <link href="http://objcer.com/2017/07/03/cordova-android-development-environment/"/>
    <id>http://objcer.com/2017/07/03/cordova-android-development-environment/</id>
    <published>2017-07-03T14:14:19.000Z</published>
    <updated>2017-07-20T11:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/android-banner.jpg" alt=""><br><a id="more"></a></p>
<h2 id="安装-IDE-Android-Studio"><a href="#安装-IDE-Android-Studio" class="headerlink" title="安装 IDE (Android Studio)"></a>安装 IDE (Android Studio)</h2><p>安装 Android Studio, SDK, Android Virtual Device (AVD，安卓模拟器)</p>
<ul>
<li>下载链接：<a href="https://developer.android.com/studio/index.html?hl=zh-cn" target="_blank" rel="external">Android Studio</a></li>
<li>下载安装全程需要<strong>翻墙</strong></li>
<li>安装 Android Studio 完成后，创建一个 HelloWorld 程序到模拟器中运行，这个过程中，按照提示进行下载安装即可</li>
</ul>
<h2 id="真机运行"><a href="#真机运行" class="headerlink" title="真机运行"></a>真机运行</h2><p>手机通过 USB 连接电脑后，运行时，选择对应的设备即可运行，以下罗列几点真机运行中遇到的问题和技巧</p>
<h3 id="解决：DELETE-FAILED-INTERNAL-ERROR-Error-while-Installing-APK"><a href="#解决：DELETE-FAILED-INTERNAL-ERROR-Error-while-Installing-APK" class="headerlink" title="解决：DELETE_FAILED_INTERNAL_ERROR Error while Installing APK"></a>解决：<em>DELETE_FAILED_INTERNAL_ERROR Error while Installing APK</em></h3><p>安卓真机（小米4C）通过 USB 连接电脑后，运行，可能会出现如下问题：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/3B19ED97-CE3F-45A9-8518-C08D779F7FA3.png" alt=""><br>点击 OK 继续，会出现如下错误：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DELETE_FAILED_INTERNAL_ERROR</div><div class="line"><span class="keyword">Error </span>while Installing APKs</div></pre></td></tr></table></figure></p>
<p>参考链接：<a href="https://stackoverflow.com/questions/38892270/delete-failed-internal-error-error-while-installing-apk" target="_blank" rel="external">DELETE_FAILED_INTERNAL_ERROR Error while Installing APK</a> 大致有两种解决方案：</p>
<ul>
<li>操作步骤：Android Studio &gt; Preferences &gt;  Build, Execution, Deployment &gt; Instant Run &gt; <strong>Uncheck : Enable Instant Run</strong>（此处理方式会禁用 Instant Run 功能）<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/03E0830C-F5BB-4EC5-AC41-50A604A3E532.png" alt=""></li>
<li>由于调试设备是小米，所以还可以：设置 &gt; 更多设置 &gt; 开发者选项 &gt; <strong>去掉：启动 MIUI 优化</strong> &gt; 关闭并重启</li>
</ul>
<h3 id="ADB-无线调试"><a href="#ADB-无线调试" class="headerlink" title="ADB 无线调试"></a>ADB 无线调试</h3><p>Android ADB 提供了无线调试的功能</p>
<blockquote>
<p><a href="https://developer.android.com/studio/command-line/adb.html?hl=zh-cn#Enabling" target="_blank" rel="external">Android 调试桥</a></p>
</blockquote>
<h4 id="解决：zsh-command-not-found-adb"><a href="#解决：zsh-command-not-found-adb" class="headerlink" title="解决：zsh: command not found: adb"></a>解决：<code>zsh: command not found: adb</code></h4><p>解决步骤：<br>1️⃣ 执行如下命令往 .bash_profile 添加两个路径<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:/Users/<span class="variable">$&#123;USER&#125;</span>/Library/Android/sdk/platform-tools/"</span> &gt;&gt; ~/.bash_profile</div><div class="line"><span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:/Users/<span class="variable">$&#123;USER&#125;</span>/Library/Android/sdk/tools/"</span> &gt;&gt; ~/.bash_profile</div></pre></td></tr></table></figure></p>
<p>执行后 <code>.bash_profile</code> 文件：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/Users/YingshanDeng/Library/Android/sdk/platform-tools/</span></div><div class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/Users/YingshanDeng/Library/Android/sdk/tools/</span></div></pre></td></tr></table></figure></p>
<p>2️⃣ 执行 <code>source .bash_profile</code> 使其生效，此时我们在终端中输入 <code>adb</code> 会发现该命令生效了<br>3️⃣ 由于我的终端使用的是 zsh，所以需要再处理一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 打开 .zshrc</span></div><div class="line">open .zshrc</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 在文件末尾添加</span></div><div class="line">source ~/.bash_profile</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 保存，重启终端即可</span></div></pre></td></tr></table></figure></p>
<h4 id="AndroidWiFiADB-插件"><a href="#AndroidWiFiADB-插件" class="headerlink" title="AndroidWiFiADB 插件"></a>AndroidWiFiADB 插件</h4><p>直接使用还是不够方便，推荐使用 <strong>AndroidWiFiADB 插件</strong>，项目地址：<a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="external">AndroidWiFiADB</a></p>
<p>安装方式：</p>
<ul>
<li>Preferences -&gt; Settings -&gt; Plugins-&gt; Browse Repositories</li>
<li>输入: Android WiFi ADB 进行搜索，安装后重启</li>
</ul>
<p>如何使用：</p>
<ul>
<li>先将手机通过 USB 连接电脑，而且保证手机和电脑连接同一 WiFi，点击 AndroidWiFiADB 插件按键，会在右下角弹气泡提示是否连接成功，连接成功后即可断开 USB 连接线，享受无线提示</li>
<li>在使用过程中，要确保手机和电脑连接的同一 WiFi</li>
<li>可以通过 AndroidWiFiADB 设备面板查看设备及设置连接状态</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/36CDAE13-BEBC-42D2-9226-A53DF0CEE4B1.png" alt=""></p>
<h2 id="Chrome-远程调试模拟器-真机"><a href="#Chrome-远程调试模拟器-真机" class="headerlink" title="Chrome 远程调试模拟器/真机"></a>Chrome 远程调试模拟器/真机</h2><blockquote>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?hl=zh-cn" target="_blank" rel="external">远程调试 Android 设备使用入门</a></p>
</blockquote>
<p>操作步骤：</p>
<ul>
<li>随便在某个页面打开调试页面，如下图找到 <strong>Remote devices</strong><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/8FA1EB72-12AE-4984-AA64-2C7022B1F00E.png" alt=""></li>
<li>确保已勾选 <strong>Discover USB devices</strong><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/B378E60C-01E5-43AE-8EA1-02999501F241.png" alt=""></li>
<li>如下图找到对应的模拟器或者真机，点击 <strong>Inspect</strong> 按键就可以打开调试界面<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/917006D3-5881-4A6F-814F-0B3BB54383D7.png" alt=""></li>
</ul>
<h2 id="其他问题记录"><a href="#其他问题记录" class="headerlink" title="其他问题记录"></a>其他问题记录</h2><p>1、Android Studio 导入项目卡在 <em>Building gradle project info</em> 的解决方法：</p>
<ul>
<li><a href="http://www.jianshu.com/p/1311562bbfd4" target="_blank" rel="external">修改项目中gradle-wrapper.properties文件中的distributionUrl</a></li>
<li>从一个能打开项目根目录拷贝 <code>gradle</code> 文件夹覆盖当前项目根目录中的 <code>gradle</code> 文件夹</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/android-banner.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Cordova" scheme="http://objcer.com/categories/Cordova/"/>
    
    
  </entry>
  
</feed>
