<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deng&#39;s Blog</title>
  <subtitle>Work Smart, Enjoy Life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://objcer.com/"/>
  <updated>2018-03-05T15:44:59.000Z</updated>
  <id>http://objcer.com/</id>
  
  <author>
    <name>小邓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SharedPen 富文本实时协同编辑器</title>
    <link href="http://objcer.com/2018/03/05/SharedPen/"/>
    <id>http://objcer.com/2018/03/05/SharedPen/</id>
    <published>2018-03-05T15:37:33.000Z</published>
    <updated>2018-03-05T15:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Main.png" alt=""></p>
<p>2017 年末，公司组织了 WPS 黑客马拉松比赛已正式开赛，比赛的主题是：利用 WPS 客户端、云，及其它第三方开放服务，针对文档的查看 、创作 ，以及工作、学习中的团队分享、合作等，来构想并实现 WPS 产品创新点。冲着主题宽泛，开发时间长，且一等奖 1 万的奖金 🤑，毫不犹豫的报名了。经过一个多月的开发，SharedPen 富文本实时协同编辑器基本功能开发完成，最终在评审中也如愿获得一等奖 👏<br>SharedPen 目前仍处于开发阶段，欢迎感兴趣的朋友与我联系一起交流，项目地址：<a href="https://github.com/YingshanDeng/SharedPen" target="_blank" rel="external">GitHub: YingshanDeng/SharedPen</a>。本文将对 SharedPen 整体架构进行介绍，下列文章对其中具体的技术方案进行了详细介绍：</p>
<ul>
<li><a href="https://objcer.com/2018/03/05/SharePen-Operational-Transformation/">SharedPen 之 Operational Transformation</a></li>
<li><a href="https://objcer.com/2018/02/27/SharedPen-AnnotationList/">SharedPen 之 AnnotationList</a></li>
<li><a href="https://objcer.com/2018/03/05/SharedPen-IntervalTree-Optimization/">SharedPen 之区间树优化</a></li>
</ul>
<a id="more"></a>
<h2 id="关于协同编辑器"><a href="#关于协同编辑器" class="headerlink" title="关于协同编辑器"></a>关于协同编辑器</h2><p>协同编辑也就是多个人对一份文档进行编辑，每个协作这都有自己的输入光标，并可以可以自由地和其他协作者一起输入。对于 web-based 的协同编辑器，目前有很多成熟的产品。像我很喜欢用的: <a href="https://www.google.com/docs/about/" target="_blank" rel="external">Google Docs</a>，国内的: <a href="https://shimo.im/" target="_blank" rel="external">石墨文档</a>。</p>
<p>另一个值得介绍的是 <a href="https://teletype.atom.io/" target="_blank" rel="external">Teletype</a>，这是在旧金山举办的 2017 QCon 大会上，GitHub 发布的 Atom 实时协作插件，Teletype 可以让两名开发者轻松的协作编写代码，由于 Atom 是基于 <a href="https://electronjs.org/" target="_blank" rel="external">Electron</a> 构建的应用程序，所以我们也可以将其看作是 web-based 协同编辑器。</p>
<p><strong>协同编辑的关键是要解决数据一致性的问题</strong>，不同的协作者修改他们自己的文档副本，本地的编辑会立刻应用到本地副本，之后会传输给其他协作者，这会导致不同的副本可能会以不同的顺序应用各种修改，应该有算法来确保在协同编辑之后，所有副本最终的内容是一致的。</p>
<h2 id="数据一致性解决方案"><a href="#数据一致性解决方案" class="headerlink" title="数据一致性解决方案"></a>数据一致性解决方案</h2><p>首先介绍一下分布式系统，分布式系统即运行在多物理计算机上的系统。这个是人类目前实际可行的构建超大规模系统的唯二办法之一（另一种就是构建超级计算机）。构建一个分布式系统的难点在于：让分布式系统运作起来正确性与单机程序完全无二。而协同编辑器，我们也可以看做是一个分布式系统，多端的协作者修改文档，而最终文档内容要收敛到相同的状态<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/real-time-portals-fa6fa303e261b1679024081d6229c9f9.png" alt=""></p>
<p>目前来说，解决分布式系统数据一致性问题，主流的有两大方案：</p>
<ul>
<li><strong>Conflict-free replicated data type</strong> (CRDT)</li>
<li><strong>Operational transformation</strong> (OT)</li>
</ul>
<h3 id="Conflict-free-replicated-data-type"><a href="#Conflict-free-replicated-data-type" class="headerlink" title="Conflict-free replicated data type"></a>Conflict-free replicated data type</h3><p>Conflict-free replicated data type，简称为 CRDT，直译的话即是：无冲突可复制数据类型。</p>
<blockquote>
<p>Wikipedia 介绍: <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" target="_blank" rel="external">Conflict-free replicated data type</a><br>In distributed computing, a conflict-free replicated data type (CRDT) is a <strong>data structure</strong> which can be replicated across multiple computers in a network, where the replicas can be updated independently and concurrently without coordination between the replicas, and where it is always mathematically possible to resolve inconsistencies which might result.</p>
</blockquote>
<p>简单的理解：CRDT 就是这样一些适应于分布式系统的可以保持最终一致性的<strong>数据结构</strong>的统称。GitHub 开源的 Teletype 协同编辑插件，使用的就是 CRDT 算法。GitHub 为此开发的 CRDT 是一个独立的库，有兴趣可前往 GitHub 具体了解。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/atom/teletype-crdt" target="_blank" rel="external">atom/teletype-crdt</a> String-wise sequence CRDT powering peer-to-peer collaborative editing in Teletype for Atom.</p>
</blockquote>
<h3 id="Operational-transformation"><a href="#Operational-transformation" class="headerlink" title="Operational transformation"></a>Operational transformation</h3><p>Operational transformation，简称 OT，直译的话即是：操作转换<br>OT 它起源于 1989 年发表的一篇<a href="https://dl.acm.org/citation.cfm?doid=67544.66963" target="_blank" rel="external">研究论文</a>，进过多年的发展，现在已经是非常成熟的一致性解决算法，很多协同编辑器都采用此算法作为协同解决方案，例如我们熟知的 Google Docs。</p>
<blockquote>
<p>Wikipedia 介绍: <a href="https://en.wikipedia.org/wiki/Operational_transformation" target="_blank" rel="external">Operational transformation</a><br>Operational transformation (OT) is a technology for supporting a range of collaboration functionalities in advanced collaborative software systems. OT was originally invented for consistency maintenance and concurrency control in collaborative editing of plain text documents. Two decades of research has extended its capabilities and expanded its applications to include group undo, locking, conflict resolution, operation notification and compression, group-awareness, HTML/XML and tree-structured document editing, collaborative office productivity tools, application-sharing, and collaborative computer-aided media design tools (see OTFAQ). In 2009 OT was adopted as a core technique behind the collaboration features in Apache Wave and Google Docs.</p>
</blockquote>
<p><strong>SharedPen 也是采用 OT 作为协同编辑解决方案</strong>，使用了 <a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="external">ot.js</a> 库，OT 算法在文章 <a href="https://objcer.com/2018/03/05/SharePen-Operational-Transformation/">SharedPen 之 Operational Transformation</a> 进行了详细介绍 😋</p>
<h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><p>SharedPen 是基于 web 端的所见即所得 (WYSIWYG) 编辑器。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/sharedpen.png" alt=""></p>
<p>在 ot.js 库中，使用 <a href="https://codemirror.net/" target="_blank" rel="external">CodeMirror</a> 作为文本编辑器，CodeMirror 是一款优秀的编辑器，多用于代码编辑器，譬如在 Chrome 浏览器的调试器中，就使用 CodeMirror 作为代码编辑器。ot.js 库基于 CodeMirror 实现了一个简单的纯文本编辑器，demo 可以参考：<a href="https://github.com/YingshanDeng/ot.js-demo" target="_blank" rel="external">GitHub: ot.js-demo</a></p>
<p>CodeMirror 编辑器具有丰富友好的 API 接口：</p>
<ul>
<li><strong>坐标系统</strong><br>CodeMirror 中以行为单位，通过 <code>{line, ch}</code> 第几行的第几个字符可以准确为每一个字符定位 <code>pos</code>，同时每一个字符都有一个全局索引 <code>index</code>，通过 <code>doc.posFromIndex</code> 和 <code>doc.indexFromPos</code> 两个辅助方法可以对二者进行转换</li>
<li><strong>丰富的事件回调: <code>change</code>, <code>beforeChange</code>, <code>cursorActivity</code>…</strong><br>其中编辑事件 <code>change</code> 的回调参数信息非常丰富，便于我们将其转换成 OT 算法中的 operation<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/codemirror-change-insert.png" alt=""><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/codemirror-change-delete.png" alt=""></li>
<li><strong><code>markText</code> 富文本支持 API</strong><br>注意到 CodeMirror 其实并不支持富文本编辑，但是得益于 API <code>markText</code> 可以动态为指定范围的文本设置一个 CSS class，也可以通过自身实现为其增加富文本编辑功能，这部分内容在文章：👉 <a href="https://objcer.com/2018/02/27/SharedPen-AnnotationList/">SharedPen 之 AnnotationList</a> 中进行了详细介绍 😋</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><table>
<thead>
<tr>
<th></th>
<th>架构</th>
<th>Server 作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Google Docs，石墨文档</td>
<td>C/S 模式</td>
<td>负责转发多端操作和数据持久化存储</td>
</tr>
<tr>
<td>Teletype(Atom协同编辑插件)</td>
<td>Peer-to-Peer 模式</td>
<td>辅助建立连接(握手)</td>
</tr>
</tbody>
</table>
<h3 id="Peer-to-Peer-模式"><a href="#Peer-to-Peer-模式" class="headerlink" title="Peer-to-Peer 模式"></a>Peer-to-Peer 模式</h3><p>Atom 协同编辑插件 Teletype，采用 Peer-to-Peer 模式，通过 WebRTC 加密多端之间的通信。除了最初的握手依赖于 GitHub 的服务器之外，所有的传输都是点对点的（不需要访问 GitHub 服务器）。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/sharedpen-peer-to-peer.png?t=1" alt=""></p>
<h3 id="C-S-模式"><a href="#C-S-模式" class="headerlink" title="C/S 模式"></a>C/S 模式</h3><p>像 Google Docs，石墨文档都是采用 C/S 模式作为前后端架构，SharedPen 也是采用这种架构模式，前后端建立 socket 连接，相互实时发送 operation 操作，服务端中还对数据进行持久化存储。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/sharedpen-client-server.png" alt=""></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://liyu1981.github.io/what-is-CRDT/" target="_blank" rel="external">谈谈CRDT</a><br><a href="http://www.jdon.com/artichect/crdt.html" target="_blank" rel="external">分布式CRDT模型</a><br><a href="https://drive.googleblog.com/2010/05/whats-different-about-new-google-docs.html" target="_blank" rel="external">What’s different about the new Google Docs?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Main.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2017 年末，公司组织了 WPS 黑客马拉松比赛已正式开赛，比赛的主题是：利用 WPS 客户端、云，及其它第三方开放服务，针对文档的查看 、创作 ，以及工作、学习中的团队分享、合作等，来构想并实现 WPS 产品创新点。冲着主题宽泛，开发时间长，且一等奖 1 万的奖金 🤑，毫不犹豫的报名了。经过一个多月的开发，SharedPen 富文本实时协同编辑器基本功能开发完成，最终在评审中也如愿获得一等奖 👏&lt;br&gt;SharedPen 目前仍处于开发阶段，欢迎感兴趣的朋友与我联系一起交流，项目地址：&lt;a href=&quot;https://github.com/YingshanDeng/SharedPen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub: YingshanDeng/SharedPen&lt;/a&gt;。本文将对 SharedPen 整体架构进行介绍，下列文章对其中具体的技术方案进行了详细介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://objcer.com/2018/03/05/SharePen-Operational-Transformation/&quot;&gt;SharedPen 之 Operational Transformation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://objcer.com/2018/02/27/SharedPen-AnnotationList/&quot;&gt;SharedPen 之 AnnotationList&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://objcer.com/2018/03/05/SharedPen-IntervalTree-Optimization/&quot;&gt;SharedPen 之区间树优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SharedPen" scheme="http://objcer.com/categories/SharedPen/"/>
    
    
      <category term="富文本" scheme="http://objcer.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
      <category term="实时协同编辑器" scheme="http://objcer.com/tags/%E5%AE%9E%E6%97%B6%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SharedPen 之区间树优化</title>
    <link href="http://objcer.com/2018/03/05/SharedPen-IntervalTree-Optimization/"/>
    <id>http://objcer.com/2018/03/05/SharedPen-IntervalTree-Optimization/</id>
    <published>2018-03-05T15:27:03.000Z</published>
    <updated>2018-03-05T15:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-IntervalTree.png" alt=""></p>
<p>前文 <a href="">SharedPen 之 AnnotationList</a> 讲到：</p>
<blockquote>
<p>为了管理，操作整个富文本文档流，我们引入 <strong>AnnotationList</strong> 单链表结构，把每一段富文本当成 <code>Node</code> 节点，由此形成链表结构。</p>
</blockquote>
<p>单链表数据结构形象容易理解，但是执行操作（增删改查）的效率比较低，所有操作的算法复杂度都是 <code>O(N)</code>（其中N为节点数）；优化的方向是将链表数据结构改造成树形结构。本文将对优化思路进行分析。</p>
<a id="more"></a>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>二叉查找树</strong>（Binary Search Tree，简称BST）是一棵二叉树，特点是：它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删查改的时间复杂度为 <code>O(logN)</code>，最坏的情况下为 <code>O(N)</code>。当它的高度为 <code>logN+1</code> 时，我们就说二叉查找树是平衡的。</p>
<p>由于 BST 存在的问题，产生了一种新的树 – <strong>自平衡二叉查找树</strong>，自平衡树在插入和删除节点的时候，会通过旋转操作将高度保持在 <code>logN</code>，所以它可以在 <code>O(log N)</code> 时间内做查找，插入和删除。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/tree-all.png" alt=""></p>
<p><strong><a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">红黑树</a></strong>（Red–black tree）就是一种<strong>自平衡二叉查找树</strong>，它是复杂的，<br>但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的，其实际应用也非常广泛。</p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。除二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>下面是一个具体的红黑树的图例：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/900px-Red-black_tree_example.svg.png" alt=""></p>
<blockquote>
<p>推荐一个数据结构可视化在线工具，可以辅助理解：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="external">Data Structure Visualizations</a><br>其中红黑树增删节点可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="external">Red/Black Tree</a></p>
</blockquote>
<h2 id="区间树"><a href="#区间树" class="headerlink" title="区间树"></a>区间树</h2><p>区间树（interval tree）是一种扩展的红黑树，区间树中的节点都代表一个区间。例如区间：(2, 8) (6, 15) (30, 36) (20, 25) (33, 40) 构成如下区间树：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/interval-tree-demo.png" alt=""></p>
<p>对于一个区间：</p>
<ul>
<li>区间用 <code>Range(lowerPosition, upperPosition)</code> 来表示，其中：<code>lowerPosition</code> 和 <code>upperPosition</code> 分别表示起始位置和结束位置</li>
<li>在起始和结束位置上，都有两种情况：包含或者不包含，也就是区间的开闭，一共有四种情况：<code>[a, b)</code>，<code>[a, b]</code>，<code>(a, b)</code>，<code>(a, b]</code></li>
</ul>
<p>在处理 SharedPen 文本区间时：</p>
<ul>
<li>注意到我们的区间是连续的（这是区间树的一种特殊情况），所以可以定义我们的区间为：<strong>左闭右开</strong>，即 <code>[a, b)</code></li>
<li>区间树也符合二叉查找树的特点，区间进行大小比较时，定义如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeKeyword</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(lowerPosition, upperPosition) &#123;</div><div class="line">    <span class="keyword">this</span>._lowerPosition = lowerPosition;</div><div class="line">    <span class="keyword">this</span>._upperPosition = upperPosition;</div><div class="line">  &#125;</div><div class="line">  gt(hint) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._lowerPosition == hint._lowerPosition) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._upperPosition &gt; hint._upperPosition</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._lowerPosition &gt; hint._lowerPosition</div><div class="line">  &#125;</div><div class="line">  lt(hint) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._lowerPosition == hint._lowerPosition) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._upperPosition &lt; hint._upperPosition</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._lowerPosition &lt; hint._lowerPosition</div><div class="line">  &#125;</div><div class="line">  eq(hint) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._lowerPosition == hint._lowerPosition</div><div class="line">      &amp;&amp; <span class="keyword">this</span>._upperPosition == hint._upperPosition</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>接下来将以这种连续（左闭右开）区间进行分析</strong></p>
<p>区间树有两个重要操作：<code>expand</code> 和 <code>remove</code></p>
<ul>
<li><strong>扩张：<code>expand(pos, length)</code></strong><br>在 <code>pos</code> 位置，插入 <code>length</code> 长度的字符，插入文本后，后续的区间位置需要<strong>自动更新</strong><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/interval-tree-expand.png?t=1" alt=""><br>例子中区间：<code>[2, 8),[8, 15),[15, 20),[20, 28)</code> 变成 <code>[2, 8),[8, 17),[17, 22),[22, 30)</code></li>
<li><strong>收缩：<code>remove(pos, length)</code></strong>：<br>在 <code>pos</code> 位置，删除 <code>length</code> 长度的字符，删除文本后，后续的区间位置需要<strong>自动更新</strong><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/interval-tree-remove.png" alt=""><br>例子中区间：<code>[2, 8),[8, 15),[15, 20),[20, 28)</code> 变成 <code>[2, 8),[8, 13),[13, 18),[18, 26)</code></li>
</ul>
<p>注意到插入和删除文本后，其后续区间的位置都能<strong>自动更新</strong>，为了实现这个功能，我们需要对区间进行一些处理。区间<code>Range(lowerPosition, upperPosition)</code> 的 <code>lowerPosition</code> 和 <code>upperPosition</code> 都表示<strong>绝对位置</strong>，下面给区间引入<strong>相对位置</strong>的概念。</p>
<ul>
<li>每一个区间都是相对于某一个区间而言的，这个相对的区间称之为 <code>originNode</code>，注意：<ul>
<li>左节点的 <code>originNode</code> = 其父节点的 <code>originNode</code></li>
<li>右节点的 <code>originNode</code> = 其父节点</li>
</ul>
</li>
<li>区间新增的几个属性：<ul>
<li><code>origin</code>: 表示区间相对位置的相对起点</li>
<li><code>relativeLower</code>: 表示区间相对位置的起始位置</li>
<li><code>upperDistance</code>: 表示区间的长度</li>
</ul>
</li>
</ul>
<p>下面通过：<code>[2, 8),[8, 15),[15, 20),[20, 28),[28, 40)</code> 这个区间树来解释一下相对位置的概念</p>
<p>下图中的红色箭头指向为 <code>originNode</code>，注意到其中的 <code>[2, 8)</code> 和 <code>[8, 15)</code> 区间其实是指向这个区间树，表示其相对区间为区间树的起点。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/interval-tree-originNode.png" alt=""></p>
<p>下图中分别列出了每个区间的 <code>origin</code>，<code>relativeLower</code>，<code>upperDistance</code> 的属性<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/interval-tree-origin2.png" alt=""></p>
<p>其中区间 <code>origin</code> 属性通过如下计算得到：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">get</span> <span class="title">origin</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = <span class="literal">null</span>,</div><div class="line">      o = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (n = <span class="keyword">this</span>.originNode; <span class="literal">null</span> != n; n = n.originNode) &#123;</div><div class="line">    o += n.relativeLower;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>区间的绝对位置可以通过如下计算得到：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">get</span> lowerPosition() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.origin + <span class="keyword">this</span>.relativeLower;</div><div class="line">&#125;</div><div class="line"><span class="keyword">get</span> upperPosition() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.lowerPosition + <span class="keyword">this</span>.upperDistance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了相对位置概念之后，<strong>处理扩张/收缩，只需遍历区间树中的部分节点，更新其中相关的属性即可。</strong>如下区间树，<code>expand(10, 2)</code>，在 10 的位置扩展 2 个长度，即区间 <code>[8, 15)</code> 变成 <code>[8, 17)</code>，除了更新当前区间 <code>[8, 15)</code> 外，只需要更新那些以该区间节点为 <code>originNode</code> 的区间，我们可以知道区间 <code>[15, 20)</code> 和 <code>[20, 28)</code> 的 <code>originNode</code> 就是 <code>[8, 15)</code><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/A02DFDB4-8A1E-4D18-997D-E1A1BC5ACC2A.png" alt=""></p>
<p>下面简单的介绍一下实现原理：<br>① <code>passWhole</code> 和 <code>passRight</code><br>执行遍历过程中，需要对比执行操作点（插入点/删除点）和区间节点的关系，其中包含两个重要的比较过程：<code>passWhole</code> 和 <code>passRight</code></p>
<ul>
<li><p><code>passWhole</code><br>区间节点有一个 <code>limitPosition</code> 属性，表示当前区间节点所在子树的右边界位置<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/C2898E5B-198A-4D3D-AA97-3207F4187376.png" alt=""><br><code>passWhole</code> 判断执行操作点的位置如果比当前区间节点所在子树的右边界大，那么可以跳过这个子树</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">passWhole(<span class="keyword">hint</span>) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._position &gt; <span class="keyword">hint</span>.limitPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>passRight</code><br><code>passRight</code> 判断执行操作点的位置如果比当前区间的（绝对位置的）起始位置小，那么可以跳过这个区间节点对应的右子树（即只需考虑当前区间的左子树）</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">passRight(<span class="keyword">hint</span>) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._position &lt; <span class="keyword">hint</span>._lowerPosition</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>② 伪代码<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function travel() &#123;</div><div class="line">  var deep = []</div><div class="line">  var <span class="keyword">hint</span> = makeHintAtTree() <span class="comment">// 生成区间树迭代器</span></div><div class="line">  var isHintStop = <span class="keyword">false</span></div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (isHintStop) &#123; <span class="comment">//</span></div><div class="line">      isHintStop = <span class="keyword">false</span></div><div class="line">      <span class="keyword">if</span> (<span class="number">0</span> == deep.length) &#123;</div><div class="line">        <span class="keyword">break</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 出栈</span></div><div class="line">      <span class="keyword">hint</span> = deep.pop()</div><div class="line">      <span class="comment">// 修改迭代器对应的区间节点数据</span></div><div class="line">      <span class="keyword">hint</span>._node.visit()</div><div class="line">      <span class="comment">// 迭代器向左移动</span></div><div class="line">      <span class="keyword">hint</span>.moveLeft();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 跳过当前区间所在的整颗子树</span></div><div class="line">      <span class="keyword">if</span> (visitor.passWhole(<span class="keyword">hint</span>)) &#123;</div><div class="line">        isHintStop = <span class="keyword">true</span></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 入栈</span></div><div class="line">      deep.push(<span class="keyword">hint</span>.clone());</div><div class="line">      <span class="comment">// 跳过当前区间所在的右子树</span></div><div class="line">      <span class="keyword">if</span> (visitor.passRight(<span class="keyword">hint</span>)) &#123;</div><div class="line">        isHintStop = <span class="keyword">true</span></div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 迭代器向右移动</span></div><div class="line">      <span class="keyword">hint</span>.moveRight();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AnnotationTree"><a href="#AnnotationTree" class="headerlink" title="AnnotationTree"></a>AnnotationTree</h2><p>区间树主要提供四个接口：插入/删除区间；扩张/收缩区间；下面我们通过这四个接口来构建 AnnotationTree，也即是将单链表数据结构的 AnnotationList 改造成区间树数据结构的 AnnotationTree，同样 AnnotationTree 需要提供增删改查的四个功能。</p>
<p>给区间树引入<strong>迭代器 <code>Hint(tree, node, origin)</code></strong>，这个迭代器指向区间树的某个节点，迭代器通过 <code>moveLeft</code>，<code>moveRight</code>，<code>movePrev</code>，<code>moveNext</code>，<code>moveUp</code> 方法在区间树中移动游走，迭代器移动过程中会更新保存 <code>origin</code> 信息，方便使用</p>
<h3 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h3><h4 id="查找-find-tree-pos"><a href="#查找-find-tree-pos" class="headerlink" title="查找 find(tree, pos)"></a>查找 <code>find(tree, pos)</code></h4><p><code>find(tree, pos)</code>：根据位置在区间树中查找区间，返回对应迭代器<br>区间和位置点的大小比较，定义如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionKeyword</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(position) &#123;</div><div class="line">    <span class="keyword">this</span>._position = position</div><div class="line">  &#125;</div><div class="line">  gt(hint) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._position &gt;= hint._upperPosition</div><div class="line">  &#125;</div><div class="line">  lt(hint) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._position &lt; hint._lowerPosition</div><div class="line">  &#125;</div><div class="line">  eq(hint) &#123;</div><div class="line">    <span class="keyword">return</span> (hint._lowerPosition &lt;= <span class="keyword">this</span>._position &amp;&amp;</div><div class="line">      <span class="keyword">this</span>._position &lt; hint._upperPosition)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：区间是左闭右开，所以当 <code>lowerPosition &lt;= position &lt; upperPosition</code> 时，判断为相等</p>
<h4 id="区间收缩-remove-tree-hint-pos-length"><a href="#区间收缩-remove-tree-hint-pos-length" class="headerlink" title="区间收缩 remove(tree, hint, pos, length)"></a>区间收缩 <code>remove(tree, hint, pos, length)</code></h4><p>扩张直接调用区间树的 <code>expand</code> 方法即可；但是对于收缩，调用区间树 <code>remove</code> 方法后，有可能出现长度为 0 的区间，这个时候，我们还需要将长度为 0 的区间进行移除。例如：<br>区间树：<code>[2, 8),[8, 15),[15, 20),[20, 28),[28, 40)</code><br>➡️ 调用区间树方法 <code>remove(10, 13)</code><br>区间树变成：<code>[2, 8),[8, 10),[10, 10),[10, 15),[15, 27)</code><br>➡️ 移除长度为 0 的区间<br>区间树变成：<code>[2, 8),[8, 10),[10, 15),[15, 27)</code></p>
<h4 id="分裂-split-tree-hint-distance-prop"><a href="#分裂-split-tree-hint-distance-prop" class="headerlink" title="分裂 split(tree, hint, distance, prop)"></a>分裂 <code>split(tree, hint, distance, prop)</code></h4><p>将 <code>hint</code> 指向的区间节点，在 <code>distance</code> 位置进行分裂，并将 <code>prop</code> 数据附加到左侧节点，返回左侧区间节点迭代器；例如将区间 <code>[15, 20)</code> 分裂成 <code>[15, 17)</code> 和 <code>[17, 20)</code></p>
<p>❗️注意此时不能将 <code>[15, 20)</code> 收缩变成 <code>[15, 17)</code>，然后再插入新的区间节点 <code>[17, 20)</code>；<br>因为 <code>[15, 20)</code> 收缩变成 <code>[15, 17)</code><br>过程中会调整区间节点的相对位置；而插入新的区间节点并不会调整区间节点的位置关系。例如：<br>区间树：<code>[2, 8),[8, 15),[15, 20),[20, 28),[28, 40)</code><br>➡️ 调用区间树方法 <code>remove(15, 3)</code><br>区间树变成：<code>[2, 8),[8, 15),[15, 17),[17, 25),[25, 37)</code><br>➡️ 插入新的区间节点 <code>[17, 20)</code><br>区间树变成：<code>[2, 8),[8, 15),[15, 17),[17, 20),[17, 25),[25, 37)</code></p>
<p><strong>正确的做法是：删除当前节点，插入两个新的节点</strong></p>
<h4 id="合并-merge-tree-hint"><a href="#合并-merge-tree-hint" class="headerlink" title="合并 merge(tree, hint)"></a>合并 <code>merge(tree, hint)</code></h4><p>将迭代器指向的区间合入下一个区间<br><strong>做法是：移除当前区间节点和下一区间节点，插入一个新的区间节点</strong></p>
<h3 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><p>增删改方法逻辑参考如下代码即可理解；查询方法比较简单，此处略。</p>
<h4 id="插入-insert-pos-length-prop"><a href="#插入-insert-pos-length-prop" class="headerlink" title="插入 insert(pos, length, prop)"></a>插入 <code>insert(pos, length, prop)</code></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">insert(pos, length, prop) &#123;</div><div class="line">  <span class="comment">// 查找位置对应的迭代器</span></div><div class="line">  <span class="keyword">var</span> found = <span class="keyword">this</span>.find(<span class="keyword">this</span>.tree, pos)</div><div class="line">  <span class="keyword">if</span> (!found) &#123; <span class="keyword">throw</span> new Error(<span class="string">'Not found'</span>) &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (found._lowerPosition === pos) &#123; <span class="comment">// 情况1: 在两句之间插入（注意区间左闭右开）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.equaler(found, prop)) &#123; <span class="comment">// 情况1.1: 和后一句属性相同</span></div><div class="line">      <span class="keyword">this</span>.expand(<span class="keyword">this</span>.tree, pos, length)</div><div class="line">      <span class="keyword">return</span> found</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// found 移动到前一句</span></div><div class="line">      found.movePrev()</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!found.atTree() &amp;&amp; <span class="keyword">this</span>.equaler(found, prop)) &#123; <span class="comment">// 情况1.2: 和前一句属性相同</span></div><div class="line">        <span class="keyword">this</span>.expand(pos<span class="number">-1</span>, length)</div><div class="line">        <span class="keyword">return</span> found</div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况1.3: 和前后句都不相同，那么创建新的句</span></div><div class="line">        found.moveNext()</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.expand(<span class="keyword">this</span>.tree, pos, length)</div><div class="line">        found = <span class="keyword">this</span>.split(<span class="keyword">this</span>.tree, found, length, prop)</div><div class="line">        <span class="keyword">return</span> found</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况2: 在一句的中间插入</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.equaler(found, prop)) &#123; <span class="comment">// 情况2.2: 句属性相同</span></div><div class="line">      <span class="keyword">this</span>.expand(<span class="keyword">this</span>.tree, pos, length)</div><div class="line">      <span class="keyword">return</span> found</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况2.3: 句属性不同 -&gt; 断句，插入新节点</span></div><div class="line">      let _splitDistance = pos - found._lowerPosition</div><div class="line"></div><div class="line">      found = <span class="keyword">this</span>.split(<span class="keyword">this</span>.tree, found, _splitDistance, found._node.prop)</div><div class="line">      <span class="keyword">this</span>.expand(<span class="keyword">this</span>.tree, pos, length)</div><div class="line">      found.moveNext()</div><div class="line">      found = <span class="keyword">this</span>.split(<span class="keyword">this</span>.tree, found, length, prop)</div><div class="line">      <span class="keyword">return</span> found</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除-shrink-pos-length"><a href="#删除-shrink-pos-length" class="headerlink" title="删除 shrink(pos, length)"></a>删除 <code>shrink(pos, length)</code></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">shrink(pos, length) &#123;</div><div class="line">  <span class="comment">// 查找位置对应的迭代器</span></div><div class="line">  <span class="keyword">var</span> found = <span class="keyword">this</span>.find(<span class="keyword">this</span>.tree, pos)</div><div class="line">  <span class="keyword">if</span> (!found) &#123; <span class="keyword">throw</span> new Error(<span class="string">'Not found'</span>) &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (found._lowerPosition !== pos) &#123; <span class="comment">// 删除位置不在句头，先断句</span></div><div class="line">    let _splitDistance = pos - found._lowerPosition</div><div class="line">    found = <span class="keyword">this</span>.split(<span class="keyword">this</span>.tree, found, _splitDistance, found._node.prop)</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除位置恰好在句头</span></div><div class="line">    found.movePrev()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 删除</span></div><div class="line">  <span class="keyword">this</span>.remove(<span class="keyword">this</span>.tree, found.clone(), pos, length)</div><div class="line">  <span class="keyword">if</span> (!found.atTree()) &#123;</div><div class="line">    <span class="keyword">var</span> found2 = found.clone()</div><div class="line">    found2.moveNext()</div><div class="line">    <span class="comment">// 判断是否需要和后一句合并</span></div><div class="line">    <span class="keyword">if</span> (!found2.atTree() &amp;&amp; <span class="keyword">this</span>.equaler(found, found2._node.prop)) &#123;</div><div class="line">      <span class="keyword">this</span>.merge(<span class="keyword">this</span>.tree, found)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="修改-modifyProp-pos-length-propFn"><a href="#修改-modifyProp-pos-length-propFn" class="headerlink" title="修改 modifyProp(pos, length, propFn)"></a>修改 <code>modifyProp(pos, length, propFn)</code></h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">modifyProp(pos, length, propFn) &#123; <span class="comment">// propFn：区间属性修改回调方法</span></div><div class="line">  <span class="comment">// 查找位置对应的迭代器</span></div><div class="line">  var found = this.<span class="built_in">find</span>(this.tree, pos)</div><div class="line">  <span class="keyword">if</span> (!found) &#123; <span class="keyword">throw</span> new Error(<span class="string">'Not found'</span>) &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(!found.atTree()) &#123;</div><div class="line">    let <span class="variable">_lower</span> = found.<span class="variable">_lowerPosition</span></div><div class="line">    let <span class="variable">_upper</span> = found.<span class="variable">_upperPosition</span></div><div class="line">    let <span class="variable">_newProp</span> = propFn(found.<span class="variable">_node</span>.prop) <span class="comment">// 返回新的区间属性</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!this.equaler(found, <span class="variable">_newProp</span>)) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="variable">_lower</span> &lt; pos) &#123;</div><div class="line">        found = this.split(tree, found, pos-<span class="variable">_lower</span>, found.<span class="variable">_node</span>.prop)</div><div class="line">        found.moveNext()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (pos+length &lt; <span class="variable">_upper</span>) &#123;</div><div class="line">        found = this.split(tree, found, pos+length-found.<span class="variable">_lowerPosition</span>, found.<span class="variable">_node</span>.prop)</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 修改句属性</span></div><div class="line">      found.<span class="variable">_node</span>.modifyProp(<span class="variable">_newProp</span>)</div><div class="line"></div><div class="line">      <span class="comment">// 当改变区域和上一个区域交接时，尝试向前合并</span></div><div class="line">      <span class="keyword">if</span> (pos &lt;= <span class="variable">_lower</span> &amp;&amp; pos !== <span class="number">0</span>) &#123;</div><div class="line">        let <span class="variable">_prevHint</span> = found.clone()</div><div class="line">        <span class="variable">_prevHint</span>.movePrev()</div><div class="line">        <span class="keyword">if</span> (!<span class="variable">_prevHint</span>.atTree() &amp;&amp; this.equaler(<span class="variable">_prevHint</span>, <span class="variable">_newProp</span>)) &#123;</div><div class="line">          found = this.merge(this.tree, <span class="variable">_prevHint</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">_upper</span> &gt;= (pos + length)) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="variable">_upper</span> == (pos + length)) &#123;</div><div class="line">        <span class="comment">// 改变的区域结束正好在句结束位置，这时尝试向后合并句</span></div><div class="line">        let <span class="variable">_nextHint</span> = found.clone()</div><div class="line">        <span class="variable">_nextHint</span>.moveNext()</div><div class="line">        <span class="keyword">if</span> (!<span class="variable">_nextHint</span>.atTree() &amp;&amp; this.equaler(<span class="variable">_nextHint</span>, <span class="variable">_newProp</span>)) &#123;</div><div class="line">          found = this.merge(this.tree, found)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      break</div><div class="line">    &#125;</div><div class="line">    found.moveNext()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">维基百科·红黑树</a><br><a href="https://segmentfault.com/a/1190000012728513" target="_blank" rel="external">红黑树详细分析，看了都说好</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-IntervalTree.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;前文 &lt;a href=&quot;&quot;&gt;SharedPen 之 AnnotationList&lt;/a&gt; 讲到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了管理，操作整个富文本文档流，我们引入 &lt;strong&gt;AnnotationList&lt;/strong&gt; 单链表结构，把每一段富文本当成 &lt;code&gt;Node&lt;/code&gt; 节点，由此形成链表结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单链表数据结构形象容易理解，但是执行操作（增删改查）的效率比较低，所有操作的算法复杂度都是 &lt;code&gt;O(N)&lt;/code&gt;（其中N为节点数）；优化的方向是将链表数据结构改造成树形结构。本文将对优化思路进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="SharedPen" scheme="http://objcer.com/categories/SharedPen/"/>
    
    
      <category term="区间树" scheme="http://objcer.com/tags/%E5%8C%BA%E9%97%B4%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SharedPen 之 Operational Transformation</title>
    <link href="http://objcer.com/2018/03/05/SharePen-Operational-Transformation/"/>
    <id>http://objcer.com/2018/03/05/SharePen-Operational-Transformation/</id>
    <published>2018-03-05T15:25:30.000Z</published>
    <updated>2018-03-05T15:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Operational%20Transformation.png" alt=""></p>
<p>当多用户协同编辑同一篇文档，由于没有锁的机制，便会出现内容冲突，这时就需要一定的算法来自动解决冲突，使所有对文档的修改同步后，每个协同编辑的用户看到的文档内容是完全一致的。而 Operational Transformation (简称 OT) 算法就是解决协同问题的通用算法，支持各类协同编辑引用，例如文档，表格，演示，代码编辑等。其最早发表于 1989 年，后因 Google 的在线协作产品 Google Wave，Google Docs 的应用而成熟流行。</p>
<blockquote>
<p>关于 Google Wave: <a href="http://www.ifanr.com/675122" target="_blank" rel="external">Google Wave，值得纪念的伟大失败</a></p>
</blockquote>
<p>GitHub 上开源项目 <a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="external">ot.js</a> 已经对 OT 算法进行 JavaScript 语言实现。本文将对 OT 算法进行介绍 👉</p>
<blockquote>
<p><strong>❗️注意:</strong> ot.js 库只是针对纯文本协同编辑的 OT 算法实现；SharedPen 使用了这个库，但是 SharedPen 支持富文本编辑，所以需要对 ot.js 库进行增强，使之支持富文本文档编辑的协同。</p>
</blockquote>
<a id="more"></a>
<h2 id="OT-Explained"><a href="#OT-Explained" class="headerlink" title="OT Explained"></a>OT Explained</h2><p>为了方便解释，以下内容基于 ot.js 这个库应用于<strong>纯文本</strong>协同编辑对 OT 算法进行介绍。</p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><ul>
<li><strong>Operation(操作) 表示对文档的修改</strong><br>例如插入文本，删除文本这些都可以看作是一个 <code>operation</code>。如同我们 Git 操作中，两个 commit 之间的 diff</li>
<li><strong>一个 Operation(操作) 包含多个 action(行为)</strong><br>共有三种 action: insert, delete, retain</li>
</ul>
<h3 id="Actions-insert-delete-retain"><a href="#Actions-insert-delete-retain" class="headerlink" title="Actions(insert, delete, retain)"></a>Actions(insert, delete, retain)</h3><blockquote>
<p>When you apply an operation to a string, an invisible cursor begins traversing the string from left to right. The insert and delete components mutate the string at the current position of the cursor while the retain component simply advances the position of the cursor by the specified number of characters.</p>
</blockquote>
<p>将 operation 应用到字符串时，有一个隐形的光标位于字符串起点，<code>retain</code> 用于移动光标，<code>insert</code> 和 <code>delete</code> 在光标所在位置对字符串进行字符插入和删除，operation 应用完后，光标必须处于字符串的末端（这保证了应用 operation 的正确性）。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> operation = <span class="function"><span class="keyword">new</span> <span class="title">ot</span>.<span class="title">Operation</span>()</span></div><div class="line">  .<span class="title">retain</span>(<span class="number">11</span>)</div><div class="line">  .<span class="title">insert</span>(" dolor");</div><div class="line"></div><div class="line"><span class="title">operation</span>.<span class="title">apply</span>("lorem ipsum"); <span class="comment">// =&gt; "lorem ipsum dolor"</span></div></pre></td></tr></table></figure>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/EB6D28DA-FACE-4B68-BB71-1A7E8ABFFDEE.png" alt=""></p>
<p>这个例子中，operation 包含两个 action: <code>retain(11)</code> 和 <code>insert(&quot; dolor&quot;)</code>，顺序执行这两个 action，光标从左往右移动 11 个字符，然后在光标当前位置插入字符 <code>&quot; dolor&quot;</code>，光标最终到达字符串末端，operation 应用完成。</p>
<p>我们再将 operation 应用到字符串 <code>&quot;lorem ipsum amet&quot;</code> 中，发现会报错！<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">operation</span><span class="selector-class">.apply</span>(<span class="string">"lorem ipsum amet"</span>); <span class="comment">// throws an error</span></div></pre></td></tr></table></figure></p>
<p>这是因为 operation 应用完后，隐形的光标并不处于字符串末端，所以报错；要解决这个问题也简单，增加一个 <code>retain</code> 行为将光标移动到字符串末端。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operation.retain(<span class="number">5</span>).<span class="built_in">apply</span>(<span class="string">"lorem ipsum amet"</span>); // =&gt; <span class="string">"lorem ipsum dolor amet"</span></div></pre></td></tr></table></figure></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/36EAED8F-D0E3-48F4-AAC9-9FC7AE2EFC88.png" alt=""></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> operation = <span class="built_in">new</span> ot.Operation() // create <span class="built_in">new</span> operation</div><div class="line">  .<span class="built_in">delete</span>(<span class="string">"lorem "</span>)</div><div class="line">  .retain(<span class="number">5</span>);</div><div class="line">operation.<span class="built_in">apply</span>(<span class="string">"lorem ipsum"</span>); // =&gt; <span class="string">"ipsum"</span></div></pre></td></tr></table></figure>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/4CA49A74-0941-4E5E-A7E5-78410D96D148.png" alt=""></p>
<p>在这个例子中，operation 包含两个 action: <code>delete(&quot;lorem &quot;)</code> 和 <code>retain(5)</code>，顺序执行这两个 action，先删除字符 <code>&quot;lorem &quot;</code>，然后光标再从左往右移动 5 个字符恰好到达字符串末端，operation 应用完成。</p>
<p>在严谨的 OT 算法实现中，<code>delete</code> 删除字符是要严格匹配的。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">operation</span><span class="selector-class">.apply</span>(<span class="string">"trolo ipsum"</span>); <span class="comment">// 删除字符不匹配，throws an error</span></div></pre></td></tr></table></figure></p>
<p>但是在实际的算法实现中，很多是根据删除字符的长度来进行删除，例如 ot.js 库就是这样处理，在实际协同文本编辑器应用中也基本满足要求了，无需再对删除字符进行比较，一定程度上也提高了处理效率。</p>
<h3 id="操作合并-compose"><a href="#操作合并-compose" class="headerlink" title="操作合并(compose)"></a>操作合并(compose)</h3><p>前面提到：<strong>一个 Operation(操作) 包含多个 action(行为)</strong>，这样有一个好处是：<strong>多个 operation 能合并 (compose) 成一个</strong>。</p>
<blockquote>
<p><strong><em>apply(apply(S, A), B) = apply(S, compose(A, B))</em></strong><br>多个 operation 依次应用等价于，先将多个 operation 合并成一个，然后再进行应用</p>
</blockquote>
<p>例如有两个 operation 要应用到一个字符串上，正常的做法是这两个 operation 依次进行应用；现在我们可以先对两个 operation 进行合并成一个 operation，然后再进行应用。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Define two consecutive operations</span></div><div class="line"><span class="keyword">var</span> operation0 = <span class="keyword">new</span> <span class="type">ot</span>.Operation()</div><div class="line">  .retain(<span class="number">11</span>)</div><div class="line">  .insert(<span class="string">" dolor"</span>);</div><div class="line"><span class="keyword">var</span> operation1 = <span class="keyword">new</span> <span class="type">ot</span>.Operation()</div><div class="line">  .delete(<span class="string">"lorem "</span>)</div><div class="line">  .retain(<span class="number">11</span>);</div><div class="line"></div><div class="line"><span class="comment">// Our input string</span></div><div class="line"><span class="keyword">var</span> str0 = <span class="string">"lorem ipsum"</span>;</div></pre></td></tr></table></figure></p>
<p>依次应用这两个 operation：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Apply operations one after another</span></div><div class="line">var str<span class="number">1</span> = operatio<span class="symbol">n0</span>.apply<span class="comment">(str0)</span>; <span class="comment">// "lorem ipsum dolor"</span></div><div class="line">var str<span class="number">2</span>a = operatio<span class="symbol">n1</span>.apply<span class="comment">(str1)</span>; <span class="comment">// "ipsum dolor"</span></div></pre></td></tr></table></figure></p>
<p>先将两个 operation 合并成一个，然后再应用这个 operation：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Combine operations <span class="keyword">and</span> <span class="built_in">apply</span> the combined operation</div><div class="line"><span class="built_in">var</span> combinedOperation = operation0.compose(operation1);</div><div class="line"><span class="built_in">var</span> str2b = combinedOperation.<span class="built_in">apply</span>(str0); // <span class="string">"ipsum dolor"</span></div></pre></td></tr></table></figure></p>
<h3 id="操作转换-transform"><a href="#操作转换-transform" class="headerlink" title="操作转换(transform)"></a>操作转换(transform)</h3><p>OT 算法的核心就是这个 <code>transform</code> 转换算法，OT 的思路是将编辑转换成操作 (operation)，当多人协同操作时，就需要对这些操作进行转换，使得最终文档的内容一致。</p>
<p>例如：文档内容是：’go’，两个用户同时在字符串末尾执行字符插入：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> str = <span class="string">'go'</span></div></pre></td></tr></table></figure></p>
<p>Client-A:<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> opA = <span class="function"><span class="keyword">new</span> <span class="title">ot</span>.<span class="title">Operation</span>()</span></div><div class="line">  .<span class="title">retain</span>(<span class="number">2</span>)</div><div class="line">  .<span class="title">insert</span>("a");</div><div class="line"></div><div class="line"><span class="title">opA</span>.<span class="title">apply</span>(str) <span class="comment">// =&gt; goa</span></div></pre></td></tr></table></figure></p>
<p>Client-B:<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> opB = <span class="function"><span class="keyword">new</span> <span class="title">ot</span>.<span class="title">Operation</span>()</span></div><div class="line">  .<span class="title">retain</span>(<span class="number">2</span>)</div><div class="line">  .<span class="title">insert</span>("t");</div><div class="line"><span class="title">opB</span>.<span class="title">apply</span>(str) <span class="comment">// =&gt; got</span></div></pre></td></tr></table></figure></p>
<p>用户对文档的插入操作会立即应用到本地文档副本，然后将操作 <code>opA</code> 和 <code>opB</code> 上传到服务器；服务器先后接收到这两个操作，然后对服务端的这份文档进行应用，假设以先 <code>opA</code> 后 <code>opB</code> 的顺序，应用 <code>opA</code> 后，字符串变成 <code>goa</code>，长度变成 3；然后应用 <code>opB</code>，隐形的光标未到字符串末端，执行会抛出错误。<br>此外，服务端也会将 <code>opA</code> 发送给 Client-B，<code>opB</code> 发送给 Client-A，由于此时字符串都长度都变成 3，应用过程中隐形的光标未到字符串末端，会抛出错误。但即使能应用成果，结果也是：</p>
<ul>
<li>Client-A: ‘goa’ + (retain(2); insert(‘t’)) = ‘gota’</li>
<li>Client-B: ‘got’ + (retain(2); insert(‘a’)) = ‘goat’</li>
</ul>
<p>两个用户得到的文档内容也不一致了，这种情况下就需要 <code>transform</code> 操作转换了。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/49EEDFD9-F635-4F55-8DCA-C165E4813AC6.png" alt=""></p>
<p>① 如上图左，<code>a</code> 表示客户端的 operation，<code>b</code> 表示服务端的 operation，二者相交的顶点表示文档状态相同，此时客户端和服务端对文档分别应用操作 <code>a</code> 和 <code>b</code>，这时两边的文档内容都发生变化，且不一致；为了客户端和服务端的文档达到一致的状态，我们需要对 <code>a</code> 和 <code>b</code> 进行操作转换 <code>transfrom(a, b) =&gt; (a&#39;, b&#39;)</code> 得到两个衍生的操作 <code>a&#39;</code> 和 <code>b&#39;</code>。<br>② 如上图右，<code>a&#39;</code> 在服务端应用，<code>b&#39;</code> 在客户端应用，最终文档内容达到一致。</p>
<p>上面这种问题称之为：<strong>one-step diamond problem</strong>，客户端和服务端同时对文档执行一个 operation，从上方顶点分裂开两条边，相当于 diamond 图形的上方两边（<code>a</code>, <code>b</code>），通过 OT 算法的 <code>transform</code> 方法得到两个衍生的 operation，客户端和服务端分别执行这两个衍生的 operation，相当于 diamond 图形的下方两边（<code>a&#39;</code>, <code>b&#39;</code>），这样从上方顶点分裂开的两边又汇合到下顶点，构成一个完整的 diamond 图形。diamond 图形的上下两个顶点表示客户端和服务器的文档内容处于相同状态。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/EE6A20BC-A5EA-4BA4-B7F8-566310464A8D.png" alt=""></p>
<p>所以这个例子的正确解法是：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var transformedPair</span> = ot.Operation.transform(opA, opB);</div><div class="line"><span class="attribute">var opAPrime</span> = transformedPair[0];</div><div class="line"><span class="attribute">var opBPrime</span> = transformedPair[1];</div><div class="line"></div><div class="line"><span class="attribute">var strABPrime</span> = opAPrime.apply(strB);</div><div class="line"><span class="attribute">var strBAPrime</span> = opBPrime.apply(strA);</div></pre></td></tr></table></figure></p>
<h3 id="operation-的逆向操作"><a href="#operation-的逆向操作" class="headerlink" title="operation 的逆向操作"></a>operation 的逆向操作</h3><blockquote>
<p>The inverse of an operation is the operation that reverts the effects of the operation</p>
</blockquote>
<p>例如一个 opration 包含 <code>insert(&quot;hello &quot;); retain(6);</code> 这两个 action；那么这个 operation 的逆向操作就是 <code>delete(&quot;hello &quot;); retain(6);</code><br>一个 operation 的逆向主要用于 Undo/Redo，在文档编辑中执行了一个 operation，那么需要将其逆向操作推入 undo/redo 栈中，在撤销/回撤时，弹出栈顶 operation 执行。</p>
<blockquote>
<p>undo/redo 入栈的数据除了当前操作的 inverse operation，还包括了选区信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// inverseOperation inverse operation</span></div><div class="line"><span class="comment">// Metadata: selection</span></div><div class="line"><span class="function"><span class="title">WrappedOperation</span><span class="params">(inverseOperation, Metadata)</span></span></div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="C-S-模式"><a href="#C-S-模式" class="headerlink" title="C/S 模式"></a>C/S 模式</h2><p>绝大多数的协同应用都是 Client/Server(C/S) 模式，下面我们将分析 OT 算法在 C/S 模式下的处理过程。</p>
<h3 id="compound-OT"><a href="#compound-OT" class="headerlink" title="compound OT"></a>compound OT</h3><p>上一节中介绍了客户端和服务端各有一个操作的情况，通过 <code>transform</code> 操作变换，将客户端和服务端的文档内容收敛到相同状态；但是在实际应用场景中，不可能仅仅只有一个操作，而是有多个操作，假设客户端有两个操作，服务端只有一个操作，如下图所示：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/AC60F950-D30A-44BC-AB0C-19719EA41C5B.png" alt=""></p>
<p>此时需要构建两个 diamond 图形才能使客户端和服务端的文档收敛到相同的状态。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/7F6B6005-8F23-4294-A94C-196EFE124E8A.png" alt=""><br>如上图客户端有三个操作，服务端有一个操作的时候，需要构建三个 diamond 图形能将两端文档内容收敛到相同状态；由此我们可以类推出，当两端操作数出现多对一 <code>N:1</code> 或者一对多 <code>1:N</code> 的关系时，可以递归构建 diamond 图形来使得两端内容最终收敛到相同状态。<br>假设已知客户端有一个操作 <code>clientOp</code>，服务端有多个操作 <code>serverOps</code> ，那么可以通过如下代码，计算出客户端的操作经过变换，在服务端应用的操作 <code>clientOpPrime</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> clientOp</div><div class="line"><span class="keyword">var</span> serverOps = []</div><div class="line"><span class="keyword">var</span> clientOpPrime = clientOp</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; serverOps.length; i++) &#123;</div><div class="line">  clientOpPrime = transform(clientOpPrime, serverOps[i])[<span class="number">0</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，客户端和服务端的操作数也有可能出现多对多 <code>N:M</code> 的关系，那么做法是将 <code>N:M</code> 的关系拆分成多个 <code>N:1</code> 或者 <code>1:N</code> 的关系来解决。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/781C4BCD-1D5C-4AD2-9173-B8CF6CD5C016.png" alt=""></p>
<h3 id="revision-版本号"><a href="#revision-版本号" class="headerlink" title="revision(版本号)"></a>revision(版本号)</h3><ul>
<li>文档一次编辑前后的差异 (diff) 即为一个 operation 操作</li>
<li>每一个操作对应一次版本号顺序递增</li>
<li>客户端和服务端各自维持一个版本号<ul>
<li>客户端进行一次编辑产生一个 operation 或者从服务端接收到一个 operation，客户端版本号都会递增一</li>
<li>服务端作为客户端并发编辑操作串行化的地点，除了保存文档内容，还会将客户端发过来的 operation 保存到一个数组中，这个数组也就是文档编辑的历史记录。服务端每接收到一个操作，服务端版本号会递增一</li>
<li><strong>客户端版本号始终小于等于服务端版本号</strong></li>
</ul>
</li>
</ul>
<h3 id="C-S-直接的交互"><a href="#C-S-直接的交互" class="headerlink" title="C/S 直接的交互"></a>C/S 直接的交互</h3><ul>
<li>客户端将一次编辑操作（例如输入/删除字符，设置文本样式等）封装成一个 operation，通过 socket 将当前客户端版本号 revision 和编辑操作 operation 发送到服务端</li>
<li>服务端接收到客户端的信息 <code>(revision, operation)</code> 后，执行如下处理函数<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">receiveOperation (revision, operation) &#123;</div><div class="line">  <span class="comment">// ① revision check</span></div><div class="line">  <span class="keyword">if</span> (revision &lt; <span class="number">0</span> || <span class="keyword">this</span>.operations.length &lt; revision) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'operation revision not in history'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ② Find all operations that the client didn't know of when it sent the</span></div><div class="line">  <span class="comment">// operation ...</span></div><div class="line">  <span class="keyword">var</span> concurrentOperations = <span class="keyword">this</span>.operations.slice(revision)</div><div class="line"></div><div class="line">  <span class="comment">// ... and transform the operation against all these operations ...</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; concurrentOperations.length; i++) &#123;</div><div class="line">    operation = WrappedOperation.transform(operation, concurrentOperations[i])[<span class="number">0</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ③ ... and apply that on the document.</span></div><div class="line">  <span class="keyword">this</span>.document = operation.apply(<span class="keyword">this</span>.document)</div><div class="line">  <span class="comment">// Store operation in history.</span></div><div class="line">  <span class="keyword">this</span>.operations.push(operation)</div><div class="line"></div><div class="line">  <span class="comment">// It's the caller's responsibility to send the operation to all connected</span></div><div class="line">  <span class="comment">// clients and an acknowledgement to the creator.</span></div><div class="line">  <span class="keyword">return</span> operation</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>👉 剖析一下这个函数：</p>
<ul>
<li><strong>注释①</strong>：客户端和服务端版本号大小比较，确保<em>客户端版本号始终小于等于服务端版本号</em>，否则报错</li>
<li><strong>注释②</strong>：客户端操作和服务端操作递归执行 <code>transform</code> 操作变换</li>
<li><strong>注释③</strong>：将<em>注释②</em>结果应用到当前文档，并保存到历史操作数组中</li>
<li>最后，将 <code>receiveOperation (revision, operation)</code> 这个函数返回的 <code>operation</code> 发送给其他协同编辑的客户端</li>
</ul>
<h3 id="UNDO-REDO"><a href="#UNDO-REDO" class="headerlink" title="UNDO/REDO"></a>UNDO/REDO</h3><p>客户端从服务端接收到一个 <code>operation</code> 后，需要使用这个 <code>operation</code> 对 UNDO/REDO 栈中的所有操作进行 <code>transform</code> 变换<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">transform (operation) &#123;</div><div class="line">  <span class="keyword">this</span>.undoStack = <span class="keyword">this</span>._transformStack(<span class="keyword">this</span>.undoStack, operation)</div><div class="line">  <span class="keyword">this</span>.redoStack = <span class="keyword">this</span>._transformStack(<span class="keyword">this</span>.redoStack, operation)</div><div class="line">&#125;</div><div class="line">_transformStack (stack, operation) &#123;</div><div class="line">  <span class="keyword">var</span> newStack = []</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = stack.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">var</span> pair = WrappedOperation.transform(stack[i], operation)</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> pair[<span class="number">0</span>].isNoop !== <span class="string">'function'</span> || !pair[<span class="number">0</span>].isNoop()) &#123;</div><div class="line">      newStack.push(pair[<span class="number">0</span>])</div><div class="line">    &#125;</div><div class="line">    operation = pair[<span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newStack.reverse()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="OT-富文本支持"><a href="#OT-富文本支持" class="headerlink" title="OT 富文本支持"></a>OT 富文本支持</h2><p>关于扩展 ot.js 支持富文本属性，可以参考文件 <a href="">TextAction.js</a> 和 <a href="">TextOperation.js</a>，此处不展开介绍（后面再写文章对此介绍）</p>
<p>前面提到服务端保存了两套数据：</p>
<ul>
<li>文档内容，这是一段纯文本字符串</li>
<li>文档编辑历史记录，这是一个保存 operation 的数组</li>
</ul>
<p>注意到文档内容是纯文本，并不包含富文本信息。客户端打开文档时，需要将文档历史记录中所有的 operation 合并成一个 operation（合并逻辑可放在服务端处理，将合并后的 operation 发给客户端），然后对文档内容执行这个 operation，这样才会让文档显示出富文本样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">initClientContent () &#123;</div><div class="line">  <span class="comment">// init the editor content with historyOps</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.historyOps &amp;&amp; <span class="keyword">this</span>.historyOps.length) &#123;</div><div class="line">    <span class="keyword">var</span> _ops = <span class="keyword">this</span>.historyOps.map(<span class="function"><span class="params">wrappedOp</span> =&gt;</span> wrappedOp.wrapped)</div><div class="line">    <span class="keyword">var</span> initialTextOp = <span class="keyword">new</span> TextOperation()</div><div class="line"></div><div class="line">    _ops.forEach(<span class="function">(<span class="params">op</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">var</span> _textOp = TextOperation.fromJSON(op)</div><div class="line">      initialTextOp = initialTextOp.compose(_textOp)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.applyOperation(initialTextOp)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="external">Operational-Transformation/ot.js</a><br><a href="http://operational-transformation.github.io/index.html" target="_blank" rel="external">Operational Transformation</a><br><a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation" target="_blank" rel="external">Understanding and Applying Operational Transformation</a><br><a href="http://blog.csdn.net/pheecian10/article/details/78496854" target="_blank" rel="external">Operational Transformation算法图解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Operational%20Transformation.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当多用户协同编辑同一篇文档，由于没有锁的机制，便会出现内容冲突，这时就需要一定的算法来自动解决冲突，使所有对文档的修改同步后，每个协同编辑的用户看到的文档内容是完全一致的。而 Operational Transformation (简称 OT) 算法就是解决协同问题的通用算法，支持各类协同编辑引用，例如文档，表格，演示，代码编辑等。其最早发表于 1989 年，后因 Google 的在线协作产品 Google Wave，Google Docs 的应用而成熟流行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 Google Wave: &lt;a href=&quot;http://www.ifanr.com/675122&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Wave，值得纪念的伟大失败&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GitHub 上开源项目 &lt;a href=&quot;https://github.com/Operational-Transformation/ot.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ot.js&lt;/a&gt; 已经对 OT 算法进行 JavaScript 语言实现。本文将对 OT 算法进行介绍 👉&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;❗️注意:&lt;/strong&gt; ot.js 库只是针对纯文本协同编辑的 OT 算法实现；SharedPen 使用了这个库，但是 SharedPen 支持富文本编辑，所以需要对 ot.js 库进行增强，使之支持富文本文档编辑的协同。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SharedPen" scheme="http://objcer.com/categories/SharedPen/"/>
    
    
      <category term="Operational Transformation" scheme="http://objcer.com/tags/Operational-Transformation/"/>
    
  </entry>
  
  <entry>
    <title>SharedPen 之 AnnotationList</title>
    <link href="http://objcer.com/2018/02/27/SharedPen-AnnotationList/"/>
    <id>http://objcer.com/2018/02/27/SharedPen-AnnotationList/</id>
    <published>2018-02-27T14:35:29.000Z</published>
    <updated>2018-03-05T15:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Annotation.png" alt=""></p>
<p>CodeMirror 是一款优秀的开源文本编辑器，常用于代码编辑器。但并不支持富文本编辑功能。但是得益于 CodeMirror 的 API</p>
<blockquote>
<p><a href="https://codemirror.net/doc/manual.html#api_marker" target="_blank" rel="external">markText</a>: <strong>Can be used to mark a range of text with a specific CSS class name.</strong></p>
</blockquote>
<p>能够为指定 range 的文本设置一个 CSS class，这样我们就可以通过这个 class 来设置富文本样式。例如对于文本：<code>ABCDEFGHF</code>，我们可以通过如下方式为其设置 class<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">doc</span><span class="selector-class">.markText</span>(&#123;<span class="attribute">line</span>:<span class="number">0</span>, ch: <span class="number">0</span>&#125;, &#123;<span class="attribute">line</span>: <span class="number">0</span>, ch: <span class="number">3</span>&#125;, &#123;<span class="attribute">className</span>: <span class="string">'classA'</span>&#125;)</div><div class="line"><span class="selector-tag">doc</span><span class="selector-class">.markText</span>(&#123;<span class="attribute">line</span>:<span class="number">0</span>, ch: <span class="number">3</span>&#125;, &#123;<span class="attribute">line</span>: <span class="number">0</span>, ch: <span class="number">6</span>&#125;, &#123;<span class="attribute">className</span>: <span class="string">'classB'</span>&#125;)</div><div class="line"><span class="selector-tag">doc</span><span class="selector-class">.markText</span>(&#123;<span class="attribute">line</span>:<span class="number">0</span>, ch: <span class="number">6</span>&#125;, &#123;<span class="attribute">line</span>: <span class="number">0</span>, ch: <span class="number">9</span>&#125;, &#123;<span class="attribute">className</span>: <span class="string">'classC'</span>&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/marktext.png" alt=""></p>
<p><code>markText</code> 方法会返回一个 <code>CodeMirror.TextMarker</code> 对象，该对象中的 <code>clear()</code> 方法用于清除 class，这样就非常便于我们动态为文本设置富文本样式了。</p>
<p>为了管理，操作整个富文本文档流，我们引入 <strong>AnnotationList</strong> 单链表结构，把每一段富文本当成 <code>Node</code> 节点，由此形成链表结构。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/annotation-list.png" alt=""></p>
<p>本文将详解 AnnotationList 单链表结构 🤓</p>
<a id="more"></a>
<h2 id="文本区间-Span-类"><a href="#文本区间-Span-类" class="headerlink" title="文本区间 Span 类"></a>文本区间 <code>Span</code> 类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Span</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> (pos, length) &#123;</div><div class="line">    <span class="keyword">this</span>.pos = pos</div><div class="line">    <span class="keyword">this</span>.length = length</div><div class="line">  &#125;</div><div class="line">  end () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos + <span class="keyword">this</span>.length</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Span</code> 表示一段文本区间：</p>
<ul>
<li><code>pos</code>：区间起点</li>
<li><code>length</code>：区间长度（若长度为0，即未选中文字，只表示光标位置）</li>
</ul>
<h2 id="链表节点-Node-类"><a href="#链表节点-Node-类" class="headerlink" title="链表节点 Node 类"></a>链表节点 <code>Node</code> 类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> (length, <span class="keyword">annotation</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.length = length</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">annotation</span> = <span class="keyword">annotation</span></div><div class="line">    <span class="keyword">this</span>.attachedObject = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链表节点包含四个属性：</p>
<ul>
<li><code>length</code>：表示该节点的文本的长度，需要注意的是，<strong>节点并不需要直接存储文本内容</strong></li>
<li><code>annotation</code>：表示节点包含的富文本属性</li>
<li><code>attachedObject</code>：<code>CodeMirror.TextMarker</code> 对象</li>
<li><code>next</code>：指向下一个节点</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/list-node.png" alt=""></p>
<h2 id="辅助方法-getAffectedNodes-span"><a href="#辅助方法-getAffectedNodes-span" class="headerlink" title="辅助方法 getAffectedNodes_(span)"></a>辅助方法 <code>getAffectedNodes_(span)</code></h2><p>此方法用于获取指定文本区间(span)在单链表中的节点信息，包括：</p>
<ul>
<li><code>start</code>: the node contains the first character in span.</li>
<li><code>end</code>: the node contains the last character in span.</li>
<li><code>beforeStart</code>: the node before <code>start</code> node.</li>
<li><code>succ</code>: the node after <code>end</code> node if <code>span.end()</code> was on a node boundary, else <code>null</code>.</li>
<li><code>pred</code>: the node before <code>start</code> if <code>span.pos</code> was on a node boundary, else <code>null</code>.</li>
<li><code>beforePred</code>: the node before <code>pred</code> node.</li>
<li><code>startPos</code>: the position of <code>start</code> node</li>
<li><code>predPos</code>: the position of <code>pred</code> node</li>
</ul>
<h3 id="start-和-end"><a href="#start-和-end" class="headerlink" title="start 和 end"></a><code>start</code> 和 <code>end</code></h3><p><code>start</code> 和 <code>end</code> 分别表示文本区间(span)的第一个和最后一个字符所在的节点。<br>大致有如下三种情况：</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/start-end-node.png" alt=""></p>
<h3 id="pred-和-succ"><a href="#pred-和-succ" class="headerlink" title="pred 和 succ"></a><code>pred</code> 和 <code>succ</code></h3><p><code>pred</code> 和 <code>succ</code> 是指文本区间(span)左右边界恰好也是处于单链表节点边界处时，左边界的前一个节点和右边界的后一个节点。<br>大致有如下五种情况：</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/pred-succ-node.png?t=1" alt=""></p>
<h3 id="startPos-和-predPos"><a href="#startPos-和-predPos" class="headerlink" title="startPos 和 predPos"></a><code>startPos</code> 和 <code>predPos</code></h3><p><code>startPos</code> 和 <code>predPos</code> 是指 <code>start</code> 和 <code>pred</code> 节点首字符在整个文档中的位置</p>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><p>文档编辑过程中的富文本操作对应到单链表中的操作包括增删改查，其中插入，删除和更新，这些方法都依赖这个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wrapOperation_ (span, operationFn)</div><div class="line"></div><div class="line"><span class="keyword">this</span>.wrapOperation_(span, <span class="function"><span class="keyword">function</span> (<span class="params">startPos, start</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> newNodes</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>其中 <code>span</code> 指定文本区间；而 <code>operationFn(res.startPos, res.start)</code> 回调方法根据从辅助方法 <code>getAffectedNodes_(span)</code> 获取的 <strong><code>startPos</code>, <code>start</code></strong> 信息生成一段新的链表段。<code>wrapOperation_</code> 将新生成的这段链表融入到原有的 AnnotationList 单链表。</p>
<h3 id="插入操作-insertAnnotatedSpan"><a href="#插入操作-insertAnnotatedSpan" class="headerlink" title="插入操作 insertAnnotatedSpan"></a>插入操作 <code>insertAnnotatedSpan</code></h3><p>插入操作包括两种情况：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/insert-span.png" alt=""></p>
<p>其中前者在节点间隔处插入，<code>start</code> 节点为 <code>null</code>，此时由新插入的文本生成 Node 节点作为新生成链表段直接返回；而后者在节点中插入，<code>start</code> 节点为当前节点，生成新链表段需要将 <code>start</code> 节点从插入点分裂生成两个节点，新插入的文本作为新 Node 节点插入其中，如下图所示：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/insert-span-action.png?t=1" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAnnotatedSpan</span> (<span class="params">span, annotation</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.wrapOperation_(<span class="keyword">new</span> Span(span.pos, <span class="number">0</span>), <span class="function"><span class="keyword">function</span> (<span class="params">oldPos, old</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> toInsert = <span class="keyword">new</span> Node(span.length, annotation)</div><div class="line">    <span class="keyword">if</span> (!old) &#123;</div><div class="line">      <span class="keyword">return</span> toInsert</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">var</span> newNodes = <span class="keyword">new</span> Node(<span class="number">0</span>, NullAnnotation)</div><div class="line">      <span class="comment">// Insert part of old before insertion point.</span></div><div class="line">      newNodes.next = <span class="keyword">new</span> Node(span.pos - oldPos, old.annotation)</div><div class="line">      <span class="comment">// Insert new node.</span></div><div class="line">      newNodes.next.next = toInsert</div><div class="line">      <span class="comment">// Insert part of old after insertion point.</span></div><div class="line">      toInsert.next = <span class="keyword">new</span> Node(oldPos + old.length - span.pos, old.annotation)</div><div class="line">      <span class="keyword">return</span> newNodes.next</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除操作-removeSpan"><a href="#删除操作-removeSpan" class="headerlink" title="删除操作 removeSpan"></a>删除操作 <code>removeSpan</code></h3><p>删除操作中，要求文本区间长度大于 0；其执行过程如下图所示：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/delete-span-action.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeSpan</span> (<span class="params">removeSpan</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (removeSpan.length === <span class="number">0</span>) &#123; <span class="keyword">return</span> &#125;</div><div class="line">  <span class="keyword">this</span>.wrapOperation_(removeSpan, <span class="function"><span class="keyword">function</span> (<span class="params">oldPos, old</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNodes = <span class="keyword">new</span> Node(<span class="number">0</span>, NullAnnotation)</div><div class="line">    <span class="keyword">var</span> current = newNodes</div><div class="line">    <span class="comment">// ① Add new node for part before the removed span (if any).</span></div><div class="line">    <span class="keyword">if</span> (removeSpan.pos &gt; oldPos) &#123;</div><div class="line">      current.next = <span class="keyword">new</span> Node(removeSpan.pos - oldPos, old.annotation)</div><div class="line">      current = current.next</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ② Skip over removed nodes.</span></div><div class="line">    <span class="keyword">while</span> (removeSpan.end() &gt; oldPos + old.length) &#123;</div><div class="line">      oldPos += old.length</div><div class="line">      old = old.next</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ③ Add new node for part after the removed span (if any).</span></div><div class="line">    <span class="keyword">var</span> afterChars = oldPos + old.length - removeSpan.end()</div><div class="line">    <span class="keyword">if</span> (afterChars &gt; <span class="number">0</span>) &#123;</div><div class="line">      current.next = <span class="keyword">new</span> Node(afterChars, old.annotation)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNodes.next</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更新操作-updateSpan"><a href="#更新操作-updateSpan" class="headerlink" title="更新操作 updateSpan"></a>更新操作 <code>updateSpan</code></h3><p>更新操作中，文本区间长度也要大于 0；其执行过程如下图所示：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/update-span-action.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSpan</span> (<span class="params">span, updateFn</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (span.length === <span class="number">0</span>) &#123; <span class="keyword">return</span> &#125;</div><div class="line">  <span class="keyword">this</span>.wrapOperation_(span, <span class="function"><span class="keyword">function</span> (<span class="params">oldPos, old</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNodes = <span class="keyword">new</span> Node(<span class="number">0</span>, NullAnnotation)</div><div class="line">    <span class="keyword">var</span> current = newNodes</div><div class="line">    <span class="keyword">var</span> currentPos = oldPos</div><div class="line"></div><div class="line">    <span class="comment">// ① Add node for any characters before the span we're updating.</span></div><div class="line">    <span class="keyword">var</span> beforeChars = span.pos - currentPos</div><div class="line">    <span class="keyword">if</span> (beforeChars &gt; <span class="number">0</span>) &#123;</div><div class="line">      current.next = <span class="keyword">new</span> Node(beforeChars, old.annotation)</div><div class="line">      current = current.next</div><div class="line">      currentPos += current.length</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ② Add updated nodes for entirely updated nodes.</span></div><div class="line">    <span class="keyword">while</span> (old !== <span class="literal">null</span> &amp;&amp; span.end() &gt;= oldPos + old.length) &#123;</div><div class="line">      <span class="keyword">var</span> length = oldPos + old.length - currentPos</div><div class="line">      current.next = <span class="keyword">new</span> Node(length, updateFn(old.annotation, length))</div><div class="line">      current = current.next</div><div class="line">      oldPos += old.length</div><div class="line">      old = old.next</div><div class="line">      currentPos = oldPos</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ③ Add updated nodes for last node.</span></div><div class="line">    <span class="keyword">var</span> updateChars = span.end() - currentPos</div><div class="line">    <span class="keyword">if</span> (updateChars &gt; <span class="number">0</span>) &#123;</div><div class="line">      current.next = <span class="keyword">new</span> Node(updateChars, updateFn(old.annotation, updateChars))</div><div class="line">      current = current.next</div><div class="line">      currentPos += current.length</div><div class="line"></div><div class="line">      <span class="comment">// ④ Add non-updated remaining part of node.</span></div><div class="line">      current.next = <span class="keyword">new</span> Node(oldPos + old.length - currentPos, old.annotation)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newNodes.next</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="wrapOperation"><a href="#wrapOperation" class="headerlink" title="wrapOperation_"></a>wrapOperation_</h3><p><code>wrapOperation_</code> 方法是 AnnotationList 链表操作的核心方法，通过这个方法会从单链表中提取需旧节点数组和新节点数组，如下图所示：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/oldNodes-newNodes.png" alt=""></p>
<p>其中浅灰色层覆盖的节点为 <code>oldNodes</code> 数组；浅蓝色层覆盖的节点为 <code>newNodes</code> 数组。得到这两个数组后，首先对 <code>oldNodes</code> 数组中的节点进行操作，通过 <code>attachedObject</code> 属性得到 <code>CodeMirror.TextMarker</code> 对象，调用 <code>clear()</code> 方法，取消先前设置的 class。然后对 <code>newNodes</code> 数组中的节点，通过 <code>markText</code> 方法设置相应的 class。</p>
<p>👇下面列几个在这个方法中比较关键(链表优化)的处理：</p>
<p><strong>1. <code>mergeNodesWithSameAnnotations_</code></strong><br>通过 <code>wrapOperation_ (span, operationFn)</code> 回调函数 <code>operationFn</code> 会生成一小段新的链表 <code>var newSegment = operationFn(res.startPos, res.start)</code>，得到这段新链表段后，需要对其进行一个预处理，合并其中节点富文本属性 <strong><code>annotation</code></strong> 相同的节点，这个过程调用 <code>mergeNodesWithSameAnnotations_</code> 方法<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">this</span>.mergeNodesWithSameAnnotations_(<span class="keyword">new</span><span class="type">Segment</span>)</div></pre></td></tr></table></figure></p>
<p><strong>2. 存在 <code>pred</code> 或者 <code>succ</code> 节点时的判断</strong><br>考虑如下这种情况：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/AD4C499B-D669-4251-B59D-0162041C4D97.png" alt=""></p>
<p>对中间三个节点进行更新操作，那么由于选择的文本区间边界正好处于链表的节点边界，所以 <code>pred</code> 和 <code>succ</code> 节点都不为空，那么此时需要进行两个判断：</p>
<ul>
<li><code>pred</code> 节点和 <code>newSegment</code> 的首节点判断富文本属性 <code>annotation</code> 是否相同；若相同，说明 <code>pred</code> 节点和<code>newSegment</code> 的首节点可以<strong>合并</strong>，那么需要将 <code>pred</code> 节点纳入 <code>oldNodes</code> 数组</li>
<li>同理，<code>succ</code> 节点和 <code>newSegment</code> 的最后一个节点也需要执行如上逻辑的判断</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (res.pred &amp;&amp; res.pred.annotation.equals(newSegment.annotation)) &#123;</div><div class="line">  // We can merge the pred <span class="keyword">node</span> <span class="title">with</span> newSegment's first <span class="keyword">node</span>.</div><div class="line">  <span class="title">includePredInOldNodes</span> = <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">if (res.succ &amp;&amp; res.succ.annotation.equals(newSegment.annotation)) &#123;</div><div class="line">  // We can merge newSegment's last <span class="keyword">node</span> <span class="title">with</span> the succ <span class="keyword">node</span>.</div><div class="line">  <span class="title">includeSuccInOldNodes</span> = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p><strong>AnnotationList</strong> 类中也提供了两个链表查询方法，根据 <code>pos</code> 位置信息或者 <code>span</code> 指定文本区间查询链表节点信息，基本上都是遍历链表的操作，此处不详述，直接参考源码即可。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnnotatedSpansForPos</span> <span class="params">(pos)</span></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnnotatedSpansForSpan</span> <span class="params">(span)</span></span></div></pre></td></tr></table></figure></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>AnnotationList</strong> 单链表结构执行操作的效率比较低，所有操作的算法复杂度都是 <code>O(n)</code>，这个链表长度会随着文章长度，富文本属性设置操作的增加而变长。优化的方向是，<strong>将链表结果改造成树状结构</strong>。这部分优化内容在文章 <a href="https://objcer.com/2018/03/05/SharedPen-IntervalTree-Optimization/">SharedPen 之区间树优化</a> 进行了详细介绍，欢迎前往阅读。🎏</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/SharedPen-Annotation.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CodeMirror 是一款优秀的开源文本编辑器，常用于代码编辑器。但并不支持富文本编辑功能。但是得益于 CodeMirror 的 API&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codemirror.net/doc/manual.html#api_marker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;markText&lt;/a&gt;: &lt;strong&gt;Can be used to mark a range of text with a specific CSS class name.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能够为指定 range 的文本设置一个 CSS class，这样我们就可以通过这个 class 来设置富文本样式。例如对于文本：&lt;code&gt;ABCDEFGHF&lt;/code&gt;，我们可以通过如下方式为其设置 class&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.markText&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;className&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;classA&#39;&lt;/span&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.markText&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;className&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;classB&#39;&lt;/span&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;doc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.markText&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;line&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, ch: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;attribute&quot;&gt;className&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;classC&#39;&lt;/span&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/marktext.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;markText&lt;/code&gt; 方法会返回一个 &lt;code&gt;CodeMirror.TextMarker&lt;/code&gt; 对象，该对象中的 &lt;code&gt;clear()&lt;/code&gt; 方法用于清除 class，这样就非常便于我们动态为文本设置富文本样式了。&lt;/p&gt;
&lt;p&gt;为了管理，操作整个富文本文档流，我们引入 &lt;strong&gt;AnnotationList&lt;/strong&gt; 单链表结构，把每一段富文本当成 &lt;code&gt;Node&lt;/code&gt; 节点，由此形成链表结构。&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/annotation-list.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将详解 AnnotationList 单链表结构 🤓&lt;/p&gt;
    
    </summary>
    
      <category term="SharedPen" scheme="http://objcer.com/categories/SharedPen/"/>
    
    
      <category term="AnnotationList" scheme="http://objcer.com/tags/AnnotationList/"/>
    
  </entry>
  
  <entry>
    <title>探究 Gulp：基于流的自动化构建工具</title>
    <link href="http://objcer.com/2018/02/27/Explore-Gulp/"/>
    <id>http://objcer.com/2018/02/27/Explore-Gulp/</id>
    <published>2018-02-27T14:21:40.000Z</published>
    <updated>2018-03-08T14:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/gulpjs-cover.png" alt=""></p>
<p>Gulp 是三个自动化构建工具（Grunt, Gulp, Webpack）之一，其通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理，仅提供几个 API 就能将构建任务很好完成，而且有着丰富的插件生态，本文将探究 Gulp 的原理及如何创建插件。</p>
<a id="more"></a>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><h3 id="Node-中的流"><a href="#Node-中的流" class="headerlink" title="Node 中的流"></a>Node 中的流</h3><p>Node 中的 Stream 一般分四种, 其中 Transform 也是 Duplex，只不过输出是由输入计算得到的，因此算作 Duplex 的特例。</p>
<ul>
<li>输入流(stream.Readable)</li>
<li>输出流(stream.Writable)</li>
<li>读写流(stream.Duplex)</li>
<li>转换流(stream.Transform)</li>
</ul>
<p>Stream 流有一个很基本的操作 <code>pipe</code> 管道。用于将一个流的输出口接到另一个流的输入口，起连接两个流的作用。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-class">.pipe</span>(<span class="selector-tag">b</span>)<span class="selector-class">.pipe</span>(<span class="selector-tag">c</span>)<span class="selector-class">.pipe</span>(<span class="selector-tag">d</span>)</div></pre></td></tr></table></figure></p>
<p>Stream 都是 Node 事件对象 EventEmitter 的实例( All streams are instances of EventEmitter )，它们可以通过 <code>on</code> 添加事件监听。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line">fs.createReadStream(<span class="string">'src.txt'</span>)</div><div class="line">  .pipe(fs.createWriteStream(<span class="string">'dest.txt'</span>))</div><div class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Write complete."</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p><code>fs.createReadStream(&#39;src.txt&#39;)</code> 创建了 Readable Stream，<code>fs.createWriteStream()</code> 创建了 Writable Stream，然后通过管道方法 <code>pipe</code> 就可以完成数据从 Readable Stream 到 Writable Stream 的流动。Stream 是 EventEmitter 的实例，通过 <code>on</code> 方法为 Readable Stream 添加了一个 <code>finish</code> 事件，写入完成时触发该事件回调。</p>
<h3 id="Stream-和-Buffer"><a href="#Stream-和-Buffer" class="headerlink" title="Stream 和 Buffer"></a>Stream 和 Buffer</h3><p><strong>两种数据类型：</strong></p>
<ul>
<li>buffer：数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入<strong>二进制数据</strong></li>
<li>stream：也就是我们上面提到的 Node 中的流，stream 对 buffer 对象的高级封装，其操作的底层还是 buffer 对象</li>
</ul>
<p><strong>处理数据的两种模式：</strong></p>
<ul>
<li>Buffer 模式：就是取完整数据一次性操作</li>
<li>Stream 模式：就是边读取数据边操作</li>
</ul>
<p>例如打开一个 2G 的文件, 用 Buffer 模式就是先分配 2G 的内存, 把文件全部读出来, 然后开始操作内存；而用 Stream 模式的方法就是边读数据边处理。可见，Steam 模式无论在空间上还是时间上都优于 Buffer 模式。</p>
<h2 id="vinyl"><a href="#vinyl" class="headerlink" title="vinyl"></a>vinyl</h2><p><a href="https://github.com/gulpjs/vinyl" target="_blank" rel="external">vinyl</a> 是一种虚拟文件格式（Virtual file format），也是一种 JavaScript 对象，称之为：<strong>Vinyl File Object</strong>，如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Vinyl = require(<span class="string">'vinyl'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> jsFile = <span class="keyword">new</span> Vinyl(&#123;</div><div class="line">  cwd: <span class="string">'/'</span>,</div><div class="line">  <span class="keyword">base</span>: <span class="string">'/test/'</span>,</div><div class="line">  path: <span class="string">'/test/file.js'</span>,</div><div class="line">  contents: <span class="keyword">new</span> Buffer(<span class="string">'var x = 123'</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们知道 Gulp 是基于流的自动化构建工具，但是这个流并非 Node 中的 Stream，而是 <strong>Vinyl File Object Stream</strong>，但其中用到了 Node 中的 Stream。那 Gulp 为什么不直接使用 Node 中的 Stream 呢？看如下例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">"copy"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">"./stylesheets/src/**/*.css"</span>)</div><div class="line">    .pipe(gulp.dest(<span class="string">"./stylesheets/dest"</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码将 <code>src</code> 目录下的 css 文件全部拷贝到 <code>dest</code> 目录，拷贝过程中保留了目录结构，文件名等等。 Node 中的 Stream 只传输 String 类型（Buffer经过 <code>utf8</code> 编码），Buffer 类型（二进制）和 Null（空），也即只关注了文件的内容；但是 Gulp 中不只关注文件内容，还用到这个文件相关的路径信息，而这是 Node 中的 Stream 无法支持的。留意上面 vinyl 对象代码，我们会发现包含了 <code>contents</code> 和 <code>path</code> 属性，所以 Gulp 中用到 Vinyl File Object，其使用的流就是 Vinyl File Object Stream。</p>
<h3 id="vinyl-fs"><a href="#vinyl-fs" class="headerlink" title="vinyl-fs"></a>vinyl-fs</h3><p><a href="https://github.com/gulpjs/vinyl-fs" target="_blank" rel="external">vinyl-fs</a> 是 vinyl 文件对象的适配器(Vinyl adapter for the file system)。Gulp 中并没有直接使用 vinyl 文件对象，而是通过 vinyl-fs 提供的方法进行操作，在 <a href="https://github.com/gulpjs/gulp/blob/master/index.js" target="_blank" rel="external">Gulp 源码</a> 中发现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vfs = <span class="built_in">require</span>(<span class="string">'vinyl-fs'</span>);</div><div class="line"></div><div class="line">Gulp.prototype.src = vfs.src;</div><div class="line">Gulp.prototype.dest = vfs.dest;</div></pre></td></tr></table></figure></p>
<h3 id="vinyl-内容类型"><a href="#vinyl-内容类型" class="headerlink" title="vinyl 内容类型"></a>vinyl 内容类型</h3><p>Vinyl File Object 的 <code>contents</code> 属性有三种类型：</p>
<ul>
<li>stream</li>
<li>buffer(二进制)</li>
<li>null</li>
</ul>
<p>Gulp 插件中操作的虽然都是 Vinyl File Object，但是对 <code>contents</code> 类型可能会有不同的要求。在使用 Gulp 过程中可能会遇到这样的插件报错：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">internal/streams/legacy.<span class="symbol">js:</span><span class="number">59</span></div><div class="line">      throw er; <span class="regexp">//</span> Unhandled stream error in pipe.</div><div class="line">      ^</div><div class="line"><span class="symbol">GulpUglifyError:</span> Streaming not supported</div><div class="line">    at createError (<span class="regexp">/Users/</span>YingshanDeng/Documents/GitHub/SharedPen/node_modules/gulp-uglify/<span class="class"><span class="keyword">lib</span>/<span class="title">create</span>-<span class="title">error</span>.<span class="title">js</span>:6:14)</span></div><div class="line">    at apply (<span class="regexp">/Users/</span>YingshanDeng/Documents/GitHub/SharedPen/node_modules/lodash/_apply.<span class="symbol">js:</span><span class="number">16</span>:<span class="number">25</span>)</div><div class="line">    at wrapper (<span class="regexp">/Users/</span>YingshanDeng/Documents/GitHub/SharedPen/node_modules/lodash/_createCurry.<span class="symbol">js:</span><span class="number">41</span>:<span class="number">12</span>)</div><div class="line">    at /Users/YingshanDeng/Documents/GitHub/SharedPen/node_modules/gulp-uglify/<span class="class"><span class="keyword">lib</span>/<span class="title">minify</span>.<span class="title">js</span>:32:15</span></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>前面介绍了 Stream 和 Buffer 的区别，我们知道：Buffer 就是一次性获取完整的文件数据，而 Stream 是将文件切分成小块，一块一块获取；那么对于不同的插件可能有不同的要求。例如上面报错的就是 gulp-uglify 插件，提示不支持 Stream，需要 Buffer 类型的 Vinyl File Object。</p>
<p><code>gulp.src(globs[, options])</code> 方法默认会返回 buffer 类型的 Vinyl File Object。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">options.<span class="keyword">buffer</span></div><div class="line">  <span class="keyword">Type</span>: <span class="built_in">Boolean</span> <span class="keyword">Default</span>: <span class="literal">true</span></div><div class="line"></div><div class="line">  Setting this <span class="keyword">to</span> <span class="literal">false</span> will <span class="keyword">return</span> <span class="keyword">file</span>.contents as a stream <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">buffer</span> files.</div><div class="line">  This <span class="keyword">is</span> useful <span class="keyword">when</span> working <span class="keyword">with</span> large files.</div><div class="line">  <span class="literal">Note</span>: Plugins might <span class="keyword">not</span> implement support <span class="keyword">for</span> streams.</div></pre></td></tr></table></figure></p>
<p>想要 Steam 类型可通过设置 <code>options.buffer</code> 为 <code>false</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gulp</span><span class="selector-class">.src</span>("*<span class="selector-class">.js</span>", &#123;<span class="attribute">buffer</span>: false&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在编写插件过程通过会遇到 Node Stream 和 Vinyl File Object Stream 之间的转换，下面介绍几种情况：</p>
<ul>
<li>将 Node Stream 转换成 Vinyl File Object Stream<ul>
<li>转换成 <code>contents</code> 类型是 stream 的 Vinyl File Object Stream<br>使用 <a href="https://www.npmjs.com/package/vinyl-source-stream" target="_blank" rel="external">vinyl-source-stream</a> 插件</li>
<li>转换成 <code>contents</code> 类型是 buffer 的 Vinyl File Object Stream<br>使用 <a href="https://www.npmjs.com/package/vinyl-source-buffer" target="_blank" rel="external">vinyl-source-buffer</a> 插件</li>
</ul>
</li>
<li>将 stream 类型的 Vinyl File Object Stream 转换成 buffer 类型的 Vinyl File Object Stream<br>使用 <a href="https://www.npmjs.com/package/vinyl-buffer" target="_blank" rel="external">vinyl-buffer</a> 插件</li>
</ul>
<p>下面通过一个经典的例子来介绍一下这些插件的使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>)</div><div class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>)</div><div class="line"><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'vinyl-buffer'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'bundle'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> browserify(bundle.entry, &#123; <span class="attr">standalone</span>: bundle.standalone &#125;)</div><div class="line">    .transform(babelify, &#123;</div><div class="line">      <span class="attr">presets</span>: [<span class="string">'es2015'</span>]</div><div class="line">    &#125;)</div><div class="line">    .bundle() <span class="comment">// ①</span></div><div class="line">    .pipe(source(<span class="string">'filename.js'</span>)) <span class="comment">// ②</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>))</div><div class="line">    .pipe(buffer()) <span class="comment">// ③</span></div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(rename(&#123;</div><div class="line">      <span class="attr">extname</span>: <span class="string">'.min.js'</span></div><div class="line">    &#125;))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>① <a href="http://browserify.org/" target="_blank" rel="external">browserify</a> 模块打包工具的 bundle 方法将打包好的文件生成 Node Stream 中的 Readable Stream<br>② vinyl-source-stream 插件将 Node Stream 转换成 Vinyl File Object Stream，这样才能在 Gulp 中使用（注意：需要传入一个文件名）<br>③ 将 stream 类型的 Vinyl File Object Stream 转换成 buffer 类型的 Vinyl File Object Stream，满足 gulp-uglify 插件的使用要求</p>
<h2 id="编写-Gulp-插件"><a href="#编写-Gulp-插件" class="headerlink" title="编写 Gulp 插件"></a>编写 Gulp 插件</h2><blockquote>
<p><a href="https://www.gulpjs.com.cn/docs/writing-a-plugin/" target="_blank" rel="external">官方编写插件文档</a></p>
</blockquote>
<p>简单的理解，Gulp 插件就是通过接收 Vinyl File Object，然后进行插件逻辑处理，最后返回 Vinyl File Object。这个过程也就是对流进行转换(transform stream)，通常我们会使用到 <a href="https://github.com/rvagg/through2" target="_blank" rel="external">through2</a>。下面通过一个例子了解一下如何编写一个 Gulp 插件：</p>
<p><code>index.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> through2 = <span class="built_in">require</span>(<span class="string">'through2'</span>);</div><div class="line"><span class="keyword">const</span> PLUGIN_NAME = <span class="string">'gulp-demo'</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (chunk.isNull()) &#123;</div><div class="line">      callback(<span class="literal">null</span>, chunk)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (chunk.isStream()) &#123;</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;PLUGIN_NAME&#125;</span>: Streaming not supported`</span>))</div><div class="line">      callback()</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (chunk.isBuffer()) &#123;</div><div class="line">      <span class="comment">// 向文件内容追加 'demo'</span></div><div class="line">      chunk.contents = <span class="keyword">new</span> Buffer(chunk.contents.toString() + <span class="string">'demo'</span>)</div><div class="line">      <span class="keyword">this</span>.push(chunk)</div><div class="line">      cb()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>gulpfile.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> demoPlugin = <span class="built_in">require</span>(<span class="string">'./index.js'</span>)</div><div class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>)</div><div class="line"><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'vinyl-buffer'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'demo'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> fs.createReadStream(<span class="string">'./test/src/text.txt'</span>)</div><div class="line">    .pipe(source(<span class="string">'text.txt'</span>))</div><div class="line">    .pipe(buffer())</div><div class="line">    .pipe(demoPlugin())</div><div class="line">    .pipe(gulp.dest(<span class="string">'./test/dest'</span>))</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="comment">// gulp.task('demo', () =&gt; &#123;</span></div><div class="line"><span class="comment">//   return gulp.src('./test/src/text.txt')</span></div><div class="line"><span class="comment">//     .pipe(demoPlugin())</span></div><div class="line"><span class="comment">//     .pipe(gulp.dest('./test/dest'))</span></div><div class="line"><span class="comment">// &#125;)</span></div></pre></td></tr></table></figure></p>
<h2 id="Gulp-和-Grunt-的比较"><a href="#Gulp-和-Grunt-的比较" class="headerlink" title="Gulp 和 Grunt 的比较"></a>Gulp 和 Grunt 的比较</h2><p>Gulp 基于流； 而 Grunt 基于文件的机制，导致了任务之间没有信息传递。<br>Grunt 任务流程基本上打开文件、处理文件、保存文件、关闭文件，然后执行继续向后执行任务。每一个任务都需要做重复的打开、保存、关闭操作无疑影响效率。Gulp 的特点在于单入口模式，文件打开、保存、关闭均一次，都是在内存中获取数据，操作数据，这样肯定比 Gulp 快。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.gulpjs.com.cn/" target="_blank" rel="external">Gulp 中文网</a><br><a href="https://segmentfault.com/a/1190000003770541" target="_blank" rel="external">探究 Gulp</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/gulpjs-cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Gulp 是三个自动化构建工具（Grunt, Gulp, Webpack）之一，其通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理，仅提供几个 API 就能将构建任务很好完成，而且有着丰富的插件生态，本文将探究 Gulp 的原理及如何创建插件。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Gulp" scheme="http://objcer.com/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>检测鼠标指针移动离开页面</title>
    <link href="http://objcer.com/2018/02/26/Detect-the-mouse-leave-the-window/"/>
    <id>http://objcer.com/2018/02/26/Detect-the-mouse-leave-the-window/</id>
    <published>2018-02-26T15:21:40.000Z</published>
    <updated>2018-03-05T15:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/banner-purple.jpg" alt=""><br>本文将介绍一种方法用于检测鼠标指针在页面中移动时，判断是否离开页面 👉</p>
<a id="more"></a>
<h2 id="relatedTarget"><a href="#relatedTarget" class="headerlink" title="relatedTarget"></a><code>relatedTarget</code></h2><p>W3C在 <code>mouseover</code> 和 <code>mouseout</code> 事件中添加了 <code>relatedTarget</code> 属性。<code>relatedTarget</code> 属性返回与事件的目标节点相关的节点元素。</p>
<ul>
<li>对于 <code>mouseover</code> 事件来说，该属性表示来自哪个元素</li>
<li>对于 <code>mouseout</code> 事件来说，该属性表示去往的那个元素</li>
</ul>
<p>对于其他类型的事件来说，这个属性没有用。<br>而Microsoft添加了两个属性：</p>
<ul>
<li><code>fromElement</code> 在 <code>mouseover</code> 事件中表示鼠标来自哪个元素</li>
<li><code>toElement</code> 在 <code>mouseout</code> 事件中指向鼠标去往的那个元素</li>
</ul>
<p>跨浏览器脚本：</p>
<ul>
<li><p>如果你想知道鼠标来自哪个元素(<code>mouseover</code> 事件)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!e) <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</div><div class="line">  <span class="keyword">var</span> relTarg = e.relatedTarget || e.fromElement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果你想知道鼠标去往哪个元素在(<code>mouseout</code> 事件)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!e) <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</div><div class="line">  <span class="keyword">var</span> relTarg = e.relatedTarget || e.toElement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mouseover-mouseout-mouseenter-mouseleave"><a href="#mouseover-mouseout-mouseenter-mouseleave" class="headerlink" title="mouseover, mouseout, mouseenter, mouseleave"></a><code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code>, <code>mouseleave</code></h2><p>关于鼠标移动，有两组容易混淆的事件：</p>
<ul>
<li><code>mouseover</code>, <code>mouseout</code>: <strong>事件会冒泡</strong></li>
<li><code>mouseenter</code>, <code>mouseleave</code>: 不会冒泡</li>
</ul>
<p>如下例子：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/E26BF2A3-9639-4EC5-B23F-7F3D8FB3BB31.png" alt=""></p>
<ul>
<li>当鼠标移动进入 outer 元素，会触发 outer 元素的 <code>mouseover</code>, <code>mouseenter</code> 事件；</li>
<li>当鼠标从 outer 元素移动进入 inner 元素，会触发 inner 元素的 <code>mouseover</code>, <code>mouseenter</code> 事件；<strong>同时会触发 outer 元素的 <code>mouseover</code> 事件</strong></li>
</ul>
<h2 id="检测光标移动离开页面"><a href="#检测光标移动离开页面" class="headerlink" title="检测光标移动离开页面"></a>检测光标移动离开页面</h2><p>通过 <code>mouseout</code> 鼠标事件，判断鼠标去往哪个元素<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseout'</span>, (evt) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (!evt) <span class="keyword">var</span> evt = <span class="built_in">window</span>.event</div><div class="line">  <span class="keyword">var</span> <span class="keyword">to</span> = evt.relatedTarget || evt.toElement</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">to</span> || <span class="keyword">to</span>.nodeName == <span class="string">"HTML"</span>) &#123;</div><div class="line">    alert(<span class="string">"left window"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>检测鼠标指针移动离开页面的应用的例子：拖拽一个DIV节点，在鼠标移动离开页面后，应该停止拖拽<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖拽实现<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-class">.block</span> &#123;</div><div class="line">      <span class="attribute">position</span>: absolute;</div><div class="line">      <span class="attribute">left</span>: <span class="number">100px</span>;</div><div class="line">      <span class="attribute">top</span>: <span class="number">100px</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">      <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">40px</span>;</div><div class="line">      <span class="attribute">background</span>: red;</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> blcokEle = <span class="built_in">document</span>.querySelector(<span class="string">".block"</span>)</div><div class="line">    <span class="keyword">var</span> blockCurrPos = &#123;<span class="attr">x</span>: <span class="number">-1</span>, <span class="attr">y</span>: <span class="number">-1</span>&#125; <span class="comment">// block element current position</span></div><div class="line">    <span class="keyword">var</span> mouseStartPos = &#123;<span class="attr">x</span>: <span class="number">-1</span>, <span class="attr">y</span>: <span class="number">-1</span>&#125; <span class="comment">// mouse start position</span></div><div class="line">    <span class="keyword">var</span> canDrag = <span class="literal">false</span></div><div class="line">    blcokEle.addEventListener(<span class="string">'mousedown'</span>, (evt) =&gt; &#123;</div><div class="line">      canDrag = <span class="literal">true</span></div><div class="line">      <span class="keyword">let</span> rect = blcokEle.getBoundingClientRect()</div><div class="line">      <span class="built_in">Object</span>.assign(blockCurrPos, &#123;<span class="attr">x</span>: rect.left, <span class="attr">y</span>: rect.top&#125;)</div><div class="line">    &#125;)</div><div class="line">    blcokEle.addEventListener(<span class="string">'mouseup'</span>, (evt) =&gt; &#123;</div><div class="line">      canDrag = <span class="literal">false</span></div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'mousedown'</span>, (evt) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!canDrag) &#123; <span class="keyword">return</span> &#125;</div><div class="line">      <span class="built_in">Object</span>.assign(mouseStartPos, &#123;<span class="attr">x</span>: evt.clientX, <span class="attr">y</span>: evt.clientY&#125;)</div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'mousemove'</span>, (evt) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!canDrag) &#123; <span class="keyword">return</span> &#125;</div><div class="line">      <span class="keyword">var</span> deltaX = evt.clientX - mouseStartPos.x</div><div class="line">      <span class="keyword">var</span> deltaY = evt.clientY - mouseStartPos.y</div><div class="line"></div><div class="line">      blockCurrPos.x += deltaX</div><div class="line">      blockCurrPos.y += deltaY</div><div class="line"></div><div class="line">      mouseStartPos = &#123;</div><div class="line">        <span class="attr">x</span>: evt.clientX,</div><div class="line">        <span class="attr">y</span>: evt.clientY</div><div class="line">      &#125;</div><div class="line">      blcokEle.style[<span class="string">'left'</span>] = <span class="string">`<span class="subst">$&#123;blockCurrPos.x&#125;</span>px`</span></div><div class="line">      blcokEle.style[<span class="string">'top'</span>] = <span class="string">`<span class="subst">$&#123;blockCurrPos.y&#125;</span>px`</span></div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseout'</span>, (evt) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (!canDrag) &#123; <span class="keyword">return</span> &#125;</div><div class="line">      <span class="keyword">var</span> to = evt.relatedTarget || evt.toElement;</div><div class="line">      <span class="keyword">if</span> (!to || to.nodeName == <span class="string">"HTML"</span>) &#123;</div><div class="line">          <span class="comment">// stop your drag event here</span></div><div class="line">          canDrag = <span class="literal">false</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/923299/how-can-i-detect-when-the-mouse-leaves-the-window/26332723" target="_blank" rel="external">How can I detect when the mouse leaves the window?
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/banner-purple.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文将介绍一种方法用于检测鼠标指针在页面中移动时，判断是否离开页面 👉&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="relatedTarget" scheme="http://objcer.com/tags/relatedTarget/"/>
    
  </entry>
  
  <entry>
    <title>学习正则表达式</title>
    <link href="http://objcer.com/2018/01/22/learn-regexp/"/>
    <id>http://objcer.com/2018/01/22/learn-regexp/</id>
    <published>2018-01-22T13:26:08.000Z</published>
    <updated>2018-01-22T13:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/regex.jpg" alt=""><br>对正则表达式，我们并不陌生。在很多地方都会用到，尤其是字符串处理，正则表达式更是一把利器。本文通过一个例子来学习总结一下正则表达式的一些知识内容 🤓</p>
<a id="more"></a>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p><code>index.html</code> 页面中，有如下一段代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"#000000"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>React SharedPen App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./pace/pace.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./pace/pace-theme-minimal.css"</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- SharedPen scripts --&gt;</span></div><div class="line">  <span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:5000/Utils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:5000/SharedPen.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- SharedPen stylesheet --&gt;</span></div><div class="line">  <span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://localhost:5000/SharedPen.css"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- end --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>注意这两段注释标签<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure></p>
<p>在页面在开发环境中，加载的是本地源文件，在生产环境中，我希望将其替换成压缩文件：<code>./dist/sharedpen.min.js</code> 和 <code>./dist/SharedPen.css</code>。</p>
<p><strong>解决思路是：</strong>使用 webpack 插件 <a href="https://www.npmjs.com/package/html-replace-webpack-plugin" target="_blank" rel="external">html-replace-webpack-plugin</a> 配置正则表达式，然后进行替换。最终的代码如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const HtmlReplaceWebpackPlugin = require('html-replace-webpack-plugin')</div><div class="line">const tpl = &#123;</div><div class="line">  css: '<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>',</div><div class="line">  js: '<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"%s"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>'</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // Definition for Webpack plugins</div><div class="line">  plugin: [</div><div class="line">    // Replace html contents with string or regex patterns</div><div class="line">    new HtmlReplaceWebpackPlugin([&#123;</div><div class="line">      pattern: /(<span class="comment">&lt;!--\s*)(css|js):([\w-\/\.]+)(\s*--&gt;</span>)([\s\S]*?)(<span class="comment">&lt;!--\s*end\s*--&gt;</span>)/,</div><div class="line">      replacement: function (match, $1, type, file) &#123;</div><div class="line">        switch (type) &#123;</div><div class="line">          case 'css':</div><div class="line">          case 'js':</div><div class="line">            return tpl[type].replace('%s', file)</div><div class="line">          default:</div><div class="line">            return ''</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;])</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中关键就是写出正则表达式，匹配出那两段注释代码。正则语法可以参考文末附录二，为了方便测试，我们可以在 <a href="https://regex101.com/" target="_blank" rel="external">https://regex101.com/</a> 这个网站上编写正则表达式。</p>
<h2 id="撰写正则表达式"><a href="#撰写正则表达式" class="headerlink" title="撰写正则表达式"></a>撰写正则表达式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure>
<h3 id="分成三部分处理"><a href="#分成三部分处理" class="headerlink" title="分成三部分处理"></a>分成三部分处理</h3><p>观察这两段注释，每一段可以分成三部分，根据正则语法，可以写出如下三部分的正则表达式：</p>
<ul>
<li><p>起始部分 匹配 <code>&lt;!-- js:./dist/sharedpen.min.js --&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):[\w\-\/\.]+\s*--&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>中间内容部分</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">\s</span><span class="symbol">\S</span>]*</div></pre></td></tr></table></figure>
</li>
<li><p>结束部分 匹配 <code>&lt;!-- end --&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*end\s*--&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>在第一部分 <code>&lt;!-- js:./dist/sharedpen.min.js --&gt;</code>，我们还需要正则表达式能匹配出：文件类型和文件路径</p>
<blockquote>
<p>注意到<br>1、<code>(pattern)</code> <strong>匹配 pattern 并捕获该匹配的子表达式。可以使用 $1…$9 属性从结果“匹配”集合中检索捕获的匹配。</strong><br>2、在 JavaScript 中 <code>$1…$9</code> 属性是包含括号子串匹配的正则表达式的静态只读属性，我们可以通过 <code>RegExp.$1, ..., RegExp.$9</code> 来使用它们</p>
</blockquote>
<p>通过括号写出子表达式，匹配出我们需要的内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regexp = new RegExp(/<span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>/)</div><div class="line">var str = '<span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span>'</div><div class="line">regexp.exec(str)</div><div class="line">console.log(RegExp.$1) // "js"</div><div class="line">console.log(RegExp.$2) // "./dist/sharedpen.min.js"</div></pre></td></tr></table></figure>
<h3 id="最长匹配（贪婪匹配）和最短匹配（懒惰匹配）"><a href="#最长匹配（贪婪匹配）和最短匹配（懒惰匹配）" class="headerlink" title="最长匹配（贪婪匹配）和最短匹配（懒惰匹配）"></a>最长匹配（贪婪匹配）和最短匹配（懒惰匹配）</h3><p>到目前为止，我们的正则表达式为：<code>&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;[\s\S]*&lt;!--\s*end\s*--&gt;</code>，但是会发现，此时匹配有点问题：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/51E1FD12-5B3D-4600-8EEE-C00AE4485F46.png" alt=""></p>
<p>我们是希望遇到第一个 <code>&lt;!-- end --&gt;</code> 就结束匹配，而现在却是匹配到最后一个。这个时候就需要了解正则表达式的最长匹配（贪婪匹配）和最短匹配（懒惰匹配）<br>例子一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> regexp1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>) <span class="comment">// 最长匹配</span></div><div class="line"><span class="keyword">var</span> regexp2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*?/</span>) <span class="comment">// 最短匹配</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp1.exec(str)[<span class="number">0</span>]) <span class="comment">// "abc123"</span></div><div class="line"><span class="built_in">console</span>.log(regexp2.exec(str)[<span class="number">0</span>]) <span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p>
<p>例子二：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = '<span class="comment">/*** 注释1 ****/</span> <span class="keyword">var</span> name = <span class="string">"aty"</span>; <span class="comment">/***注释2****/</span>'</div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="type">RegExp</span>(/\/\*([\s\<span class="type">S</span>]*?)\*\<span class="comment">//)</span></div><div class="line"></div><div class="line">console.log(regexp.exec(str)[<span class="number">0</span>]) <span class="comment">// 使用 `*?` 就可以正确的匹配到注释内容</span></div></pre></td></tr></table></figure></p>
<p>我们会发现，最长和最短匹配的差别是，前者匹配尽可能多的字符，后者匹配尽可能少的字符。一般正则表达式引擎默认都是最长匹配，<strong>如果想要最短匹配，那么需要在数量修饰符(例如：<code>*</code>，<code>+</code>)后面添加一个 <code>?</code> 变成最短匹配</strong></p>
<p>所以此时执行对我们的正则表达式增加一个 <code>?</code> 即可<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>[\s\S]*?<span class="comment">&lt;!--\s*end\s*--&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>JavaScript 中使用正则表达式有两种方式：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 直接量语法</span></div><div class="line">/pattern/attributes</div><div class="line"></div><div class="line"><span class="meta"># 创建 RegExp 对象的语法</span></div><div class="line"><span class="keyword">new</span> RegExp(pattern, attributes);</div></pre></td></tr></table></figure></p>
<p><strong>参数:</strong></p>
<ul>
<li>pattern 是一个字符串，指定了正则表达式</li>
<li>attributes 是一个可选的字符串，包含属性: <strong>“g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配</strong>。</li>
</ul>
<p>其中 <code>g</code> 指定正则表达式全局匹配，那么有什么特殊之处呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>, <span class="string">'g'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>其中第二次 console 输出为啥是 <code>false</code> 呢？</p>
<ul>
<li>在全局匹配模式下可以对指定要查找的字符串<strong>执行多次匹配</strong>。</li>
<li>每次匹配使用当前正则对象的 <code>lastIndex</code> 属性的值作为在目标字符串中开始查找的起始位置。</li>
<li><code>lastIndex</code> 属性的初始值为 0，找到匹配的项后，<code>lastIndex</code> 的值被重置为匹配内容的下一个字符在字符串中的位置索引，用来标识下次执行匹配时开始查找的位置。</li>
<li>如果找不到匹配的项，<code>lastIndex</code> 的值会被设置为 0。</li>
<li>没有设置正则对象的全局匹配标志时 <code>lastIndex</code> 属性的值始终为0，每次执行匹配仅查找字符串中第一个匹配的项。</li>
</ul>
<p>如果我们每次执行 <code>regexp.test(str)</code> 方法后，查看一下正则对象的 lastIndex 属性的值，就清楚了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'abc123def'</span></div><div class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc[\d]*/</span>, <span class="string">'g'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(regexp.lastIndex) <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>第一次执行 <code>regexp.test(str)</code> 前，正则对象的 <code>lastIndex</code> 属性值为 0，匹配到字符 <code>abc123</code> 后，正则对象的 <code>lastIndex</code> 属性值变成 6；<br>在第二次执行 <code>regexp.test(str)</code> 时，从第 7 个字符(从0开始)开始进行匹配，当然就匹配失败啦。</p>
<p>下面再来看看正则对象的另一个方法 <code>exec</code> 在全局模式下的例子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var str = `</div><div class="line"><span class="comment">&lt;!-- js:./dist/sharedpen.min.js --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span>`</div><div class="line"></div><div class="line">var regexp = new RegExp(/<span class="comment">&lt;!--\s*(css|js):([\w\-\/\.]+)\s*--&gt;</span>[\s\S]*?<span class="comment">&lt;!--\s*end\s*--&gt;</span>/g)</div><div class="line">var matches</div><div class="line">while((matches = regexp.exec(str)) != null) &#123;</div><div class="line">  str = str.replace(matches[0], '<span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span>')</div><div class="line">&#125;</div><div class="line">console.log(str)</div></pre></td></tr></table></figure></p>
<p>我们希望代码执行匹配替换后，输出结果是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span>&gt;<span class="keyword">test</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;<span class="keyword">div</span>&gt;<span class="keyword">test</span>&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>但是实际上输出结果是：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- css:./dist/SharedPen.css --&gt;</span></div><div class="line">...</div><div class="line"><span class="comment">&lt;!-- end --&gt;</span></div></pre></td></tr></table></figure></p>
<p>显然是第二次匹配替换出问题了。有了前面的经验，我们很快就知道，是全局模式匹配的问题，第一次全局匹配后，正则对象的 <code>lastIndex</code> 属性值发生变化，影响了第二次正则匹配，我们只需去掉全局匹配 <code>g</code> 即可解决问题。</p>
<p>🏗 至此，我们终于可以得到如下的正则表达式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(<span class="comment">&lt;!--\s*)(css|js):([\w-\/\.]+)(\s*--&gt;</span>)([\s\S]*?)(<span class="comment">&lt;!--\s*end\s*--&gt;</span>)/</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="附录一-常用方法"><a href="#附录一-常用方法" class="headerlink" title="[附录一] 常用方法"></a>[附录一] 常用方法</h2><p>RegExp 对象方法：<code>test</code>, <code>exec</code></p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RegExpObj.test(string)</code></td>
<td>用于检测一个字符串是否匹配某个模式</td>
<td>匹配返回 true，否则返回 false</td>
</tr>
<tr>
<td><code>RegExpObj.exec(string)</code></td>
<td>用于检索字符串中的正则表达式的匹配</td>
<td>返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</td>
</tr>
</tbody>
</table>
<p>String 对象方法：<code>match</code>, <code>replace</code></p>
<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stringObj.match( regexp/substr )</code></td>
<td>在字符串内检索指定的值，或找到一个或多个正则表达式的匹配</td>
<td>返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</td>
</tr>
<tr>
<td><code>stringObj.replace( regexp/substr, replacement )</code></td>
<td>根据 regexp/substr 进行正则匹配,把匹配结果替换为 replacement</td>
<td>一个新的字符串</td>
</tr>
</tbody>
</table>
<h2 id="附录二-正则表达式语法"><a href="#附录二-正则表达式语法" class="headerlink" title="[附录二] 正则表达式语法"></a>[附录二] 正则表达式语法</h2><p>学习正则表达式，首先要了解其语法规则，以下规则来自：<strong>MSDN 正则表达式语法:</strong> <a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90).aspx</a></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。</strong>例如，“n” 匹配字符 “n”。“\n” 匹配换行符。序列 “\” 匹配 “\”，“(” 匹配 “(”。</td>
</tr>
<tr>
<td><code>^</code></td>
<td><strong>匹配输入字符串开始的位置。</strong>如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 “\n” 或 “\r” 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td><strong>匹配输入字符串结尾的位置。</strong>如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 “\n” 或 “\r” 之前的位置匹配。</td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>零次或多次匹配前面的字符或子表达式。</strong>例如，zo<em> 匹配 “z” 和 “zoo”。</em> 等效于 {0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td><strong>一次或多次匹配前面的字符或子表达式。</strong>例如，“zo+” 与 “zo” 和 “zoo” 匹配，但与 “z” 不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>零次或一次匹配前面的字符或子表达式。</strong>例如，“do(es)?” 匹配 “do” 或 “does” 中的 “do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td><strong>n 是非负整数。正好匹配 n 次。</strong>例如，“o{2}” 与 “Bob” 中的 “o” 不匹配，但与 “food” 中的两个“o”匹配。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td><strong>n 是非负整数。至少匹配 n 次。</strong>例如，“o{2,}” 不匹配 “Bob” 中的 “o”，而匹配 “foooood” 中的所有 o。“o{1,}” 等效于 “o+”。“o{0,}” 等效于 “o*”。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 是非负整数，其中 n &lt;= m。<strong>匹配至少 n 次，至多 m 次。</strong>例如，“o{1,3}” 匹配 “fooooood” 中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。</strong>例如，在字符串 “oooo” 中，“o+?” 只匹配单个 “o”，而 “o+” 匹配所有 “o”。</td>
</tr>
<tr>
<td><code>.</code></td>
<td><strong>匹配除“\n”之外的任何单个字符。</strong>若要匹配包括 “\n” 在内的任意字符，请使用诸如 “[\s\S]” 之类的模式。</td>
</tr>
<tr>
<td><code>(pattern)</code></td>
<td><strong>匹配 pattern 并捕获该匹配的子表达式。可以使用 $1…$9 属性从结果“匹配”集合中检索捕获的匹配。</strong>若要匹配括号字符 ( )，请使用“(”或者“)”。</td>
</tr>
<tr>
<td><code>(?:pattern)</code></td>
<td>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用 “or” 字符 <code>(│)</code> 组合模式部件的情况很有用。例如，<code>industr(?:y│ies)</code> 是比 <code>industry│industries</code> 更经济的表达式。</td>
</tr>
<tr>
<td><code>(?=pattern)</code></td>
<td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95│98│NT│2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td><code>(?!pattern)</code></td>
<td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95│98│NT│2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td><code>x│y</code></td>
<td><strong>匹配 x 或 y。</strong>例如，’z│food’ 匹配“z”或“food”。’(z│f)ood’ 匹配“zood”或“food”。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td>字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td><strong>字符范围。</strong>匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</td>
</tr>
<tr>
<td><code>[^a-z]</code></td>
<td><strong>反向范围字符。</strong>匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</td>
</tr>
<tr>
<td><code>\cx</code></td>
<td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td><strong>数字字符匹配。</strong>等效于 [0-9]。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td><strong>非数字字符匹配。</strong>等效于 [^0-9]。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td><strong>匹配任何空白字符，包括空格、制表符、换页符等。</strong>与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td><strong>匹配任何非空白字符。</strong>与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td><code>\xn</code></td>
<td>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td><code>\num</code></td>
<td>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td>
</tr>
<tr>
<td><code>\nm</code></td>
<td>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td><code>\nml</code></td>
<td>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td>
</tr>
<tr>
<td><code>\un</code></td>
<td>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody>
</table>
<p>正则表达式从左往右进行计算，运算符的优先级顺序如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>(), (?:), (?=), []</code></td>
<td>括号和中括号</td>
</tr>
<tr>
<td><code>*, +, ?, {n}, {n,}, {n,m}</code></td>
<td>限定符</td>
</tr>
<tr>
<td><code>^, $, \ 任何元字符、任何字符</code></td>
<td>定位点和序列</td>
</tr>
<tr>
<td>│</td>
<td>替换</td>
</tr>
</tbody>
</table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">JavaScript RegExp 对象</a><br><a href="https://segmentfault.com/a/1190000003497780" target="_blank" rel="external">JS 进阶 test, exec, match, replace</a><br><a href="https://regex101.com/" target="_blank" rel="external">正则匹配在线网站</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/regex.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;对正则表达式，我们并不陌生。在很多地方都会用到，尤其是字符串处理，正则表达式更是一把利器。本文通过一个例子来学习总结一下正则表达式的一些知识内容 🤓&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="正则表达式" scheme="http://objcer.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中的 UnhandledPromiseRejectionWarning 问题</title>
    <link href="http://objcer.com/2017/12/27/unhandled-promise-rejections-in-node-js/"/>
    <id>http://objcer.com/2017/12/27/unhandled-promise-rejections-in-node-js/</id>
    <published>2017-12-27T09:25:07.000Z</published>
    <updated>2017-12-27T09:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>问题引入：</em>今天在 Gulp 构建任务中出现一个 html 解析错误，但是并没有报错，也没有中断 gulp 构建任务的执行，而是出现 <code>UnhandledPromiseRejectionWarning</code> 的警告，所以会误以为构建成功，这篇文章将对此进行探究并解决该问题。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="string">node:</span><span class="number">24866</span>) <span class="string">UnhandledPromiseRejectionWarning:</span> Unhandled promise rejection (rejection <span class="string">id:</span> <span class="number">2</span>): Error <span class="keyword">in</span> plugin <span class="string">'gulp-posthtml'</span></div><div class="line"><span class="string">Message:</span></div><div class="line">  Parse <span class="string">Error:</span> &lt;img id=<span class="string">"titleIcon"</span> <span class="class"><span class="keyword">class</span>$="&#123;</span>&#123;getStypeType_(info.stype)&#125;&#125;<span class="string">" src$="</span>&#123;&#123;getTitleIcon_(<span class="keyword">in</span></div><div class="line">  ...</div><div class="line">(<span class="string">node:</span><span class="number">24866</span>) [DEP0018] <span class="string">DeprecationWarning:</span> Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="关于-Unhandled-Rejection"><a href="#关于-Unhandled-Rejection" class="headerlink" title="关于 Unhandled Rejection"></a>关于 Unhandled Rejection</h2><p>一个 Promise 是一个异步操作的状态机，其可能处于这三种状态之一</p>
<ul>
<li><code>pending</code>：异步操作还在执行中</li>
<li><code>fulfilled</code>：异步操作已经完成</li>
<li><code>rejected</code>：异步操作执行失败</li>
</ul>
<blockquote>
<p>Node.js 6.6.0 added a sporadically useful bug/feature: <strong>logging unhandled promise rejections to the console by default.</strong></p>
</blockquote>
<p>在 Node.js 6.6.0 中增加了一个特性：对 Promise 中未处理的 rejection 默认会输出 <code>UnhandledPromiseRejectionWarning</code> 提示</p>
<p>例如：<code>test.js</code> 中有如下代码：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="string">'woops'</span>), <span class="number">500</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>node test.js</code> 执行：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47122</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">1</span>): error</div><div class="line">(<span class="keyword">node</span><span class="title">:47122</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code</div></pre></td></tr></table></figure></p>
<p>另一种情况是直接在 Promise 中抛出异常：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception!'</span>); &#125;);</div></pre></td></tr></table></figure></p>
<p>执行后也会有 <code>UnhandledPromiseRejectionWarning</code> 的警告：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47657</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">1</span>): Error: exception!</div><div class="line">(<span class="keyword">node</span><span class="title">:47657</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code.</div></pre></td></tr></table></figure></p>
<p>Promise API 中有 <code>.catch()</code> 这个方法，可以用来处理捕捉 rejection 进行处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="string">'error'</span>), <span class="number">500</span>);</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'caught'</span>, error))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception!'</span>); &#125;)</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'caught'</span>, error.message))</div></pre></td></tr></table></figure></p>
<p>但是注意：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'caught'</span>, err.message); &#125;);</div></pre></td></tr></table></figure></p>
<p>这个例子中虽然用 <code>.catch()</code> 捕捉处理了 Promise 中的 rejection；但是注意在 <code>err.message</code> 中的 <code>err</code> 是未定义的，代码执行时会抛出错误，由于没有后续的处理，所以也会输出 <code>UnhandledPromiseRejectionWarning</code> 的警告</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:47918</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">2</span>): ReferenceError: err is not <span class="keyword">defined</span></div><div class="line">(<span class="keyword">node</span><span class="title">:47918</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. <span class="keyword">In</span> the future, promise rejections that are not handled will terminate the <span class="keyword">Node</span>.<span class="title">js</span> process with a non-zero exit code.</div></pre></td></tr></table></figure>
<p>所以稍不注意就会引起 Promise 中的 <strong>unhandled rejections</strong> 😨</p>
<h2 id="unhandledRejection-事件"><a href="#unhandledRejection-事件" class="headerlink" title="unhandledRejection 事件"></a><code>unhandledRejection</code> 事件</h2><p>在 node <code>process</code> 中有一个 <code>unhandledRejection</code> 事件，当没有对 Promise 的 rejection 进行处理就会抛出这个事件（这只对原生 Promise 有效）</p>
<blockquote>
<p>The <strong>unhandledrejection</strong> event is fired when a JavaScript Promise is rejected but there is no rejection handler to deal with the rejection.</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// Will print "unhandledRejection err is not defined"</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'unhandledRejection'</span>, error.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'caught'</span>, err.message); &#125;);</div></pre></td></tr></table></figure>
<p>此时执行后，就没有 <code>UnhandledPromiseRejectionWarning</code> 的警告输出了，只输出：<code>unhandledRejection err is not defined</code></p>
<p>如果我们不想监听 <code>unhandledRejection</code> 事件，也不想看到 <code>UnhandledPromiseRejectionWarning</code> 的警告输出，怎么办呢？<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">Promise</span>((<span class="literal">_</span>, reject) =&gt; reject(<span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'woops'</span>)))</div><div class="line">.<span class="keyword">catch</span>(<span class="keyword">new</span> <span class="type">Function</span>());</div></pre></td></tr></table></figure></p>
<p>我们可以在 <code>.catch()</code> 中传入一个空函数，假装对 rejection 进行了处理，这样也没有触发 <code>unhandledRejection</code> 事件</p>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>关于 Async/Await，可以参考文章：<a href="https://objcer.com/2017/10/11/Async-Await/">ES7 中的 async await</a>，在这篇文章中详细介绍了 Async/Await 并且和 Promise 进行了对比，Async/Await 在处理异步操作上的优势更明显。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// No unhandled rejection!</span></div><div class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">test();</div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// (node:54358) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 3): Error: test</span></div><div class="line"><span class="comment">// (node:54358) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span></div><div class="line"></div><div class="line">test().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error.message));</div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="comment">// test</span></div></pre></td></tr></table></figure>
<p>async 异步函数返回的是 Promise，所以执行异步函数后，统一需要用 <code>.catch()</code> 对可能出现的 rejection 进行捕捉处理，否则统一也是会出现 <code>UnhandledPromiseRejectionWarning</code> 的警告</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>最后解决一下文章开头的问题：构建任务中 html 解析错误，出现了一个 Unhandled Rejection，所以我们可以添加一个 <code>unhandledRejection</code> 事件监听，直接退出：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'unhandledRejection'</span>, error =&gt; &#123;</div><div class="line">  console.error(<span class="string">'unhandledRejection'</span>, error);</div><div class="line">  process.<span class="keyword">exit</span>(<span class="number">1</span>) <span class="regexp">//</span> To <span class="keyword">exit</span> with a <span class="string">'failure'</span> code</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://thecodebarbarian.com/unhandled-promise-rejections-in-node.js.html" target="_blank" rel="external">Unhandled Promise Rejections in Node.js</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;问题引入：&lt;/em&gt;今天在 Gulp 构建任务中出现一个 html 解析错误，但是并没有报错，也没有中断 gulp 构建任务的执行，而是出现 &lt;code&gt;UnhandledPromiseRejectionWarning&lt;/code&gt; 的警告，所以会误以为构建成功，这篇文章将对此进行探究并解决该问题。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;string&quot;&gt;node:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24866&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;UnhandledPromiseRejectionWarning:&lt;/span&gt; Unhandled promise rejection (rejection &lt;span class=&quot;string&quot;&gt;id:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;): Error &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; plugin &lt;span class=&quot;string&quot;&gt;&#39;gulp-posthtml&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;Message:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  Parse &lt;span class=&quot;string&quot;&gt;Error:&lt;/span&gt; &amp;lt;img id=&lt;span class=&quot;string&quot;&gt;&quot;titleIcon&quot;&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;$=&quot;&amp;#123;&lt;/span&gt;&amp;#123;getStypeType_(info.stype)&amp;#125;&amp;#125;&lt;span class=&quot;string&quot;&gt;&quot; src$=&quot;&lt;/span&gt;&amp;#123;&amp;#123;getTitleIcon_(&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;string&quot;&gt;node:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24866&lt;/span&gt;) [DEP0018] &lt;span class=&quot;string&quot;&gt;DeprecationWarning:&lt;/span&gt; Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Promise" scheme="http://objcer.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>探究数据绑定（2）ES6 Proxy</title>
    <link href="http://objcer.com/2017/10/31/Data-Binding-with-ES6-Proxies/"/>
    <id>http://objcer.com/2017/10/31/Data-Binding-with-ES6-Proxies/</id>
    <published>2017-10-31T07:25:45.000Z</published>
    <updated>2017-10-31T07:27:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/data-binding-with-es6-proxy.png" alt=""><br>在上一篇文章：<a href="https://objcer.com/2017/10/27/Data-binding-introduction/">探究数据绑定（1）脏检查和存取器方法</a> 中，探究了 ES5 中实现数据绑定的两种方式；而在本文中，将会探究使用 ES6 Proxy 实现数据绑定。</p>
<a id="more"></a>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>Proxy 方式实现数据绑定中涉及到 Proxy、Reflect、Set、Map 和 WeakMap，这些都是 ES6 的新特性。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 对象代理，在目标对象之前架设一层拦截，外部对目标对象的操作，都会通过这层拦截，我们可以定制拦截行为，每一个被代理的拦截行为都对应一个处理函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let p = <span class="keyword">new</span> Proxy(<span class="keyword">target</span>, <span class="keyword">handler</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> handler = &#123;</div><div class="line">  get: (target, name, recevier) =&gt; &#123;</div><div class="line">    return <span class="string">'proxy'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = new Proxy(&#123;&#125;, handler)</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.a</span> = <span class="number">1</span></div><div class="line"></div><div class="line">console.log(<span class="selector-tag">p</span><span class="selector-class">.a</span>, <span class="selector-tag">p</span>.c) <span class="comment">// -&gt; proxy proxy</span></div></pre></td></tr></table></figure>
<p>Proxy 构造函数接收两个参数：</p>
<ul>
<li>第一个参数是要代理的目标对象</li>
<li>第二个参数是配置对象，每一个被代理的操作都对应一个处理函数</li>
</ul>
<p>在这个例子中，目标对象是一个空对象，配置对象中有一个 <code>get</code> 函数，用来拦截外部对目标对象属性的访问，可以看到，<code>get</code> 函数始终返回 <code>proxy</code>。</p>
<p>Proxy 支持拦截的操作一共有13种：</p>
<ul>
<li>get(target, propKey, receiver)</li>
<li>set(target, propKey, value, receiver)</li>
<li>has(target, propKey)</li>
<li>deleteProperty(target, propKey)</li>
<li>ownKeys(target)</li>
<li>getOwnPropertyDescriptor(target, propKey)</li>
<li>defineProperty(target, propKey, propDesc)</li>
<li>preventExtensions(target)</li>
<li>getPrototypeOf(target)</li>
<li>isExtensible(target)</li>
<li>setPrototypeOf(target, proto)</li>
<li>apply(target, object, args)</li>
<li>construct(target, args)</li>
</ul>
<blockquote>
<p>👉 更详细介绍参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">MDN·Proxy</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="external">Proxy</a></p>
</blockquote>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>Reflect 对象同 Proxy 对象一样，也是 ES6 为了操作对象而提供的新特性。</p>
<p>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的静态方法（Reflect 对象没有构造函数，不能使用 new 创建实例）。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> handler = &#123;</div><div class="line">  get: (target, name, recevier) =&gt; &#123;</div><div class="line">    console.log(<span class="string">'get: '</span>, name)</div><div class="line">    Reflect.get(target, name)</div><div class="line">  &#125;,</div><div class="line">  set: (target, name, value, recevier) =&gt; &#123;</div><div class="line">    console.log(<span class="string">'set: '</span>, name)</div><div class="line">    Reflect.get(target, name, value)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = new Proxy(&#123;&#125;, handler)</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.a</span> = <span class="number">1</span></div><div class="line"></div><div class="line">console.log(<span class="selector-tag">p</span><span class="selector-class">.a</span>, <span class="selector-tag">p</span>.c)</div></pre></td></tr></table></figure></p>
<p>代码执行结果，输出：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>:  <span class="keyword">a</span></div><div class="line"><span class="built_in">get</span>:  <span class="keyword">a</span></div><div class="line"><span class="built_in">get</span>:  c</div></pre></td></tr></table></figure></p>
<p>上面代码中，Proxy 拦截目标对象的 <code>get</code> 和 <code>set</code>方法，在其中定制拦截行为，最后采用 <code>Reflect.get</code> 和 <code>Reflect.set</code> 分别完成目标对象默认的属性获取和设置行为。</p>
<blockquote>
<p>👉 更详细介绍参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="external">MDN·Reflect</a><br><a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="external">Reflect</a></p>
</blockquote>
<h3 id="Set-WeakSet-和-Map-WeakMap"><a href="#Set-WeakSet-和-Map-WeakMap" class="headerlink" title="Set/WeakSet 和 Map/WeakMap"></a>Set/WeakSet 和 Map/WeakMap</h3><p><strong>Set</strong></p>
<ul>
<li>类似 Array 数组</li>
<li>Set 允许你存储任何类型的唯一值，无论是原始值或者是对象引用</li>
<li>Set 成员的值都是唯一的，没有重复值</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li>类似 Set，也是不重复元素的集合</li>
<li>WeakSet 对象中只能存放对象值, 不能存放原始值, 而 Set 对象都可以</li>
<li>WeakSet 对象中存储的<strong>对象值都是被弱引用的</strong>, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>类似 Object 对象，保存键值对</li>
<li>Map 任何值(对象或者原始值) 都可以作为一个键(key)或一个值(value)，而 Object 对象的 key 键值只能是字符串</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li>类似 Map，也是一组键值对的集合</li>
<li>WeakMap 对象中的<strong>键是弱引用的</strong>。键必须是对象，值可以是任意值</li>
<li>由于这样的弱引用，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用，原理同 WeakSet</li>
<li>WeakMap 的 key 是非枚举的</li>
</ul>
<h2 id="Proxy-实现数据绑定"><a href="#Proxy-实现数据绑定" class="headerlink" title="Proxy 实现数据绑定"></a>Proxy 实现数据绑定</h2><p>先上完整代码 👉<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听对象集合</span></div><div class="line"><span class="keyword">var</span> observers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="comment">// 待执行监听函数集合，Set 可以避免重复</span></div><div class="line"><span class="keyword">var</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line"><span class="comment">// 当前监听函数</span></div><div class="line"><span class="keyword">var</span> currentObserver</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  observers.set(obj, <span class="keyword">new</span> <span class="built_in">Map</span>())</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123; get, set &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">  <span class="comment">// get 方法默认行为</span></div><div class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver)</div><div class="line">  <span class="comment">// 当前监听函数中，监听使用了该属性，</span></div><div class="line">  <span class="comment">// 那么把该 监听函数 存放到该属性对应的 对象属性监听函数集合 Set</span></div><div class="line">  <span class="keyword">if</span> (currentObserver) &#123;</div><div class="line">    registerObserver(target, key, currentObserver)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerObserver</span>(<span class="params">target, key, observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> observersForKey = observers.get(target).get(key)</div><div class="line">  <span class="comment">// 为每一个对象属性都创建一个 Set 集合，存放监听了该属性的监听函数</span></div><div class="line">  <span class="keyword">if</span> (!observersForKey) &#123;</div><div class="line">    observersForKey = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">    observers.get(target).set(key, observersForKey)</div><div class="line">  &#125;</div><div class="line">  observersForKey.add(observer)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> observersForKey = observers.get(target).get(key)</div><div class="line">  <span class="comment">// 修改对象属性，即对象属性值发生变更时，</span></div><div class="line">  <span class="comment">// 判断 对象属性监听函数集合 Set 是否存在，将其中的所有监听函数都添加到 待执行监听函数集合</span></div><div class="line">  <span class="keyword">if</span> (observersForKey) &#123;</div><div class="line">    observersForKey.forEach(queueObserver)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// set 方法默认行为</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  queueObserver(fn)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将监听函数添加到 待执行监听函数集合 Set 中</span></div><div class="line"><span class="comment">// 如果 待执行监听函数集合 Set 为空，那么在添加后立即执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueObserver</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (queuedObservers.size === <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 异步执行</span></div><div class="line">    <span class="built_in">Promise</span>.resolve().then(runObservers)</div><div class="line">  &#125;</div><div class="line">  queuedObservers.add(observer)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 执行 待执行监听函数集合 Set 中的监听函数</span></div><div class="line"><span class="comment">// 执行完毕后，进行清理工作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runObservers</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    queuedObservers.forEach(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">      currentObserver = observer</div><div class="line">      observer()</div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    currentObserver = <span class="literal">undefined</span></div><div class="line">    queuedObservers.clear()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对外暴露的 <code>observable(obj)</code> 和 <code>observe(fn)</code> 方法二者分别用于创建 observable 监听对象和 observer 监听回调函数。当 observable 监听对象发生属性变化时，observer 函数将自动执行。</p>
<p>测试用例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;</div><div class="line"><span class="comment">// observable object</span></div><div class="line"><span class="keyword">var</span> person = observable(obj)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`监听属性发生变化：<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// observer function</span></div><div class="line">observe(print)</div></pre></td></tr></table></figure></p>
<h3 id="分析接口方法"><a href="#分析接口方法" class="headerlink" title="分析接口方法"></a>分析接口方法</h3><p>关于 <code>observable(obj)</code> 和 <code>observe(fn)</code>：<br><strong><code>observable(obj)</code> 方法中，通过 ES6 Proxy 为目标对象 <code>obj</code> 创建代理，拦截 <code>get</code> 和 <code>set</code> 操作</strong></p>
<ul>
<li>当前监听函数：<code>currentObserver</code></li>
<li>待执行监听函数集合 Set：<code>var queuedObservers = new Set()</code></li>
<li>监听对象集合 WeakMap：<code>var observers = new WeakMap()</code> 键值为监听对象</li>
<li>对象属性监听函数集合 Set：监听了对象属性的监听函数，都保存到对象属性监听函数集合 Set 中，方便在对象属性发生变更时，执行监听函数</li>
<li>拦截方法 <code>get</code>：使用 <code>obj.property</code> 获取对象属性，即会被拦截方法 <code>get</code> 拦截<br>👉 查看 <code>get</code> 中的注释</li>
<li>拦截方法 <code>set</code>：使用 <code>obj.property = value</code> 设置对象属性，即会被拦截方法 <code>set</code> 拦截<br>👉 查看 <code>set</code> 中的注释</li>
</ul>
<p><strong><code>observe(fn)</code> 方法中，添加对象属性监听函数</strong><br>  监听函数中使用 <code>obj.property</code> 获取对象属性，即表明监听函数监听了该属性，那么就会触发拦截方法 <code>get</code> 中对监听属性的逻辑处理，为其创建对象属性监听函数集合 Set，并将当前的监听函数添加进其中</p>
<h3 id="分析测试用例"><a href="#分析测试用例" class="headerlink" title="分析测试用例"></a>分析测试用例</h3><p>下面通过流程图讲解一下测试用例的执行过程<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/es6-proxy-observables-code.png" alt=""></p>
<ul>
<li>通过 <code>observable</code> 方法创建代理对象 <code>person</code></li>
<li><code>observe</code> 方法设置监听函数，此时待执行监听函数集合 Set 为空，监听函数添加到 Set 中后执行待执行监听函数集合 Set 中的监听函数</li>
<li>在 <code>runObservers</code> 方法中当前监听函数 <code>currentObserver</code> 被设为 <code>print</code></li>
<li><code>print</code> 开始执行</li>
<li>在 <code>print</code> 内部检索到 <code>person.name</code></li>
<li>在 <code>person</code> 上触发拦截方法 <code>get</code></li>
<li><code>observers.get(person).get(&#39;name&#39;)</code> 检索到 <code>(person, name)</code> 组合的对象属性监听函数集 Set</li>
<li>当前监听函数 <code>print</code> 被添加到对象属性监听函数集 Set 中</li>
<li>对于 <code>person.age</code>，同理，执行前面在 <code>print</code> 内部检索到 <code>person.name</code> 的流程</li>
<li><code>${person.name}, ${person.age}</code> 打印出来；</li>
<li><code>print</code> 函数执行结束；</li>
<li>当前监听函数 <code>currentObserver</code> 变为 <code>undefined</code></li>
</ul>
<p>当调用 <code>person.age = 22</code> 修改对象属性时：</p>
<ul>
<li><code>person</code> 上触发拦截方法 <code>set</code></li>
<li><code>observers.get(person).get(&#39;age&#39;)</code> 检索到 <code>(person, age)</code> 组合的对象属性监听函数集 Set</li>
<li>对象属性监听函数集 Set 中的监听函数（包括 <code>print</code>）入待执行监听函数集合，准备执行</li>
<li>再次执行 <code>print</code></li>
</ul>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="动态-observable-tree"><a href="#动态-observable-tree" class="headerlink" title="动态 observable tree"></a>动态 observable tree</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'John'</span>,</div><div class="line">  age: <span class="number">20</span>,</div><div class="line">  teacher: &#123;</div><div class="line">    name: <span class="string">'Tom'</span>,</div><div class="line">    age: <span class="number">30</span></div><div class="line">&#125;&#125;</div><div class="line"><span class="comment">// observable object</span></div><div class="line"><span class="selector-tag">var</span> person = observable(obj)</div><div class="line"></div><div class="line">function print () &#123;</div><div class="line">  console.log(`监听属性发生变化：$&#123;person<span class="selector-class">.teacher</span><span class="selector-class">.name</span>&#125;, $&#123;person<span class="selector-class">.teacher</span><span class="selector-class">.age</span>&#125;`)</div><div class="line">&#125;</div><div class="line"><span class="comment">// observer function</span></div><div class="line"><span class="function"><span class="title">observe</span><span class="params">(print)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; &#123;person<span class="selector-class">.teacher</span><span class="selector-class">.name</span> = <span class="string">'Jack'</span>&#125;)</div></pre></td></tr></table></figure>
<p>到目前为止，单层对象的数据绑定监听是正常工作的。但是在这个例子中，我们监听的对象值又是对象，这个时候监听就失效了，我们需要将：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">observable</span>(&#123;<span class="attribute">data</span>: &#123;name: <span class="string">'John'</span>&#125;&#125;)</div></pre></td></tr></table></figure></p>
<p>替换成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">observable</span>(&#123;<span class="attribute">data</span>: <span class="built_in">observable</span>(&#123;name: <span class="string">'John'</span>&#125;)&#125;)</div></pre></td></tr></table></figure></p>
<p>这样就能正常运行了 😋</p>
<p>显然，这样使用不方便，可以做拦截方法 <code>get</code> 中修改一下，在返回值是对象时，对返回值对象也调用 <code>observable(obj)</code> 为其创建监听对象。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function <span class="built_in">get</span>(target, <span class="built_in">key</span>, receiver) &#123;</div><div class="line">  <span class="keyword">const</span> result = Reflect.<span class="built_in">get</span>(target, <span class="built_in">key</span>, receiver)</div><div class="line">  <span class="keyword">if</span> (currentObserver) &#123;</div><div class="line">    registerObserver(target, <span class="built_in">key</span>, currentObserver)</div><div class="line">    <span class="keyword">if</span> (typeof result === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">const</span> observableResult = observable(result)</div><div class="line">      Reflect.<span class="built_in">set</span>(target, <span class="built_in">key</span>, observableResult, receiver)</div><div class="line">      <span class="keyword">return</span> observableResult</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>对于 Proxy 拦截操作也可以在原型链中被继承，例如：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let proto = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get(target, propertyKey, receiver) &#123;</div><div class="line">    console.log('GET ' + propertyKey);</div><div class="line">    return Reflect.get(target, propertyKey, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">let obj = Object.create(proto);</div><div class="line">obj.foo // <span class="string">"<span class="keyword">GET</span> foo"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，拦截操作 <code>get</code> 定义在原型对象上面，所以如果读取 <code>obj</code> 对象属性时，拦截会生效。</p>
<p>同理，通过 Proxy 实现的数据绑定也能与原型继承搭配工作，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const parent = observable(&#123;greeting: <span class="string">'Hello'</span>&#125;)</div><div class="line">const child = observable(&#123;subject: <span class="string">'World!'</span>&#125;)</div><div class="line">Object.setPrototypeOf(child, parent)</div><div class="line"></div><div class="line">function print () &#123;</div><div class="line">  console.log(`$&#123;child.greeting&#125; $&#123;child.subject&#125;`)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hello World!'</span></div><div class="line"><span class="function"><span class="title">observe</span><span class="params">(print)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hello There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; child<span class="selector-class">.subject</span> = <span class="string">'There!'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Hey There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; parent<span class="selector-class">.greeting</span> = <span class="string">'Hey'</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment">// 控制台打印出 'Look There!'</span></div><div class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(()</span></span> =&gt; child<span class="selector-class">.greeting</span> = <span class="string">'Look'</span>, <span class="number">200</span>)</div></pre></td></tr></table></figure></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文中通过简单的代码展示了 Proxy 实现数据绑定，更加完整的实现，参考：<a href="https://github.com/nx-js/observer-util" target="_blank" rel="external">nx-js/observer-util</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/" target="_blank" rel="external">Writing a JavaScript Framework - Data Binding with ES6 Proxies</a><br><a href="http://www.zcfy.cc/article/writing-a-javascript-framework-data-binding-with-es6-proxies-risingstack-1655.html" target="_blank" rel="external">使用 ES6 Proxy 实现数据绑定</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/data-binding-with-es6-proxy.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在上一篇文章：&lt;a href=&quot;https://objcer.com/2017/10/27/Data-binding-introduction/&quot;&gt;探究数据绑定（1）脏检查和存取器方法&lt;/a&gt; 中，探究了 ES5 中实现数据绑定的两种方式；而在本文中，将会探究使用 ES6 Proxy 实现数据绑定。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="数据绑定" scheme="http://objcer.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
      <category term="Proxy" scheme="http://objcer.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>探究数据绑定（1）脏检查和存取器方法</title>
    <link href="http://objcer.com/2017/10/27/Data-binding-introduction/"/>
    <id>http://objcer.com/2017/10/27/Data-binding-introduction/</id>
    <published>2017-10-27T02:30:21.000Z</published>
    <updated>2017-10-27T02:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Data binding is a general technique that binds data sources from the provider and consumer together and synchronizes them.</strong></p>
</blockquote>
<p>在前端组件化框架中，基本都有<strong>数据绑定</strong>这一特性，数据绑定是将生产者的数据源绑定到消费者，并负责数据同步。本文将探究数据绑定的不同实现方式。🤓</p>
<p>目前主要有以下几种实现方案：</p>
<ul>
<li><strong>脏检查（dirty check）</strong></li>
<li><strong>存取器方法（accessor method）</strong>: <code>Object.defineProperty</code> ES5</li>
<li><code>Proxy</code>: ES6 支持较差【Proxies are one of the few non polyfillable additions.（babel不支持转换）】</li>
<li><code>Object.observe</code>: ES7，已经移出草案，不支持</li>
<li><code>object.watch</code>: 目前只有基于gecko的浏览器如火狐支持,官方建议仅供调试用</li>
</ul>
<p>其中前两种方式是主流，angular、Polymer 使用的就是脏检查，Vue 使用的就是存取器方法。</p>
<a id="more"></a>
<h2 id="脏检查（dirty-check）"><a href="#脏检查（dirty-check）" class="headerlink" title="脏检查（dirty check）"></a>脏检查（dirty check）</h2><p>通过一个例子来阐述脏检查的原理：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> provider = &#123;</div><div class="line">  message: <span class="string">'Hello World'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> consumer = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</div><div class="line"></div><div class="line">observe(provider, <span class="string">'message'</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</div><div class="line">  consumer.innerHTML = message</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>定义一个 <code>provider</code> 对象作为生产者，DOM 节点 <code>consumer</code> 作为消费者，通过 <code>observe</code> 监听，生产者数据的变更会反映到消费者上，这样也就简单的实现了数据绑定，即生产者数据绑定到了消费者上。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> <span class="params">(provider, prop, handler)</span> </span>&#123;</div><div class="line">  provider._handlers[prop] = handler</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而其中监听函数 <code>observe</code> 只是将对某一个属性的监听回调 <code>handler</code> 保存起来，方便在该属性值发生变化时，执行该回调。</p>
<p>接下来就是监听变化过程了，脏检查之所以称之为<em>脏</em>，是因为其不是直接监听属性是否发生了变更，而是通过一个定时器轮询检查，不断的遍历检查对象的新值和旧值，判断是否发生了变化，若是，则调用会回调函数 <code>handler</code> 将生产者的数据同步到消费者上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">digest</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  providers.forEach(digestProvider)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">digestProvider</span> (<span class="params">provider</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> provider._handlers) &#123;</div><div class="line">    <span class="keyword">if</span> (provider._prevValues[prop] !== provider[prop]) &#123;</div><div class="line">      provider._prevValues[prop] = provider[prop]</div><div class="line">      handler(provider[prop])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>所以对于 <code>digest</code> 方法就需要循环进行调用</strong>，譬如使用 <code>setInterval</code> 或者 <code>requestAnimationFrame</code> 方法，显然这个过程会对性能产生影响，当监听的对象越来越多时尤其明显。</p>
<p>在 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 1.0 版本中的数据绑定也是使用脏检查的解决方案，在其 <code>observe-js-behavior.html</code> 文件中我们就发现了通过定时器轮询脏检查的代码：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Poll observe-js all the time</span></div><div class="line">setInterval(<span class="keyword">Platform</span>.performMicrotaskCheckpoint, <span class="number">125</span>);</div></pre></td></tr></table></figure></p>
<p>而 angular 就对此也进行了优化，其并不使用定时轮询脏检查，而是对常用的 DOM 事件， XHR 事件等进行封装，在里面触发进入脏检查。</p>
<p>脏检查应该是实现对象监听比较成熟和完整的解决方案。可以参考以下两个项目:</p>
<ul>
<li><a href="https://github.com/Polymer/observe-js" target="_blank" rel="external">Polymer/observe-js</a></li>
<li><a href="https://github.com/MaxArt2501/object-observe" target="_blank" rel="external">MaxArt2501/object-observe</a></li>
</ul>
<p>而对于前者，也是 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 框架中使用的监听方案，</p>
<h2 id="存取器方法（accessor-method）"><a href="#存取器方法（accessor-method）" class="headerlink" title="存取器方法（accessor method）"></a>存取器方法（accessor method）</h2><p>这种方式是通过重写对象（<code>Object</code>类型）属性的 <code>set</code> 和 <code>get</code> 方法，在 <code>setter</code> 方法中执行相应的监听回调（callback）来实现的。</p>
<p>对对象的监听需要考虑 <code>Object</code> 类型和 <code>Array</code> 类型这两种类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一：obj1 只包含 `Object` 类型</span></div><div class="line"><span class="selector-tag">var</span> obj1 = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: <span class="number">2</span>,</div><div class="line">  c: &#123;</div><div class="line">   d: <span class="number">3</span>,</div><div class="line">   e: <span class="number">4</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 情况二：obj2 包含 `Object` 类型和 `Array` 类型</span></div><div class="line"><span class="selector-tag">var</span> obj2 = &#123;</div><div class="line">  <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="selector-tag">b</span>: <span class="number">2</span>,</div><div class="line">  c: [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>首先我们考虑情况一，对象中不包含 <code>Array</code> 类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">obj, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    <span class="comment">// Object</span></div><div class="line">    <span class="keyword">if</span>(type === <span class="string">'[object Object]'</span>) &#123;</div><div class="line">     observeObject(obj, path);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="comment">// for...in 可以遍历对象的实例属性和原型属性，而 Object.keys 只遍历实例属性</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">      <span class="comment">// 注意这里不要用 var</span></div><div class="line">      <span class="keyword">let</span> value = obj[prop],</div><div class="line">        _path = path.slice(); <span class="comment">// 主要对 path 数组进行一次拷贝</span></div><div class="line">        _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">      <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">          callback(_path, newVle, value);</div><div class="line">          value = newVle;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      <span class="comment">// 递归</span></div><div class="line">      observe(value, _path);</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">  observe(obj, []);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>📌注意</strong></p>
<ul>
<li><code>for...in</code> 和 <code>Object.keys</code> 的区别，<a href="http://objcer.com/2017/02/22/js-enumerable/">参考链接</a></li>
<li><code>for...in</code> 循环中，变量定义不能使用 <code>var</code>，需要使用 <code>let</code> 或者用闭包，如下<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = obj[prop],</div><div class="line">        _path = path.slice();</div><div class="line">    _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">      <span class="attribute">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">        callback(_path, newVle, value);</div><div class="line">        value = newVle;</div><div class="line">      &#125;,</div><div class="line">      <span class="attribute">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 递归</span></div><div class="line">    observe(value, _path);</div><div class="line">  &#125;)()</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>测试代码：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></div><div class="line"><span class="attr">  a:</span> <span class="number">1</span><span class="string">,</span></div><div class="line"><span class="attr">  b:</span> <span class="number">2</span><span class="string">,</span></div><div class="line"><span class="attr">  c:</span> <span class="string">&#123;</span></div><div class="line"><span class="attr">   d:</span> <span class="number">3</span><span class="string">,</span></div><div class="line"><span class="attr">   e:</span> <span class="number">4</span></div><div class="line">  <span class="string">&#125;</span></div><div class="line"><span class="string">&#125;;</span></div><div class="line"><span class="string">new</span> <span class="string">Observer(obj,</span> <span class="string">(path,</span> <span class="string">newVle,</span> <span class="string">oldVle)</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></div><div class="line">  <span class="string">console.log(`path:</span> <span class="string">$&#123;path&#125;,</span> <span class="attr">newValue:</span> <span class="string">$&#123;newVle&#125;,</span> <span class="attr">oldValue:</span> <span class="string">$&#123;oldVle&#125;`)</span></div><div class="line"><span class="string">&#125;);</span></div><div class="line"></div><div class="line"><span class="string">obj.a</span> <span class="string">=</span> <span class="number">5</span><span class="string">;</span> <span class="string">//</span> <span class="attr">log:</span> <span class="attr">path:</span> <span class="string">a,</span> <span class="attr">newValue:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">oldValue:</span> <span class="number">1</span></div><div class="line"><span class="string">obj.c.d</span> <span class="string">=</span> <span class="number">6</span><span class="string">;</span> <span class="string">//</span> <span class="attr">log:</span> <span class="attr">path:</span> <span class="string">c,d,</span> <span class="attr">newValue:</span> <span class="number">6</span><span class="string">,</span> <span class="attr">oldValue:</span> <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p><strong>💣 局限性</strong><br>通过 <code>Object.defineProperty</code> 实现对对象的监听，我们是在 <code>set</code> 方法中做文章，那么监听的情况也就只限于对象属性的修改（modify），如果对对象属性的增删（add/delete），那么就无能为力了。</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>接着我们考虑情况二，对象中包含 <code>Object</code> 类型和 <code>Array</code> 类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">obj, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(obj);</div><div class="line">    <span class="keyword">if</span>(type === <span class="string">'[object Object]'</span> || type== <span class="string">'[object Array]'</span>) &#123;</div><div class="line">      observeObject(obj, path);</div><div class="line">      <span class="keyword">if</span> (type === <span class="string">'[object Array]'</span>) &#123;</div><div class="line">        observeArrayPreparation(obj, path);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeObject = <span class="function"><span class="keyword">function</span> (<span class="params">obj, path</span>) </span>&#123;</div><div class="line">    <span class="comment">// for...in 可以遍历对象的实例属性和原型属性，而 Object.keys 只遍历实例属性</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</div><div class="line">      <span class="comment">// 注意：不能用 var</span></div><div class="line">      <span class="keyword">let</span> value = obj[prop],</div><div class="line">        _path = path.slice(); <span class="comment">// 主要对 path 数组进行一次拷贝</span></div><div class="line">        _path.push(prop); <span class="comment">// 记录路径</span></div><div class="line">      <span class="built_in">Object</span>.defineProperty(obj, prop, &#123;</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVle</span>) </span>&#123;</div><div class="line">          callback(_path, newVle, value);</div><div class="line">          value = newVle;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">       <span class="comment">// 递归</span></div><div class="line">       observe(value, _path);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> observeArrayPreparation = <span class="function"><span class="keyword">function</span> (<span class="params">arr, path</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _props = [<span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span>];</div><div class="line">    <span class="keyword">var</span> _newProto = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype);</div><div class="line">    _props.forEach(<span class="function">(<span class="params">prop</span>) =&gt;</span> &#123;</div><div class="line">      <span class="built_in">Object</span>.defineProperty(_newProto, prop, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 注意：数组方法的参数个数不确定，所以此处暂不处理</span></div><div class="line">          <span class="keyword">var</span> _path = path.slice();</div><div class="line">          _path.push(prop);</div><div class="line">          <span class="comment">// 注意：此处只返回 path</span></div><div class="line">          callback(_path);</div><div class="line">          <span class="built_in">Array</span>.prototype[prop].apply(arr, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;);</div><div class="line">    arr.__proto__ = _newProto;</div><div class="line">  &#125;</div><div class="line">  observe(obj, []);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>涉及到数组类型，解决的方法是，重新封装一下数组的操作方法 <code>[&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;]</code>，在其中调用相应的监听回调</p>
<p>测试代码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="type">1</span>,</div><div class="line">  b: <span class="type">2</span>,</div><div class="line">  c: <span class="type"></span>[<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> <span class="type">Observer</span>(obj, (path, <span class="keyword">new</span><span class="type">Vle</span>, oldVle) =&gt; &#123;</div><div class="line">  console.log(`path: <span class="type"></span>$&#123;path&#125;, <span class="keyword">new</span><span class="type">Value</span>: $&#123;<span class="keyword">new</span><span class="type">Vle</span>&#125;, oldValue: <span class="type"></span>$&#123;oldVle&#125;`)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.c[<span class="number">1</span>] = <span class="number">33</span> <span class="comment">// path: c,1, newValue: 33, oldValue: 4</span></div><div class="line"></div><div class="line">obj.c.push(<span class="number">5</span>); <span class="comment">// path: c,push, newValue: undefined, oldValue: undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>📌注意</strong></p>
<ul>
<li>由于数组不同操作方法的参数个数不同，所以在重新定义时需要对此进行判断处理，此处暂不处理，监听回调也只返回 path 路径</li>
<li>上述对数组的处理还存在很多问题，譬如测试代码中，新添加的 <code>5</code> 这个值并没有进行监听，如果此时对 <code>obj.c[2]</code> 进行修改，那么发现并没有回调监听函数；所以此处只提供一个思路。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/" target="_blank" rel="external">Writing a JavaScript Framework - Introduction to Data Binding, beyond Dirty Checking</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Data binding is a general technique that binds data sources from the provider and consumer together and synchronizes them.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前端组件化框架中，基本都有&lt;strong&gt;数据绑定&lt;/strong&gt;这一特性，数据绑定是将生产者的数据源绑定到消费者，并负责数据同步。本文将探究数据绑定的不同实现方式。🤓&lt;/p&gt;
&lt;p&gt;目前主要有以下几种实现方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏检查（dirty check）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存取器方法（accessor method）&lt;/strong&gt;: &lt;code&gt;Object.defineProperty&lt;/code&gt; ES5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxy&lt;/code&gt;: ES6 支持较差【Proxies are one of the few non polyfillable additions.（babel不支持转换）】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.observe&lt;/code&gt;: ES7，已经移出草案，不支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.watch&lt;/code&gt;: 目前只有基于gecko的浏览器如火狐支持,官方建议仅供调试用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中前两种方式是主流，angular、Polymer 使用的就是脏检查，Vue 使用的就是存取器方法。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="数据绑定" scheme="http://objcer.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
      <category term="脏检查" scheme="http://objcer.com/tags/%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    
      <category term="存取器方法" scheme="http://objcer.com/tags/%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web Components</title>
    <link href="http://objcer.com/2017/10/20/Web-Components/"/>
    <id>http://objcer.com/2017/10/20/Web-Components/</id>
    <published>2017-10-20T08:35:02.000Z</published>
    <updated>2017-10-20T08:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/web-components.png" alt=""></p>
<p>组件是构建现代网页应用的基础。组件化给前端开发带来了极大的效率提升，提高了代码的重用性；组件化的 UI 框架也层出不穷，React, Vue 等等。但是这些框架缺乏标准，代码层面可能存在很大的差异，如何对前端组件标准化就显得尤为重要。<br>Web Components 作为面向未来的 Web 组件化标准，包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分，浏览器原生支持，所以 Web Components 是最彻底的组件化解决方案。</p>
<a id="more"></a>
<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><p>Web Components 包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分， 需要浏览器支持，但是目前为止，未被所有浏览器完整实现。<br>参考 <a href="https://www.webcomponents.org/" target="_blank" rel="external">https://www.webcomponents.org/</a> 给出的浏览器支持情况：</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/web-component-browser-support.png" alt=""></p>
<p>基于 Web Components，Google 推出了 <a href="https://www.polymer-project.org/" target="_blank" rel="external">Polymer</a> 框架，作为应用层框架，使用 Polymer 相较于直接使用 Web Components 接口，开发网页应用更加方便简洁，提高效率。Polymer 在今年 5 月份，推出 <a href="https://www.polymer-project.org/blog/2017-05-15-time-for-two.html" target="_blank" rel="external">Polymer 2.0</a>，使用 Shadow DOM v1 和 Custom elements v1，对于不兼容的浏览器，也提供了 polyfill。而在今年 Polymer Summit 大会上，推出了最新 <a href="https://www.polymer-project.org/blog/2017-08-22-npm-modules.html" target="_blank" rel="external">Polymer 3.0 preview</a>，也指明了 Polymer 最新的发展方向，其中主要变化是：① 从 bower 转向 npm ② 使用 ES6 modules，弃用 HTML Imports</p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/" target="_blank" rel="external">Building Components</a> 系列文章中详细介绍了 Custom Elements 和 Shadow DOM，阅读后整理如下：</p>
<ul>
<li><a href="https://objcer.com/2017/10/20/Custom-Elements/">Custom Elements</a></li>
<li><a href="https://objcer.com/2017/10/20/Shadow-DOM/">Shadow DOM</a></li>
</ul>
<p>通过 Web Components 开发自定义组件就是用 Custom Elements 做外壳，其中建立 Shadow DOM 提供 DOM 封装，作用域 CSS 等特性，通过 template 模板构建 DOM，每一个组件都是一个 html 文件，使用时通过 HTML Import引入。</p>
<p>关于 Web Components 网上也有很多讨论质疑的声音：<br><a href="https://github.com/dt-fe/weekly/issues/15" target="_blank" rel="external">精读《Web Components 的困境》</a></p>
<h2 id="Polymer"><a href="#Polymer" class="headerlink" title="Polymer"></a>Polymer</h2><p>Polymer 是基于 Web Components 的组件化框架，了解 Web Components 对于理解使用 Polymer 有很大的帮助。Polymer 可以划分为以下四大部分内容：</p>
<ul>
<li>Custom elements</li>
<li>Shadow DOM</li>
<li>Events</li>
<li>Data system</li>
</ul>
<p>关于 Polymer 的学习会通过下一个系列文章进行记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/web-components.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;组件是构建现代网页应用的基础。组件化给前端开发带来了极大的效率提升，提高了代码的重用性；组件化的 UI 框架也层出不穷，React, Vue 等等。但是这些框架缺乏标准，代码层面可能存在很大的差异，如何对前端组件标准化就显得尤为重要。&lt;br&gt;Web Components 作为面向未来的 Web 组件化标准，包括 HTML Templates, Shadow DOM, Custom elements 和 HTML Imports 四部分，浏览器原生支持，所以 Web Components 是最彻底的组件化解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Web Components" scheme="http://objcer.com/tags/Web-Components/"/>
    
  </entry>
  
  <entry>
    <title>Shadow DOM</title>
    <link href="http://objcer.com/2017/10/20/Shadow-DOM/"/>
    <id>http://objcer.com/2017/10/20/Shadow-DOM/</id>
    <published>2017-10-20T08:08:02.000Z</published>
    <updated>2017-10-20T08:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/shadow-dom.png" alt=""><br>Shadow DOM 是四大网络组件标准之一，提供 CSS 作用域、DOM 封装和组合(Composition) 等优势，构建自定义元素。</p>
<a id="more"></a>
<h2 id="什么是-Shadow-DOM"><a href="#什么是-Shadow-DOM" class="headerlink" title="什么是 Shadow DOM"></a>什么是 Shadow DOM</h2><p>浏览器在解析网页文档的时候，会将 HTML 标签转换成节点，为了保持页面的层次结构，这些节点构成一个节点树，这个结构就是 DOM（文档对象模型）。DOM 将文档作为一个结构化的节点组以及包含属性和方法的对象，是 HTML 的编程接口，我们通常会使用 JavaScript 来访问操纵 DOM。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</div><div class="line"><span class="keyword">const</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</div><div class="line">h1.textContent = <span class="string">'Hello world!'</span>;</div><div class="line">header.appendChild(h1);</div><div class="line"><span class="built_in">document</span>.body.appendChild(header);</div></pre></td></tr></table></figure></p>
<p>这段 JavaScript 代码执行后会生成如下的 DOM 结构：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello DOM<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那什么是 Shadow DOM 呢❓<br>Shadow DOM 为 Web 组件中的 DOM 和 CSS 提供了封装。Shadow DOM 使得这些东西与主文档的 DOM 保持分离。Shadow DOM 与普通的 DOM 的区别是：<br>👉 通常创建新的 DOM 节点附加到其他 DOM 元素上，就会成为其子节点（元素）；但借助 Shadow DOM，可以创建一个  DOM 树附加到其他元素上，这个 DOM 树并非其子节点（元素），其拥有自身的作用域范围，这个 DOM 树称为：<strong><code>shadwo tree</code></strong>。被附加的元素称为 <strong><code>shadow host</code></strong>，这个 DOM 树称为 <strong><code>shadow root</code></strong>。</p>
<blockquote>
<p>You can think of shadow DOM as a scoped subtree inside your element.</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</div><div class="line"><span class="keyword">const</span> shadowRoot = header.attachShadow(&#123;mode: <span class="string">'open'</span>&#125;);</div><div class="line">shadowRoot.innerHTML = <span class="string">'&lt;h1&gt;Hello Shadow DOM&lt;/h1&gt;'</span>; <span class="comment">// Could also use appendChild().</span></div><div class="line"></div><div class="line"><span class="comment">// header.shadowRoot === shadowRoot</span></div><div class="line"><span class="comment">// shadowRoot.host === header</span></div></pre></td></tr></table></figure>
<ul>
<li>为元素创建 shadow DOM，调用 <code>element.attachShadow()</code></li>
<li>通过 <code>shadowRoot</code> 属性获取元素附加的 Shadow DOM</li>
<li>通过 shadow root 的 <code>host</code> 属性获取其附属的元素</li>
</ul>
<p>❗️<strong>注意：</strong>并非所有元素都可以调用 <code>element.attachShadow()</code> 为其创建添加 Shadow DOM，因为有些元素浏览器已经为其添加了 Shadow DOM，例如 <code>&lt;textarea&gt;</code> <code>&lt;input&gt;</code>；而还有些元素为其添加 Shadow DOM 是没有意义的，例如 <code>&lt;img&gt;</code>。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">document</span><span class="selector-class">.createElement</span>(<span class="string">'input'</span>)<span class="selector-class">.attachShadow</span>(&#123;<span class="attribute">mode</span>: <span class="string">'open'</span>&#125;);</div><div class="line"><span class="comment">// Error. `&lt;input&gt;` cannot host shadow dom.</span></div></pre></td></tr></table></figure>
<p>在创建自定义元素时，Shadow DOM 尤其有用。使用 Shadow DOM 来分隔元素的 HTML、CSS 和 JS，从而生成一个组件。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    shadowRoot.innerHTML = `</div><div class="line">    &lt;style&gt;</div><div class="line">    b &#123;</div><div class="line">      color: red;</div><div class="line">    &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;b&gt;<span class="type">Hello</span> world&lt;/b&gt;</div><div class="line">    `</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>注意 Shadow DOM 中的 CSS 规则的作用域仅限于 <code>&lt;x-tag&gt;</code>。</p>
<h2 id="组合和-slot"><a href="#组合和-slot" class="headerlink" title="组合和 slot"></a>组合和 slot</h2><p>组合是 shadow DOM 最难理解的功能之一，但可以说是最重要的功能。</p>
<h3 id="light-DOM-和-shadow-DOM"><a href="#light-DOM-和-shadow-DOM" class="headerlink" title="light DOM 和 shadow DOM"></a>light DOM 和 shadow DOM</h3><p><strong>light DOM</strong><br>使用组件的用户编写的标记，DOM 元素的实际子元素，该子元素不在组件的 shadow DOM 之内，这就是 light DOM。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"better-button"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- the image and span are better-button's light DOM --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"gear.svg"</span> <span class="attr">slot</span>=<span class="string">"icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Settings<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中 <code>image</code> 和 <code>span</code> 即是 <code>button</code> 的 light DOM。</p>
<p><strong>shadow DOM</strong><br>组件作者编写的标记，它定义组件的内部结构，作用域 CSS 等<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">...</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>Flattened DOM tree</strong><br>浏览器将用户的 light DOM 分布到 shadow DOM 中，渲染成一颗 DOM 树，这个过程称为 <strong><code>flattening the tree</code></strong>，这棵树称为扁平树 <strong><code>Flattened DOM tree</code></strong>。 扁平树也是我们在 DevTools 中最终看到的树以及在页面上渲染的结果。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/FF183E44-E19D-4B24-918B-2DE5067699A4.png" alt=""></p>
<h3 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><slot> 元素</slot></h3><p>Shadow DOM 使用 <code>&lt;slot&gt;</code> 元素将 light DOM 树组合到 shadow DOM 中，形成一颗 DOM 树。</p>
<p>Slot 相当于是组件内部的占位符，通过定义一个或者多个 <code>&lt;slot&gt;</code>，可以将外部的标记引入到组件 shadow DOM 中进行渲染，相当于“跨域”了 shadow DOM 的边界，这些引入到 shadow DOM 中的元素被称为分布式节点 <strong><code>distributed nodes</code></strong>。注意：slot 实际上并不移动这些分布式节点，它们在 shadow DOM 内部的其他位置进行渲染。</p>
<p>组件可在其 shadow DOM 中定义零个或多个 slot。Slot 可以为空，或者提供回退内容(fallback content)，如果用户不提供 light DOM 内容，slot 会将对其备用内容进行渲染。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Default slot. If there's more than one default slot, the first is used. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>Fancy button<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- default slot with fallback content --&gt;</span></div></pre></td></tr></table></figure>
<p>还可以创建命名 slot (named slots)，使用组件的用户通过名称找到特定的 slot。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">x-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Custom Elements<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">x-tag</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">b</span> &#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="设定样式"><a href="#设定样式" class="headerlink" title="设定样式"></a>设定样式</h2><p>shadow DOM 最有用的功能是作用域 CSS：</p>
<ul>
<li>外部页面中的 CSS 选择器不会应用于组件内部。</li>
<li>组件内部定义的样式也不会渗出，它们的作用域仅限于宿主元素(shadow host)</li>
</ul>
<h3 id="通过选择器设定样式"><a href="#通过选择器设定样式" class="headerlink" title="通过选择器设定样式"></a>通过选择器设定样式</h3><p><strong>使用 <code>:host</code> 为组件为自身设定样式</strong><br>需要注意：外部页面中为组件设定的样式比 <code>:host</code> 规则具有更高的优先级，也就是说，对于组件自身，外部样式优先，用户可以在外部设置组件自身的样式。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 外部样式比 :host 优先</div><div class="line">x-tag &#123;</div><div class="line">  border: 1px solid red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">:host</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用 <code>:host(&lt;selector&gt;)</code> 匹配组件自身不同状态</strong><br>通过 <code>:host(&lt;selector&gt;)</code> 匹配不同状态，对组件自身或者内部节点设定不同的样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">:host(</span><span class="selector-pseudo">:hover)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.red_bg)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.green_bg)</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">:host(.disable)</span> <span class="selector-tag">button</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用 <code>:host-context(&lt;selector&gt;)</code> 匹配任意父级</strong><br>使用 <code>:host-context(&lt;selector&gt;)</code> 主要用于根据组件所在的环境进行主题化（基于情境设定样式），例如设置白天模式，夜晚模式，我们在 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 设定不同的 class，而组件通过 <code>:host-context(&lt;selector&gt;)</code> 就可以匹配到</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;body class="darktheme"&gt;</span></div><div class="line">  <span class="params">&lt;fancy-tabs&gt;</span></div><div class="line">    ...</div><div class="line">  <span class="params">&lt;/fancy-tabs&gt;</span></div><div class="line"><span class="params">&lt;/body&gt;</span></div><div class="line"></div><div class="line"><span class="meta">#shadow-root</span></div><div class="line">  :host-context(.darktheme) &#123;</div><div class="line"><span class="symbol">    color:</span> white;</div><div class="line"><span class="symbol">    background:</span> black;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>使用 <code>::slotted(&lt;compound-selector&gt;)</code> 匹配分布到 <slot> 中的节点</slot></strong><br>使用 <code>::slotted(&lt;compound-selector&gt;)</code> 为分布式节点设定样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">name-badge</span>&gt;</span></div><div class="line">  #shadow-root</div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Eric Bidelman<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></div><div class="line">      Digital Jedi, <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"company"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">name-badge</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>组件的 shadow DOM 可为用户的 <code>&lt;h2&gt;</code> 和 <code>.title</code> 设定样式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">::slotted(h2)</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-pseudo">::slotted(.title)</span> &#123;</div><div class="line">     <span class="attribute">color</span>: orange;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* DOESN'T WORK (can only select top-level nodes).</span></div><div class="line">  ::slotted(.company),</div><div class="line">  ::slotted(.title .company) &#123;</div><div class="line">    text-transform: uppercase;</div><div class="line">  &#125;</div><div class="line">  */</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是：<br>① 使用 <code>::slotted(&lt;compound-selector&gt;)</code> 只能为分布节点的<strong>顶级节点</strong>设置样式。<br>② slot 并不会移动 light DOM，light DOM 节点分布到 shadow DOM 中后，slot 会对其 DOM 进行渲染，样式设置，但是节点实际还是留在原处。如果外部对 light DOM 设置了样式，那么外部样式将会覆盖 shadow DOM 中通过 <code>::slotted(&lt;compound-selector&gt;)</code> 设置的样式，具有较高优先级。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">  x-tag p &#123;</div><div class="line">    color: red; // 外部样式，具有较高优先级</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">x-tag</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>Custom Elements<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">x-tag</span>&gt;</span></div><div class="line"></div><div class="line">#shadow-root</div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-pseudo">::slotted(p)</span> &#123;</div><div class="line">    <span class="attribute">color</span>: green;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="从外部为组件设定样式"><a href="#从外部为组件设定样式" class="headerlink" title="从外部为组件设定样式"></a>从外部为组件设定样式</h3><p>有几种方法可从外部为组件设定样式：最简单的方法是使用标记名称作为选择器</p>
<p><strong>为组件自身设定样式</strong><br>从外部为组件自身设定样式最简单的方法，就是使用组件标签名称作为选择器，设置 CSS 样式。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x-<span class="keyword">tag</span> <span class="title">&#123;</span></div><div class="line"></div><div class="line">&#125;</div><div class="line">x-tag:hover &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<strong>外部样式总是优先于在 shadow DOM 中定义的样式。</strong>例如，如果用户在组件外部编写：<code>fancy-tabs { width: 500px; }</code>，它将优先于组件的规则：<code>:host { width: 650px;}</code>。</p>
<p><strong>为组件内部元素设定样式</strong><br>在组件外部，我们不能直接通过选择器对组件内的元素设置样式。组件提供自定义属性 <strong>custom properties</strong>，相当于是样式占位符，外部通过对自定义属性 <strong>custom properties</strong> 来调整组件内部元素的样式。</p>
<p>例如，<code>&lt;fancy-tabs&gt;</code> 可让用户替换背景颜色：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- main page --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">fancy-tabs</span> &#123;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">--fancy-tabs-bg</span>: black;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">fancy-tabs</span> <span class="attr">background</span>&gt;</span>...<span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在其 shadow DOM 内部：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:host(</span><span class="selector-attr">[background]</span>) &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--fancy-tabs-bg, #9E9E9E);</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中，该组件将使用 <code>black</code> 作为背景值，因为用户指定了该值。 否则背景颜色将采用默认值 <code>#9E9E9E</code>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="避免在组件中创建-closed-shadow-root"><a href="#避免在组件中创建-closed-shadow-root" class="headerlink" title="避免在组件中创建 closed shadow root"></a>避免在组件中创建 closed shadow root</h3><p>shadow DOM 的另一情况称为<strong>闭合</strong>模式。创建closed shadow DOM tree 后，在外部无法通过 JavaScript 访问组件的内部 DOM。这与 <code>&lt;video&gt;</code> 等原生元素工作方式类似，JavaScript 无法访问 <code>&lt;video&gt;</code> 的 shadow DOM，因为浏览器使用closed shadow root来实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">const</span> shadowRoot = div.attachShadow(&#123;mode: <span class="string">'closed'</span>&#125;); <span class="comment">// close shadow tree</span></div><div class="line"><span class="comment">// div.shadowRoot === null</span></div><div class="line"><span class="comment">// shadowRoot.host === div</span></div></pre></td></tr></table></figure>
<h3 id="关于-slot-的-API"><a href="#关于-slot-的-API" class="headerlink" title="关于 slot 的 API"></a>关于 slot 的 API</h3><p><strong><code>slotchange</code> 事件</strong></p>
<p>当 slot 的分布式节点发生变化时，<code>slotchange</code> 事件会触发。例如，当用户从 light DOM 中添加/移除子项时。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> slot = <span class="keyword">this</span>.shadowRoot.querySelector(<span class="string">'#slot'</span>);</div><div class="line">slot.addEventListener(<span class="string">'slotchange'</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'light dom children changed!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注：当组件的实例首次初始化时，<code>slotchange</code> 不触发。</p>
<p><strong>查看 slot 中渲染的元素</strong><br>调用 <code>slot.assignedNodes()</code> 可查看 slot 正在渲染哪些元素；该方法中传入 <code>{flatten: true}</code> 选项将返回 slot 的备用内容fallbcak content（前提是没有分布任何节点）。</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>调用</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;My button&lt;/button&gt;</code></td>
<td>slot.assignedNodes();</td>
<td>[text]</td>
</tr>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;&lt;/button&gt;</code></td>
<td>slot.assignedNodes();</td>
<td>[]</td>
</tr>
<tr>
<td><code>&lt;button is=&quot;better-button&quot;&gt;&lt;/button&gt;</code></td>
<td>slot.assignedNodes({flatten: true});</td>
<td>[<b>fallback content</b>]</td>
</tr>
</tbody>
</table>
<p><strong>查看元素渲染在哪个 slot 中</strong><br><code>element.assignedSlot</code> 将告诉您元素分配到组件的哪个 slot。</p>
<h3 id="Shadow-DOM-事件模型"><a href="#Shadow-DOM-事件模型" class="headerlink" title="Shadow DOM 事件模型"></a>Shadow DOM 事件模型</h3><p>当事件从 shadow DOM 中触发时，其目标 target 为维持 shadow DOM 的封装，不暴露 shadow DOM 中的内容元素，会进行重置 retarget，看起来事件是来自组件本身，而不是组件中 shadow DOM 中的内容元素。</p>
<p>大部分事件都会跨过 shadow DOM 边界，向外传播：</p>
<ul>
<li>聚焦事件：blur、focus、focusin、focusout</li>
<li>鼠标事件：click、dblclick、mousedown、mouseenter、mousemove，等等</li>
<li>滚轮事件：wheel</li>
<li>输入事件：beforeinput、input</li>
<li>键盘事件：keydown、keyup</li>
<li>组合事件：compositionstart、compositionupdate、compositionend</li>
<li>拖放事件：dragstart、drag、dragend、drop，等等</li>
</ul>
<p>对于 <code>mode</code> 为 <code>open</code> 的 shadow DOM，事件回调中，调用 <code>event.composedPath()</code> 将返回事件向上传播经过的节点路径。</p>
<p>对于组件内的自定义事件，不会传播出 shadow DOM，除非事件创建时指定 <code>composed: true</code><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inside &lt;fancy-tab&gt; custom element class definition:</span></div><div class="line">selectTab() &#123;</div><div class="line">  <span class="keyword">const</span> tabs = <span class="keyword">this</span>.shadowRoot.<span class="built_in">querySelector</span>(<span class="string">'#tabs'</span>);</div><div class="line">  tabs.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'tab-select'</span>, &#123;bubbles: <span class="keyword">true</span>, composed: <span class="keyword">true</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 <code>composed: false</code>（默认值），用户无法在组件外部侦听到这个自定义事件。<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">fancy-tabs</span>&gt;</span><span class="tag">&lt;/<span class="name">fancy-tabs</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> tabs = <span class="built_in">document</span>.querySelector(<span class="string">'fancy-tabs'</span>);</div><div class="line">  tabs.addEventListener(<span class="string">'tab-select'</span>, e =&gt; <span class="template-variable">&#123;</span></div><div class="line">    // won't fire <span class="keyword">if</span> `tab-<span class="keyword">select</span>` wasn't created with `composed: true`.</div><div class="line">  &#125;<span class="xml"><span class="undefined">);</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文主要是阅读 <strong>Shadow DOM v1: Self-Contained Web Components</strong> 后，理解整理而来。<br>英文原文：<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom" target="_blank" rel="external">Shadow DOM v1: Self-Contained Web Components</a><br>中文翻译：<a href="https://developers.google.com/web/fundamentals/web-components/best-practices?hl=zh-cn" target="_blank" rel="external">Shadow DOM v1：独立的网络组件</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/shadow-dom.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Shadow DOM 是四大网络组件标准之一，提供 CSS 作用域、DOM 封装和组合(Composition) 等优势，构建自定义元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Shadow DOM" scheme="http://objcer.com/tags/Shadow-DOM/"/>
    
  </entry>
  
  <entry>
    <title>Custom Elements</title>
    <link href="http://objcer.com/2017/10/20/Custom-Elements/"/>
    <id>http://objcer.com/2017/10/20/Custom-Elements/</id>
    <published>2017-10-20T08:07:56.000Z</published>
    <updated>2017-10-20T08:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/custom-elements.png" alt=""></p>
<p>Custom Elements 为开发者提供了创建新 HTML 标记，扩展现有 HTML 标记的能力，创建自定义新的元素，将 JS 逻辑行为和元素 DOM 关联起来，代码模块化，提供重用性。</p>
<a id="more"></a>
<h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p><strong>创建自定义元素包括两个步骤：</strong></p>
<ul>
<li><p>通过 class <strong>定义</strong>自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="comment">// If you define a ctor, always call super() first!</span></div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>向浏览器<strong>注册</strong>该自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;...&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">AppDrawer</span>);</div><div class="line"></div><div class="line"><span class="comment">// 匿名类</span></div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>创建自定义元素几点注意：</strong></p>
<ul>
<li>自定义元素定义类中的构造函数中，总是需要调用 <code>super()</code></li>
<li>自定义元素名称必须要包含一个短横线(-)，浏览器以次来区分自定义元素和常规元素。例如 <code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code> 为有效名称；而 <code>&lt;tabs&gt;</code> 和 <code>&lt;foo_bar&gt;</code> 则为无效名称</li>
<li><p>不能多次注册同一自定义元素，否则会抛出 <code>DOMException</code> 异常</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">A</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;&#125;</div><div class="line">window.customElements.define(<span class="symbol">'app</span>-drawer', <span class="type">B</span>); <span class="comment">// ❗️DOMException</span></div></pre></td></tr></table></figure>
</li>
<li><p>自定义元素不能自闭合(self-closing)，所以需要写结束标签，例如 <code>&lt;x-tags&gt;&lt;/x-tags&gt;</code></p>
</li>
</ul>
<p><strong>定义新的自定义元素，class 类继承 <code>HTMLElement</code>；也可以扩展已有的元素，包括：</strong></p>
<ul>
<li><p>扩展自定义元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyDrawer</span> <span class="keyword">extends</span> <span class="title">AppDrawer</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>扩展 HTML 原生元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">customElements.define(<span class="symbol">'fancy</span>-button', <span class="type">FancyButton</span>, &#123;<span class="keyword">extends</span>: <span class="symbol">'butto</span>n'&#125;);</div></pre></td></tr></table></figure>
<p>扩展 HTML 原生元素时，对 <code>define()</code> 的调用会稍有不同，需要传入第三个参数告知浏览器要扩展的标记。</p>
</li>
</ul>
<p>使用自定义元素与 <code>&lt;div&gt;</code> 或任何其他元素的使用没有区别。可以在页面上声明，也可也通过 JavaScript 动态创建实例，也可添加事件侦听器，诸如此类。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;app-drawer&gt;&lt;/app-drawer&gt;</div><div class="line"><span class="keyword">let</span> drawer = <span class="keyword">new</span> AppDrawer()</div><div class="line"></div><div class="line"><span class="comment">// ❗️自定义 HTML 原生元素需要在原生标记上添加 is="" 属性来声明</span></div><div class="line">&lt;button <span class="keyword">is</span>=<span class="string">"fancy-button"</span>&gt;Fancy button!&lt;/button&gt;</div><div class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> FancyButton()</div><div class="line"></div><div class="line"><span class="comment">// customElements.get 方法通过传入自定义元素标记名称，获取元素的构造函数</span></div><div class="line"><span class="keyword">let</span> Drawer = customElements.<span class="keyword">get</span>(<span class="string">'app-drawer'</span>);</div><div class="line"><span class="keyword">let</span> drawer = <span class="keyword">new</span> Drawer();</div></pre></td></tr></table></figure></p>
<h2 id="自定义元素的响应"><a href="#自定义元素的响应" class="headerlink" title="自定义元素的响应"></a>自定义元素的响应</h2><p>自定义元素提供了一些响应方法，表征其生命周期的不同时刻，我们可以在这些响应方法（回调方法）中执行相关的逻辑。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>创建或升级元素的一个实例。用于初始化状态、设置事件侦听器或创建 Shadow DOM</td>
</tr>
<tr>
<td>connectedCallback</td>
<td>元素每次插入到 DOM 时都会调用</td>
</tr>
<tr>
<td>disconnectedCallback</td>
<td>元素每次从 DOM 中移除时都会调用</td>
</tr>
<tr>
<td>attributeChangedCallback(attrName, oldVal, newVal)</td>
<td>属性添加、移除、更新或替换时调用；创建元素或者升级时，也会调用它来获取初始值</td>
</tr>
<tr>
<td>adoptedCallback</td>
<td>自定义元素被移入新的 document （例如，有人调用了 document.adoptNode(el)）</td>
</tr>
</tbody>
</table>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDrawer</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>(); <span class="comment">// always call super() first in the ctor.</span></div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  connectedCallback() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  disconnectedCallback() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  attributeChangedCallback(attrName, oldVal, newVal) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>attributeChangedCallback</code> 响应仅针对 <code>observedAttributes</code> 属性中列出的，对于 class, style 等属性的修改并不会调用该响应，这也是处于性能考虑</li>
<li><code>disconnectedCallback()</code> 响应主要用于清理工作，例如移除事件侦听器等。但是如果用户关闭了标签，<code>disconnectedCallback()</code> 响应将无法调用</li>
<li><strong>响应是同步的</strong>，例如移除自定义元素后，会立即收到 <code>disconnectedCallback()</code> 响应</li>
</ul>
<h2 id="自定义元素升级-upgrades"><a href="#自定义元素升级-upgrades" class="headerlink" title="自定义元素升级(upgrades)"></a>自定义元素升级(upgrades)</h2><p><strong>自定义元素可以在其定义注册之前使用。</strong></p>
<p>HTML 解析标签容错能力强，对于页面上声明的 <code>&lt;asdfasdf&gt;</code> 这类未知的标签，浏览器也能接受，因为 HTML 规范允许这类未知标签，它把这类未知标签生成的元素当成 <code>HTMLUnknownElement</code> 进行解析。而当页面中存在符合自定义元素命名规则（包含短横线’-‘）的标签，但是还未定义注册时，浏览器将其视为潜在的自定义元素，解析成 <code>HTMLElement</code></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> <span class="string">"tabs"</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid custom element name</div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'tabs'</span>) <span class="keyword">instanceof</span> HTMLUnknownElement === <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="regexp">//</span> <span class="string">"x-tabs"</span> <span class="keyword">is</span> a valid custom element name</div><div class="line"><span class="built_in">document</span>.createElement(<span class="string">'x-tabs'</span>) <span class="keyword">instanceof</span> HTMLElement === <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>所以我们可以在页面中先声明使用自定义元素，其后再调用 <code>customElements.define</code> 注册自定义元素，在自定义元素注册完成后，将页面中已声明使用的升级（upgrades）为自定义元素，这个过程称之为元素升级（element upgrades）</p>
<p>要了解标记名称何时注册定义，可以使用 <code>window.customElements.whenDefined()</code>。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">customElements.whenDefined(<span class="string">'app-drawer'</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'app-drawer defined'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="自定义元素的状态-state"><a href="#自定义元素的状态-state" class="headerlink" title="自定义元素的状态 (state)"></a>自定义元素的状态 (state)</h2><p>自定义元素的状态包括：<strong><code>undefined</code>, <code>failed</code>, <code>uncustomized</code>, <code>custom</code></strong>，其中 <strong><code>uncustomized</code>, <code>custom</code></strong> 都表已定义 <strong><code>defined</code></strong>；对于类似 <code>div</code> 的内置元素状态始终为已定义 <strong><code>defined</code></strong></p>
<p>在元素升级之前，处于未定义状态，我们可以过 <code>:defined</code> 伪类预设置未注册元素的样式，避免在获得定义时产生布局跳动或者 FOUC</p>
<blockquote>
<p>FOUC: Flash of Unstyled Content 文档样式短暂失效，指 HTML 页面在打开过程中，内容先于样式展示，导致页面样式在瞬间出现剧变，并且人眼可见</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">app-drawer</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:defined)</span> &#123;</div><div class="line">  <span class="comment">/* Pre-style, give layout, replicate app-drawer's eventual styles, etc. */</span></div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> ease-in-out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>&lt;app-drawer&gt;</code> 获得定义后，选择器 <code>app-drawer:not(:defined)</code> 不再匹配。</p>
<h2 id="设置自定义元素的内容"><a href="#设置自定义元素的内容" class="headerlink" title="设置自定义元素的内容"></a>设置自定义元素的内容</h2><h3 id="通过-innerHTML-设置元素内容"><a href="#通过-innerHTML-设置元素内容" class="headerlink" title="通过 innerHTML 设置元素内容"></a>通过 <code>innerHTML</code> 设置元素内容</h3><p>自定义元素在 <code>connectedCallback</code> 响应中，使用 DOM API 来设置元素的内容，但这不是好的做法，不推荐使用，更好的方式是使用 Shadow DOM。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  connectedCallback() &#123;</div><div class="line">    <span class="keyword">this</span>.innerHTML = '&lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt; <span class="type">Custom</span> <span class="type">Element</span>'</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="通过-Shadow-DOM-设置元素内容"><a href="#通过-Shadow-DOM-设置元素内容" class="headerlink" title="通过 Shadow DOM 设置元素内容"></a>通过 Shadow DOM 设置元素内容</h3><blockquote>
<p>关于 Shadow DOM 的详细介绍，参考：<a href=""></a></p>
</blockquote>
<p>Shadow DOM 提供了一种方法，可让设置的元素以独立于页面其余部分的方式拥有和渲染 DOM 并设置其样式。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;x-tag&gt;<span class="type">Custom</span> <span class="type">Element</span>&lt;/x-tag&gt;</div><div class="line"></div><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    shadowRoot.innerHTML = `</div><div class="line">    &lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt;</div><div class="line">    &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    `</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在这个例子中，Shadow DOM 是通过 <code>innerHTML</code> 来创建 DOM 元素；我们还可以通过 <code>&lt;template&gt;</code> 元素来创建 DOM。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;x-tag&gt;<span class="type">Custom</span> <span class="type">Element</span>&lt;/x-tag&gt;</div><div class="line">&lt;template id=<span class="string">"tmpl"</span>&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">  <span class="comment">/*scoped styles*/</span></div><div class="line">  &lt;/style&gt;</div><div class="line">  &lt;b&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/b&gt;</div><div class="line">  &lt;slot&gt;&lt;/slot&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">window.customElements.define(<span class="symbol">'x</span>-tag', <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    let shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;mode: <span class="symbol">'ope</span>n'&#125;)</div><div class="line">    let tmpl = document.querySelector('#tmpl')</div><div class="line">    shadowRoot.appendChild(tmpl.content.cloneNode(<span class="literal">true</span>))</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="属性-property-映射为特性-attribute"><a href="#属性-property-映射为特性-attribute" class="headerlink" title="属性 (property) 映射为特性 (attribute)"></a>属性 (property) 映射为特性 (attribute)</h2><p>对 DOM 元素属性 (property) 修改，其值会以特性 (attribute) 的形式映射到 DOM，例如通过 JS 修改 DOM 元素的 id，hidden 属性：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">div</span>.<span class="built_in">id</span> = '<span class="keyword">my</span>-<span class="built_in">id</span>';</div><div class="line"><span class="keyword">div</span>.hidden = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>DOM 节点会变成：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"my-id"</span> hidden&gt;</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文主要是阅读 <strong>Custom Elements v1: Reusable Web Components</strong> 后，理解整理而来。<br>英文原文：<a href="https://developers.google.com/web/fundamentals/web-components/customelements" target="_blank" rel="external">Custom Elements v1: Reusable Web Components</a><br>中文翻译：<a href="https://developers.google.com/web/fundamentals/web-components/customelements?hl=zh-cn" target="_blank" rel="external">自定义元素 v1：可重用网络组件</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/custom-elements.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Custom Elements 为开发者提供了创建新 HTML 标记，扩展现有 HTML 标记的能力，创建自定义新的元素，将 JS 逻辑行为和元素 DOM 关联起来，代码模块化，提供重用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Components" scheme="http://objcer.com/categories/Web-Components/"/>
    
    
      <category term="Custom Elements" scheme="http://objcer.com/tags/Custom-Elements/"/>
    
  </entry>
  
  <entry>
    <title>0.1+0.2=0.30000000000000004❓</title>
    <link href="http://objcer.com/2017/10/16/floating-point-arithmetic/"/>
    <id>http://objcer.com/2017/10/16/floating-point-arithmetic/</id>
    <published>2017-10-16T08:31:42.000Z</published>
    <updated>2017-10-17T01:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-brjYnVlXwM3j_SWXImT0Rg.png" alt=""><br>JavaScript中所有的数字，无论是整数还是小数，其类型都是 Number，遵循 <a href="http://grouper.ieee.org/groups/754/" target="_blank" rel="external">IEEE 754</a> 程序内部用一个 64 位固定长度的二进制进行存储表示。JavaScript 中的浮点数进行运算时，经常会遇到计算精度问题，例如经典的 <code>0.1+0.2=0.30000000000000004</code>，本文将探究 JavaScript 的浮点数，并解释为何 <code>0.1+0.2=0.30000000000000004</code></p>
<a id="more"></a>
<h2 id="浮点数的二进制表示"><a href="#浮点数的二进制表示" class="headerlink" title="浮点数的二进制表示"></a>浮点数的二进制表示</h2><p>JavaScript 里的数字是采用 <a href="http://grouper.ieee.org/groups/754/" target="_blank" rel="external">IEEE 754</a> 标准的 64 位 double 双精度浮点数（与之相关的还有 32 位 float 单精度浮点数）。该规范定义了浮点数的格式。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/5F33F675-2DF0-472F-9F2E-98066AE91720.png" alt=""></p>
<p>对于 32 位的浮点数，最高的 1 位是符号位 S，接着的 8 位是指数 E，剩下的 23 位为尾数位 M<br>对于 64 位的浮点数，最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为尾数位 M</p>
<ul>
<li>符号位 S：0 表示正数，1 表示负数</li>
<li>指数 E：表示次方</li>
<li>尾数位 M：表示有效数字（小数部分）</li>
</ul>
<p>实际数字的计算公式为：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V = (-<span class="number">1</span>)<span class="symbol">^S</span> * M * <span class="number">2</span><span class="symbol">^E</span></div></pre></td></tr></table></figure></p>
<p>接下来只对 64 位浮点数的二进制表示进行分析：</p>
<p>该计算公式遵循科学计数法的规范，对于十进制表示而言，尾数的范围是 <code>0&lt;M&lt;10</code>；对于二进制表示而言，尾数的范围是 <code>0&lt;M&lt;2</code>。浮点数二进制表示，所以此处尾数的范围是：<code>0&lt;M&lt;2</code>，也就是说 M 的整数位始终是 1，所以可以舍去，只保留后面的小数部分，这样就能表示 53 位了。</p>
<p>指数位 E 是一个无符号整数，64 位浮点数中，指数位长度是 11 位，取值范围是 <code>[0~2047]</code>，由于科学计数法中指数可正可负，所以，中间数 1023，<code>[0,1022]</code> 表示为负，<code>[1024,2047]</code> 表示为正</p>
<p>最终的公式变成：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V = (<span class="number">-1</span>)^S * (M + <span class="number">1</span>) * <span class="number">2</span>^(E - <span class="number">1023</span>)</div></pre></td></tr></table></figure></p>
<h3 id="十进制转换为二进制"><a href="#十进制转换为二进制" class="headerlink" title="十进制转换为二进制"></a>十进制转换为二进制</h3><p><strong>十进制整数转换为二进制整数：</strong>采用”除2取余，逆序排列”法。具体做法是：用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>
<p><strong>十进制小数转换成二进制小数：</strong>采用”乘2取整，顺序排列”法。具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/58DF62FC-51A3-4F01-A3C6-0E75DF916261.png" alt=""></p>
<p>（173.8125）10＝（❓）2</p>
<ul>
<li>（173）10＝（10101101）2</li>
<li>（0.8125）10＝（0.1101）2</li>
</ul>
<p>把整数部分和小数部分合并得：（173.8125）10＝（10101101.1101）2</p>
<h3 id="64-位浮点数的二进制表示"><a href="#64-位浮点数的二进制表示" class="headerlink" title="64 位浮点数的二进制表示"></a>64 位浮点数的二进制表示</h3><blockquote>
<p>十进制数和 64 位浮点数二进制相互转换可以访问该网站进行：<br><a href="http://www.binaryconvert.com/convert_double.html" target="_blank" rel="external">http://www.binaryconvert.com/convert_double.html</a></p>
</blockquote>
<p>下面以 0.1 为例，对其进行 64 位二进制表示</p>
<p>0.1 转换成二进制：0.0001100110011001100(1100循环)，即 <code>1.100110011001100x2^-4</code>，得到:</p>
<ul>
<li>指数位 E = -4 + 1023 = 1019 (<code>1019</code> 11 位二进制表示为：01111111011)</li>
<li>尾数位 M = 100110011001100… (舍去首位 1)</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/000D23FF-1ECD-45D1-9BC3-09908A10787B.png" alt=""></p>
<p>所以十进制 0.1 转换成 64 位浮点数二进制表示为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0011111110111001100110011001100110011001100110011001100110011010</span></div></pre></td></tr></table></figure></p>
<p>而将 64 位浮点数二进制的 0.1 转换回十进制时，得到：<code>1.00000000000000005551115123126E-1</code>。</p>
<p>但是：此时输出 <code>x</code> 为啥能得到 0.1 呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0.1</span></div><div class="line"><span class="built_in">console</span>.log(x) <span class="comment">// -&gt; 0.1</span></div></pre></td></tr></table></figure></p>
<p><strong>分析：</strong>尾数位固定长度 52 位，加上省略的整数位 1，就再加上一位，那么尾数最多能表示的数为：2^53=9007199254740992，对应的十进制科学计数尾数是 9.007199254740992，这也是 JavaScript 最多能表示的精度，长度是 16，所以用 <code>toPrecision(16)</code>  来做精度运算，于是：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.10000000000000000555</span>.toPrecision(<span class="number">16</span>) <span class="comment">// -&gt; 0.1</span></div></pre></td></tr></table></figure></p>
<p>如果使用更高精度，那么可能得到的就不是 0.1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0.1</span></div><div class="line"><span class="built_in">console</span>.log(x.toPrecision(<span class="number">21</span>)) <span class="comment">// -&gt; 0.100000000000000005551</span></div></pre></td></tr></table></figure></p>
<p>注意：<code>toPrecision</code> 方法最大指定精度为 21。对于 0.1 而言，64 位二进制表示，最多能表示的精度为 16 位；转换成十进制后 <code>0.100000000000000005551</code>，默认的 JavaScript 使用 16 位进行截取，我们最多能使用 21 位进行截取，注意二者的区别。</p>
<h3 id="toPrecision-和-toFixed"><a href="#toPrecision-和-toFixed" class="headerlink" title="toPrecision 和 toFixed"></a>toPrecision 和 toFixed</h3><ul>
<li><code>toPrecision</code> 方法以指定的精度返回该数值对象的字符串表示，精度是从左至右第一个不为0的数开始数起</li>
<li><code>toFixed</code> 方法使用定点表示法来格式化一个数，是小数点后指定位数取整，从小数点开始数起</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var x = <span class="number">0.12345</span></div><div class="line">x.toPrecision(<span class="number">3</span>) <span class="comment">// -&gt; "0.123"</span></div><div class="line"></div><div class="line">var y = <span class="number">1.234</span></div><div class="line">y.toFixed(<span class="number">3</span>) <span class="comment">// -&gt; "1.234"</span></div></pre></td></tr></table></figure>
<p>这两个方法在截取数字时，都有进行四舍五入处理，但是都存在 BUG，使用要谨慎❗️<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x = <span class="number">0.3456</span></div><div class="line"><span class="function"><span class="title">x</span>.toPrecision(3) // -&gt;</span> <span class="string">"0.346"</span></div><div class="line"><span class="function"><span class="title">x</span>.toFixed(3) // -&gt;</span> <span class="string">"0.346"</span></div><div class="line"></div><div class="line"><span class="comment">// BUG</span></div><div class="line">var y = <span class="number">1.005</span></div><div class="line"><span class="function"><span class="title">y</span>.toPrecision(3) // -&gt;</span> <span class="string">"1.00"</span></div><div class="line"><span class="function"><span class="title">y</span>.toFixed(2) // -&gt;</span> <span class="string">"1.00"</span></div></pre></td></tr></table></figure></p>
<p>原因是：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去了</p>
<h2 id="0-1-0-2-0-30000000000000004"><a href="#0-1-0-2-0-30000000000000004" class="headerlink" title="0.1+0.2=0.30000000000000004"></a>0.1+0.2=0.30000000000000004</h2><p>在计算 <code>0.1+0.2</code> 的时候，现将其转换为二进制，得到的结果也是二进制，然后再将其转换为十进制<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</div><div class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</div><div class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></div></pre></td></tr></table></figure></p>
<p>计算结果 <code>0.0100110011001100110011001100110011001100110011001100111</code> 转换成十进制，就是 <code>0.30000000000000004</code>，这就导致出现了误差。</p>
<p>遇到浮点数误差问题时可以直接使用 <a href="https://github.com/dt-fe/number-precision/blob/master/src/index.js" target="_blank" rel="external">dt-fe/number-precision</a> 完美支持浮点数的加减乘除、四舍五入等运算。</p>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据浮点数算术标准，指数位最大值为 2047，E = 2047 -1023 = 1024，所以 <strong>JavaScript 能表示的数值范围是：<code>[-(2^1024-1), +(2^1024-1)]</code>，即：正负1.7976931348623157乘以10的308次方</strong>，注意：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.pow<span class="function"><span class="params">(<span class="number">2</span>, <span class="number">1023</span>)</span></span></div><div class="line">-&gt; <span class="number">8.98846567431158e+307</span></div><div class="line"></div><div class="line">Math.pow<span class="function"><span class="params">(<span class="number">2</span>, <span class="number">1024</span>)</span></span></div><div class="line">-&gt; Infinity</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ul>
<li><code>Number.MIN_VALUE</code> 属性表示在 JavaScript 中所能表示的最小的正值<ul>
<li>值为 5e-324</li>
<li>MIN_VALUE 属性是 JavaScript 里最接近 0 的正值，而不是最小的负值</li>
<li>小于 MIN_VALUE 的值将会转换为 0</li>
</ul>
</li>
<li><code>Number.MAX_VALUE</code> 属性表示在 JavaScript 里所能表示的最大数值<ul>
<li>值为 1.7976931348623157e+308</li>
<li>大于 MAX_VALUE 的值代表 “Infinity”</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 规定能安全的表示数字(进行精确算术运算)的范围在 ：<code>[-2^53, +2^53]</code>，即正负2的53次方</strong>；对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的准确性，这也是 JavaScript 中安全整数的两个边界：<code>Number.MIN_SAFE_INTEGER</code> 和 <code>Number.MAX_SAFE_INTEGER</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.MIN_SAFE_INTEGER</div><div class="line"><span class="meta">-&gt;</span><span class="bash"> -9007199254740991</span></div><div class="line"></div><div class="line">Number.MAX_SAFE_INTEGER</div><div class="line"><span class="meta">-&gt;</span><span class="bash"> 9007199254740991</span></div></pre></td></tr></table></figure></p>
<p>超过安全整数范围的，计算不保证正确，例如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>)</div><div class="line">-&gt; <span class="number">9007199254740992</span></div><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></div><div class="line">-&gt; <span class="number">9007199254740992</span></div><div class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></div><div class="line">-&gt; <span class="number">9007199254740994</span></div></pre></td></tr></table></figure></p>
<p>对于不在 <code>[-2^53, +2^53]</code> 范围中的数字，例如 (2^53, 2^63) 之间的数会出现什么情况呢？</p>
<ul>
<li>(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数</li>
<li>(2^54, 2^55) 之间的数会四个选一个，只能精确表示4的倍数</li>
<li>… 依次跳过更多2的倍数</li>
</ul>
<p>下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系，我们常用的 <code>[-2^53, 2^53]</code> 只是最中间非常小的一部分，越往两边越稀疏越不精确。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/real-numbers-floating-point-numbers.jpeg" alt=""></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="external">JavaScript 浮点数陷阱及解法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-brjYnVlXwM3j_SWXImT0Rg.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;JavaScript中所有的数字，无论是整数还是小数，其类型都是 Number，遵循 &lt;a href=&quot;http://grouper.ieee.org/groups/754/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IEEE 754&lt;/a&gt; 程序内部用一个 64 位固定长度的二进制进行存储表示。JavaScript 中的浮点数进行运算时，经常会遇到计算精度问题，例如经典的 &lt;code&gt;0.1+0.2=0.30000000000000004&lt;/code&gt;，本文将探究 JavaScript 的浮点数，并解释为何 &lt;code&gt;0.1+0.2=0.30000000000000004&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="float-point" scheme="http://objcer.com/tags/float-point/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中何时加分号❓</title>
    <link href="http://objcer.com/2017/10/13/hacking-semicolons/"/>
    <id>http://objcer.com/2017/10/13/hacking-semicolons/</id>
    <published>2017-10-13T02:06:47.000Z</published>
    <updated>2017-10-16T09:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读 medium 上的文章 <a href="https://codeburst.io/javascript-async-await-with-foreach-b6ba62bbf404" target="_blank" rel="external">JavaScript: async/await with forEach()</a> 时，作者用了如下一个例子来阐述：async/await 和 forEach 之间的问题。但是仔细琢磨这段代码，发现不对劲啊 😤 明显和我之前的认知不同啊。本文将分析一下其中的蹊跷。</p>
<blockquote>
<p>关于 async/await 和 forEach，我在 <a href="https://objcer.com/2017/10/12/async-await-with-forEach/">当 async/await 遇上 forEach</a> 文中进行了详细分析，读者若对此不熟悉，请先前往了解 👉</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>当 async/await 遇上 forEach，无非就是将回调的异步函数，全部并行执行了，而非我们期望的串行执行。那么对于这段代码，正常的输出结果是：输出：<code>Done</code>，间隔 50 毫秒，输出：1，2，3；但是实际却只输出了 <code>Done</code>，所以我们可以断定这段代码有问题。</p>
<h3 id="考虑箭头函数的问题"><a href="#考虑箭头函数的问题" class="headerlink" title="考虑箭头函数的问题"></a>考虑箭头函数的问题</h3><p>一开始我把目光放到箭头函数上，箭头函数 <code>waitFor</code> 返回一个 Promise 对象， 把箭头函数返回改造成如下，发现，执行结果正确了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms))&#125;</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure></p>
<p>然后，在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">MDN - Arrow functions</a> 发现：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Parenthesize the <span class="keyword">body</span> <span class="keyword">of</span> <span class="keyword">function</span> <span class="title">to</span> <span class="keyword">return</span> <span class="type">an</span> object literal expression:</div><div class="line">params =&gt; (&#123;foo: bar&#125;)</div></pre></td></tr></table></figure></p>
<p>指箭头函数返回对象字面量时，需要用括号包起来。对于如下函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        square: n * n</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以改写成箭头函数如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; &#123; squa<span class="symbol">re:</span> <span class="built_in">n</span> * <span class="built_in">n</span> &#125;</div></pre></td></tr></table></figure></p>
<p>此时调用 <code>square</code> 函数，会发现，无论传入什么参数都没有任何输出，为啥呢？</p>
<p>JavaScript 在解析 <code>square</code> 函数时，遇到 <code>{ square: n * n }</code>，并不是认为其是一个对象字面量，而把它解析成 <code>Labelled Block Statement</code>，label 为 <code>square</code>，statement 为 <code>n * n</code>；由于没有返回值，执行 <code>square</code> 函数会一直返回 undefined，如果返回 <code>n * n</code> 那么代码也可正常执行<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; &#123; squa<span class="symbol">re:</span> return <span class="built_in">n</span> * <span class="built_in">n</span> &#125;</div></pre></td></tr></table></figure></p>
<p>显然这样的代码太奇怪了，最简单的方式是用括号将对象字面量包起来，这样，JavaScript 在解析的时候遇到括号，就不会将 <code>{ square: n * n }</code> 认为是 <code>Labelled Block Statement</code> 了，而是对象字面量，如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> square = <span class="built_in">n</span> =&gt; (&#123; squa<span class="symbol">re:</span> <span class="built_in">n</span> * <span class="built_in">n</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>但是，但是，我们分析的这段代码中 <code>waitFor</code> 箭头函数返回的是 Promise 对象，并非对象字面量，所以并不是箭头函数的锅啊。</p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>我们看到如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="string">'b'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</div><div class="line">[<span class="string">'b'</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(v)&#125;)  <span class="comment">// 输出： 1, 2, 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;</div><div class="line">[<span class="string">'b'</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(v)&#125;) <span class="comment">// 出错：Uncaught TypeError: &#123;(intermediate value)&#125;.b.forEach is not a function</span></div></pre></td></tr></table></figure></p>
<p>显然 JavaScript 在代码解析的时候，第一行和第二行没有分开啊，我们可以加上分号，这样代码就正常执行了。<br>我们分析的这段代码，在 <code>waitFor</code> 箭头函数后加上分号，代码也就正确执行了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> waitFor = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> setTimeout(r, ms));</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="keyword">async</span> (num) =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> waitFor(<span class="number">50</span>)</div><div class="line">  <span class="built_in">console</span>.log(num)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>)</div></pre></td></tr></table></figure></p>
<p>这是为啥呢？似乎在我们的印象中，JavaScript 是可以忽略分号的，莫非有特殊情况。在知乎问题： <a href="https://www.zhihu.com/question/20298345/answer/49551142" target="_blank" rel="external">JavaScript 语句后应该加分号么？</a> 中，我们发现：</p>
<blockquote>
<p>👉 <strong>真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。</strong>我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：<strong>一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。</strong></p>
</blockquote>
<p>也即是在 <code>+ - [ ( /</code> 这五个字符开头时，需要在上一行或者当前行首加上分号，避免 JavaScript 上下行解析出错。</p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>medium 的作者不小心踩了一个坑，少写了一个分号，导致 JavaScript 上下文解析出错，写了一个不恰当的例子，通过一步步分析，还是找到了问题的本质，也算是涨姿势了😋</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.mariusschulz.com/2015/06/09/returning-object-literals-from-arrow-functions-in-javascript" target="_blank" rel="external">Returning Object Literals from Arrow Functions in JavaScript</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读 medium 上的文章 &lt;a href=&quot;https://codeburst.io/javascript-async-await-with-foreach-b6ba62bbf404&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript: async/await with forEach()&lt;/a&gt; 时，作者用了如下一个例子来阐述：async/await 和 forEach 之间的问题。但是仔细琢磨这段代码，发现不对劲啊 😤 明显和我之前的认知不同啊。本文将分析一下其中的蹊跷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 async/await 和 forEach，我在 &lt;a href=&quot;https://objcer.com/2017/10/12/async-await-with-forEach/&quot;&gt;当 async/await 遇上 forEach&lt;/a&gt; 文中进行了详细分析，读者若对此不熟悉，请先前往了解 👉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; waitFor = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;ms&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;r&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(r, ms))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].forEach(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; (num) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; waitFor(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Done&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>当 async/await 遇上 forEach</title>
    <link href="http://objcer.com/2017/10/12/async-await-with-forEach/"/>
    <id>http://objcer.com/2017/10/12/async-await-with-forEach/</id>
    <published>2017-10-12T08:28:38.000Z</published>
    <updated>2017-10-12T08:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章 <a href="https://objcer.com/2017/10/11/Async-Await/">ES7 中的 async await</a> 中介绍了 async/await。本文将分析介绍当 async/await 遇上 <code>forEach</code> 出现的一些问题和解决方案。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-pWGJIKats-zuumA3RQNEWQ.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getNumbers = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> multi = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (num) &#123;</div><div class="line">        resolve(num * num)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'num not specified'</span>))</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  nums.forEach(<span class="keyword">async</span> x =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test()</div></pre></td></tr></table></figure>
<p>在这个例子中，通过 <code>forEach</code> 遍历的将每一个数字都执行 <code>multi</code> 操作。代码执行的结果是：1 秒后，一次性输出1，4，9。这个结果和我们的预期有些区别，我们是希望每间隔 1 秒，然后依次输出 1，4，9；所以当前代码应该是并行执行了，而我们期望的应该是串行执行。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="JavaScript-中的循环数组遍历"><a href="#JavaScript-中的循环数组遍历" class="headerlink" title="JavaScript 中的循环数组遍历"></a>JavaScript 中的循环数组遍历</h3><p>在 JavaScript 中提供了如下四种循环遍历数组元素的方式：</p>
<ul>
<li><p><code>for</code><br>这是循环遍历数组元素最简单的方式</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">  console.log(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>for-in</code><br><code>for-in</code> 语句以任意顺序遍历一个对象的可枚举属性，对于数组即是数组下标，对于对象即是对象的 key 值。注意 <code>for-in</code> 遍历返回的对象属性都是字符串类型，即使是数组下标，也是字符串 “0”, “1”, “2” 等等。<em>[不推荐使用 <code>for-in</code> 语句]</em></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">index</span> <span class="keyword">in</span> myArray) &#123;</div><div class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>forEach</code><br><code>forEach</code> 方法用于调用数组的每个元素，并将元素传递给回调函数；注意在回调函数中无法使用 <code>break</code> 跳出当前循环，也无法使用 <code>return</code> 返回值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myArray.forEach(<span class="function"><span class="keyword">function</span></span> (<span class="keyword">value</span>) &#123;</div><div class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>for-of</code><br><code>for-of</code> 语句为各种 collection 集合对象专门定制的，遍历集合对象的属性值，注意和 <code>for-in</code> 的区别</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">value</span> <span class="keyword">of</span> myArray) &#123;</div><div class="line">  console.log(<span class="keyword">value</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>在本例中 <code>forEach</code> 的回调函数是一个异步函数，异步函数中包含一个 <code>await</code> 等待 Promise 返回结果，我们期望数组元素串行执行这个异步操作，但是实际却是并行执行了。</p>
<p><code>forEach</code> 的 polyfill 参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">MDN-Array.prototype.forEach()</a>，简单点理解：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Array.prototype.forEach = function (callback) &#123;</div><div class="line">  <span class="comment">// this represents our array</span></div><div class="line">  <span class="keyword">for</span> (let <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="keyword">this</span>.length; <span class="keyword">index</span>++) &#123;</div><div class="line">    <span class="comment">// We call the callback for each entry</span></div><div class="line">    callback(<span class="keyword">this</span>[<span class="keyword">index</span>], <span class="keyword">index</span>, <span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于 <code>for</code> 循环执行了这个异步函数，所以是并行执行，导致了一次性全部输出结果：1，4，9<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line"><span class="comment">//   nums.forEach(async x =&gt; &#123;</span></div><div class="line"><span class="comment">//     var res = await multi(x)</span></div><div class="line"><span class="comment">//     console.log(res)</span></div><div class="line"><span class="comment">//   &#125;)</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; nums.length; index++) &#123;</div><div class="line">    (<span class="keyword">async</span> x =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">      <span class="built_in">console</span>.log(res)</div><div class="line">    &#125;)(nums[index])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>我们可以改造一下 <code>forEach</code>，确保每一个异步的回调执行完成后，才执行下一个<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncForEach</span>(<span class="params">array, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</div><div class="line">    <span class="keyword">await</span> callback(array[index], index, array)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  asyncForEach(nums, <span class="keyword">async</span> x =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用 <code>for-of</code> 替代 <code>for-each</code>。</p>
<p><code>for-of</code> 可以遍历各种集合对象的属性值，要求被遍历的对象需要实现迭代器 (iterator) 方法，例如 <code>myObject[Symbol.iterator]()</code> 用于告知 JS 引擎如何遍历该对象。一个拥有 <code>[Symbol.iterator]()</code> 方法的对象被认为是可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zeroesForeverIterator = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如上就是一个最简单的迭代器对象；<code>for-of</code> 遍历对象时，先调用遍历对象的迭代器方法 <code>[Symbol.iterator]()</code>，该方法返回一个迭代器对象(迭代器对象中包含一个 <code>next</code> 方法)；然后调用该迭代器对象上的 <code>next</code> 方法。</p>
<p>每次调用 <code>next</code> 方法都返回一个对象，其中 <code>done</code> 和 <code>value</code> 属性用来表示遍历是否结束和当前遍历的属性值，当 <code>done</code> 的值为 <code>true</code> 时，遍历就停止了。</p>
<figure class="highlight cal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">VAR</span> <span class="keyword">of</span> ITERABLE) &#123;</div><div class="line">  STATEMENTS</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var</span> <span class="variable">$iterator</span> = ITERABLE[Symbol.iterator]();</div><div class="line"><span class="attribute">var</span> <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</div><div class="line"><span class="attribute">while</span> (!<span class="variable">$result</span>.done) &#123;</div><div class="line">  <span class="attribute">VAR</span> = <span class="variable">$result</span>.value;</div><div class="line">  <span class="attribute">STATEMENTS</span></div><div class="line">  <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可以知道 <code>for-of</code> 和 <code>forEach</code> 遍历元素时处理的方式是不同的。使用 <code>for-of</code> 替代 <code>for-each</code> 后代码为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nums = <span class="keyword">await</span> getNumbers()</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> nums) &#123;</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">await</span> multi(x)</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://codeburst.io/understand-async-await-better-7a03aeba60fe" target="_blank" rel="external">Understand async/await better</a><br><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">ES6 In Depth: Iterators and the for-of loop</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章 &lt;a href=&quot;https://objcer.com/2017/10/11/Async-Await/&quot;&gt;ES7 中的 async await&lt;/a&gt; 中介绍了 async/await。本文将分析介绍当 async/await 遇上 &lt;code&gt;forEach&lt;/code&gt; 出现的一些问题和解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-pWGJIKats-zuumA3RQNEWQ.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="async" scheme="http://objcer.com/tags/async/"/>
    
      <category term="await" scheme="http://objcer.com/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>ES7 中的 async await</title>
    <link href="http://objcer.com/2017/10/11/Async-Await/"/>
    <id>http://objcer.com/2017/10/11/Async-Await/</id>
    <published>2017-10-11T06:36:46.000Z</published>
    <updated>2017-10-11T09:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中处理异步操作的回调 (callback) 通常会导致多嵌套的代码块，俗称回调地狱 (callback hell)，这样的代码复杂，可读性，可维护性非常不友好；直达 ES6，Promise 出现，使得我们能够扁平化回调函数，告别回调地狱，写出优雅的代码；但是在实践中发现，Promise 并不完美，如果 Promise 的回调中出现嵌套，依旧会出现回调地狱；而如今，async await 出现了，它提供了一种新的编写异步代码方式，使得异步代码看起来像是同步代码，这正式它的魔力所在。</p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-ko3KtcVSlzpe3RnTRgJaHw.jpeg" alt=""></p>
<a id="more"></a>
<h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// async <span class="function"><span class="keyword">function</span></span> statement：async <span class="function"><span class="keyword">function</span></span> 声明语句</div><div class="line">async <span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>([param[, param[, ... param]]]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div><div class="line"></div><div class="line">// async <span class="function"><span class="keyword">function</span></span> expression：async <span class="function"><span class="keyword">function</span></span> 表达式</div><div class="line">async <span class="function"><span class="keyword">function</span></span> [<span class="keyword">name</span>]([param1[, param2[, ..., paramN]]]) &#123;</div><div class="line">   statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，可以通过 async function 声明语句或者表达式来定义一个异步函数，返回一个 <code>AsyncFunction</code> 对象，二者的区别在于在于函数名称，async function 表达式可以省略函数名称来创建一个匿名的函数。</p>
<p><strong>调用异步函数时会返回一个 promise 对象</strong></p>
<ul>
<li>当这个异步函数返回一个值时，promise 的 resolve 方法将会处理这个返回值</li>
<li>当异步函数抛出异常或者非法值时，promise 的 reject 方法将处理这个异常值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ok'</span></div><div class="line">  <span class="comment">// throw new Error('error')</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error)</div></pre></td></tr></table></figure>
<h2 id="AsyncFunction"><a href="#AsyncFunction" class="headerlink" title="AsyncFunction"></a><code>AsyncFunction</code></h2><blockquote>
<p>注意，<code>AsyncFunction</code> 并不是一个全局对象，我们可以这样获得 <code>AsyncFunction</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).constructor</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>AsyncFunction</code> 构造函数用于创建一个新的 async function 对象，在 JavaScript 中，每一个异步函数都是一个 <code>AsyncFunction</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.constructor)</div><div class="line"><span class="comment">// -&gt; ƒ AsyncFunction() &#123; [native code] &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.__proto__)</div><div class="line"><span class="comment">// -&gt; AsyncFunction &#123;Symbol(Symbol.toStringTag): "AsyncFunction", constructor: ƒ&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> AsyncFunction = <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).constructor</div><div class="line"><span class="keyword">var</span> asyncFun = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(asyncFun <span class="keyword">instanceof</span> AsyncFunction) <span class="comment">// -&gt; true</span></div></pre></td></tr></table></figure></p>
<p>通过 <code>AsyncFunction</code> 构造函数创建异步函数的语法如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new AsyncFunction(<span class="comment">[arg1<span class="comment">[, arg2<span class="comment">[, ...argN]</span>]</span>,]</span> functionBody)</div></pre></td></tr></table></figure></p>
<p>把 <code>AsyncFunction</code> 当成函数调用（省略 <code>new</code> 操作符）也可创建异步函数，如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var AsyncFunction = Object.getPrototypeOf(async function () &#123;&#125;).constructor<span class="comment">;</span></div><div class="line">// var <span class="function"><span class="keyword">func</span> = <span class="title">new</span> <span class="title">AsyncFunction</span><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>)</span></span></div><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">AsyncFunction</span><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>.<span class="title">then</span><span class="params">(console.log)</span> // -&gt; 3</span></div></pre></td></tr></table></figure>
<p>👉 通过 <code>AsyncFunction</code> 构造函数创建的异步函数 在当前上下文不创建闭包；而是在全局作用域创建的。而且只需效率比用 async function 声明语句或者表达式来定义一个异步函数要低，所以一般情况使用 async function 声明语句或者表达式来定义一个异步函数。</p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a><code>await</code></h2><p><code>await</code> 操作符用于等待一个 Promise 返回结果或者某个直接的值，且 <code>await</code> 必须在异步函数 (async function) 上下文中使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnPromise</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    resolve(a)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnValue</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// var a = await returnPromise(2)</span></div><div class="line">  <span class="keyword">var</span> a = <span class="keyword">await</span> returnValue(<span class="number">3</span>)</div><div class="line">  <span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error)</div></pre></td></tr></table></figure></p>
<p>异步函数中执行 <code>await</code> 表达式，这将会使异步函数暂停执行并等待 promise 解析传值后，继续执行异步函数并返回解析值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">second</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, second * <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</div><div class="line">  <span class="keyword">await</span> sleep(<span class="number">3</span>)</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</div><div class="line">&#125;</div><div class="line"></div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>代码执行结果：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Wed Oct <span class="number">11</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">32</span> GMT+<span class="number">0800</span> (CST)</div><div class="line">Promise &#123;<span class="string">[[PromiseStatus]]</span>: <span class="string">"pending"</span>, <span class="string">[[PromiseValue]]</span>: undefined&#125;</div><div class="line">Wed Oct <span class="number">11</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">35</span> GMT+<span class="number">0800</span> (CST)</div></pre></td></tr></table></figure></p>
<p><code>await</code> 串行，并行执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve.bind(<span class="literal">null</span>, a * a), <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 串行执行</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> x = <span class="keyword">await</span> multi(<span class="number">2</span>)</div><div class="line">   <span class="keyword">var</span> y = <span class="keyword">await</span> multi(<span class="number">3</span>)</div><div class="line">   <span class="keyword">return</span> [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 并行执行</span></div><div class="line"><span class="comment">// async function test () &#123;</span></div><div class="line"><span class="comment">//    var res = await Promise.all([multi(2), multi(3)])</span></div><div class="line"><span class="comment">//    return res</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line">test().then(<span class="built_in">console</span>.log)</div></pre></td></tr></table></figure></p>
<h2 id="async-await-的优势"><a href="#async-await-的优势" class="headerlink" title="async await 的优势"></a>async await 的优势</h2><p>Promise 有了 async await 的辅助，使其发挥更大的威力，通过 async await 终于可以彻底摆脱回调地狱，以同步方式编写异步代码，代码简洁，十分友好，下面举几个例子 👇</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>try-catch</code> 处理同步，异步错误。如下代码片段一中，<code>try-catch</code> 并不能捕捉 <code>then</code> 方法中 <code>JSON.parse</code> 异常出错；但是在代码片段二中，使用了 async await，使得 <code>try-catch</code> 能捕捉 <code>JSON.parse</code> 可能的异常出错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码块一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    getJSON().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(res) <span class="comment">// 此处可能出错</span></div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代码块二</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> getJSON())</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="中间值"><a href="#中间值" class="headerlink" title="中间值"></a>中间值</h3><p>有时会遇到这样的情形：promise1 返回值 value1；promise2 依赖 value1，返回value2；promise3 依赖 value1 和 value2。最简单的做法是通过嵌套解决 promise 间的依赖：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> test () &#123;</div><div class="line">  <span class="keyword">return</span> promise<span class="number">1</span>()</div><div class="line">      .<span class="keyword">then</span>(<span class="keyword">value</span><span class="number">1</span> =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> promise<span class="number">2</span>(valu<span class="number">1</span>)</div><div class="line">          .<span class="keyword">then</span>(<span class="keyword">value</span><span class="number">2</span> =&gt; &#123;</div><div class="line">              <span class="keyword">return</span> promise<span class="number">3</span>(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)</div><div class="line">          &#125;)</div><div class="line">      &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这种简单粗暴的处理方式使我们又掉进回调地狱了；我们可以通过中间变量来抹平这个回调嵌套：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> test () &#123;</div><div class="line">  var <span class="keyword">value</span><span class="number">1</span></div><div class="line">  var <span class="keyword">value</span><span class="number">2</span></div><div class="line">  <span class="keyword">return</span> promise<span class="number">1</span>()</div><div class="line">    .<span class="keyword">then</span>(vle =&gt; &#123;</div><div class="line">        <span class="keyword">value</span><span class="number">1</span> = vle</div><div class="line">        <span class="keyword">return</span> promise<span class="number">2</span>(<span class="keyword">value</span><span class="number">1</span>)</div><div class="line">    &#125;)</div><div class="line">    .<span class="keyword">then</span>(vle =&gt; &#123;</div><div class="line">        <span class="keyword">value</span><span class="number">2</span> = vle</div><div class="line">        <span class="keyword">return</span> promise<span class="number">3</span>(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而通过 async await，可以最优，最简洁的解决这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value1 = <span class="keyword">await</span> promise1()</div><div class="line">  <span class="keyword">var</span> value2 = <span class="keyword">await</span> promise2(value1)</div><div class="line">  <span class="keyword">return</span> promise3(value1, value2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>❗️注意，在上面代码的返回语句 promise3 并没有 <code>await</code>，因为异步函数的会将其返回值隐式封装在 <code>Promise.resolve</code> 中。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="external">MDN-AsyncFunction</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">MDN-async function</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="external">MDN-await</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中处理异步操作的回调 (callback) 通常会导致多嵌套的代码块，俗称回调地狱 (callback hell)，这样的代码复杂，可读性，可维护性非常不友好；直达 ES6，Promise 出现，使得我们能够扁平化回调函数，告别回调地狱，写出优雅的代码；但是在实践中发现，Promise 并不完美，如果 Promise 的回调中出现嵌套，依旧会出现回调地狱；而如今，async await 出现了，它提供了一种新的编写异步代码方式，使得异步代码看起来像是同步代码，这正式它的魔力所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-ko3KtcVSlzpe3RnTRgJaHw.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="async" scheme="http://objcer.com/tags/async/"/>
    
      <category term="await" scheme="http://objcer.com/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X 环绕刘海滚动列表</title>
    <link href="http://objcer.com/2017/10/10/iPhone-X-notch-surround-list/"/>
    <id>http://objcer.com/2017/10/10/iPhone-X-notch-surround-list/</id>
    <published>2017-10-10T07:33:27.000Z</published>
    <updated>2017-10-10T09:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>iPhone X 面市后，其异形屏给交互设计提供了更多想象的空间。在 Twitter 上，这位推友就针对刘海设计了列表环绕刘海滚动的效果。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/4E124A83-5DD5-44C1-AA71-9394E34E8C57.png" alt=""></p>
<p>最近在 codepen 上看到已经有人实现了这个 demo：<a href="https://codepen.io/davvidbaker/pen/KXgPyG" target="_blank" rel="external">https://codepen.io/davvidbaker/pen/KXgPyG</a>，本文将图文结合分析一下实现这个效果的逻辑。</p>
<a id="more"></a>
<h2 id="DOM-结构"><a href="#DOM-结构" class="headerlink" title="DOM 结构"></a>DOM 结构</h2><p><img src="http://7vikhl.com1.z0.glb.clouddn.com/D75661B5-C160-4906-826D-E7908AA9B237.png" alt=""><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"notch"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>DOM 结构比较简单，主要包括列表 <code>ul</code>，其滚动容器为 <code>class=&quot;inner&quot;</code> 的 DIV；刘海是 <code>class=&quot;notch&quot;</code> 的 DIV。</p>
<h2 id="滚动逻辑"><a href="#滚动逻辑" class="headerlink" title="滚动逻辑"></a>滚动逻辑</h2><p>为了实现列表环绕刘海滚动，需要在滚动事件中，计算处理每一行列表 X 轴方向的位置移动。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/840F60D8-1D25-4B1C-BF50-C9F79DCC2AC9.png" alt=""></p>
<p>如上图列表向下滚动，上方的列表需要向右位移 <code>notch</code> 宽度；对应的，下方的列表需要向左位移 <code>notch</code> 宽度。我们需要对移动进行相应的计算处理，使位移线性变化，从而在滚动时，环绕效果自然。</p>
<h3 id="distFromTop-和-distFromBottom"><a href="#distFromTop-和-distFromBottom" class="headerlink" title="distFromTop 和 distFromBottom"></a><code>distFromTop</code> 和 <code>distFromBottom</code></h3><p>列表在上下滚动过程中分为两部分：</p>
<ul>
<li>向下滚动：上方列表向右移动进入刘海区域，下方列表向左移动离开刘海区域</li>
<li>向上滚动：上方列表向左移动离开刘海区域，下方列表向右移动进入刘海区域</li>
</ul>
<p>这两部分刚好是相对应的，此处我们只分析<strong>上方列表移动进入/离开刘海区域</strong>，即可以了解滚动过程中的逻辑处理。首先介绍两个变量：<code>distFromTop</code> 和 <code>distFromBottom</code></p>
<blockquote>
<p><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置，返回值是一个 <code>DOMRect</code> 对象。<code>DOMRect</code> 对象包含了一组用于描述边框的只读属性 —— left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的，如下图：<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/F772D60E-E17B-434F-A970-053BB77E53BB.png" alt=""></p>
</blockquote>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notchRect = notch.getBoundingClientRect()</div><div class="line"><span class="keyword">let</span> itemRect = item.getBoundingClientRect()</div><div class="line"><span class="keyword">let</span> distFromTop = itemRect.<span class="built_in">bottom</span> - notchRect.<span class="built_in">top</span></div><div class="line"><span class="keyword">let</span> distFromBottom = itemRect.<span class="built_in">top</span> - notchRect.<span class="built_in">bottom</span></div></pre></td></tr></table></figure>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/CB366BB3-C658-4514-96F7-103F5B712AD6.png" alt=""></p>
<p>这两个变量表征当前这一行列表距离上下刘海边界的位置，在滚动过程中根据 <code>distFromTop</code> 和 <code>distFromBottom</code> 变量触发不同的位移逻辑。</p>
<h3 id="位移逻辑"><a href="#位移逻辑" class="headerlink" title="位移逻辑"></a>位移逻辑</h3><p>分析<strong>上方列表移动进入/离开刘海区域</strong>时，列表位移的逻辑。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/7B8867D1-1A5E-4DE6-A6CB-5B64209808F2.png" alt=""><br><img src="http://7vikhl.com1.z0.glb.clouddn.com/E875669C-BEBE-4B6E-A883-EACF4CF29D63.png" alt=""></p>
<p>1️⃣ <strong>阈值：<code>Threshold</code></strong><br>在刘海边界上下 <code>Threshold</code> 区域定义为位移区域，列表进入这一区域即需要进行计算位移量，检测是否进入这一区域的逻辑判断为：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.<span class="keyword">abs</span>(distFromTop) &lt;= Threshold</div></pre></td></tr></table></figure></p>
<p>2️⃣ <strong>计算位移量</strong><br>考虑两个边界情况：</p>
<ul>
<li>当 <code>distFromTop</code> 等于 <code>- Threshold</code>，即列表开始进入刘海区域<br>此时位移量为 0</li>
<li>当 <code>distFromTop</code> 等于 <code>+ Threshold</code>，即列表完全进入刘海区域<br>此时位移量为刘海宽度 <code>NotchWidth</code></li>
</ul>
<p>这个变换过程可以通过线性插值来完成，根据 <code>distFromTop</code> 变量计算在 Y 轴方向的比例关系，从而得到 X 轴方向的位移量。</p>
<blockquote>
<p>关于线性插值参考：<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC" target="_blank" rel="external">维基百科：线性插值</a></p>
</blockquote>
<p>在此处，我们可以简化理解，如下图<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/94A6750A-B927-4B11-8446-8F92DCFA7747.png" alt=""></p>
<p>计算公式如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let lerp = (<span class="name">v0</span>, v1, <span class="literal">t</span>) =&gt; v0 + (<span class="name">v1</span> - v0) * <span class="literal">t</span></div></pre></td></tr></table></figure></p>
<p>在我们分析的这个情形：上方列表向右移动进入刘海区域，对应的调用为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = lerp(<span class="number">0</span>, NotchWidth, (<span class="name">distFromTop</span> + Threshold) / (<span class="name">Threshold</span> * 2))</div></pre></td></tr></table></figure></p>
<p>其他情况，位移量计算分别为：</p>
<ul>
<li>在刘海区域内滚动<br>判断条件：<code>distFromTop &gt; 0 &amp;&amp; distFromBottom &lt; - Threshold</code><br>位移量始终为：刘海宽度 <code>NotchWidth</code></li>
<li>下方列表移动进入/离开刘海区域<br>判断条件：<code>Math.abs(distFromBottom) &lt;= Threshold</code><br>位移量始终为：<code>x = lerp(NotchWidth, 0, (distFromBottom + Threshold) / (Threshold * 2))</code></li>
<li>其他<br>位移量始终为：0</li>
</ul>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>最终实现效果：<a href="https://codepen.io/yingshandeng/pen/JrJRBR?editors=1010" target="_blank" rel="external">https://codepen.io/yingshandeng/pen/JrJRBR?editors=1010</a></p>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/iPhone%20X%20list.gif" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-tag">html</span>,</div><div class="line">  <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">display</span>: flex;</div><div class="line">      <span class="attribute">justify-content</span>: center;</div><div class="line">      <span class="attribute">align-items</span>: center;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#E3F3FD</span>;</div><div class="line">      <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>, Helvetica, Arial, sans-serif;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.outer</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">640px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">310px</span>;</div><div class="line">    <span class="attribute">min-width</span>: <span class="number">640px</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">310px</span>;</div><div class="line">    <span class="attribute">background-color</span>: white;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">45px</span>;</div><div class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.10),</div><div class="line">      inset <span class="number">0</span> -<span class="number">5px</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.08);</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.10),</div><div class="line">      inset <span class="number">0</span> -<span class="number">5px</span> <span class="number">20px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0, 0, 0, 0.08);</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.inner</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">610px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">280px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#EBEBEB</span>;</div><div class="line">    <span class="attribute">overflow-x</span>: hidden;</div><div class="line">    <span class="attribute">overflow-y</span>: scroll;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.notch</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">15px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">79px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">22px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">152px</span>;</div><div class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">17px</span>;</div><div class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">17px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#dadada</span>;</div><div class="line">    <span class="attribute">transform-origin</span>: center left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  *<span class="selector-pseudo">::-webkit-scrollbar</span> &#123;</div><div class="line">    <span class="attribute">visibility</span>: hidden;</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>天津<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>山西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>内蒙古<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>辽宁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>吉林<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>江苏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>浙江省<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>福建<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>江西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>山东<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>湖北<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>湖南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>广西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>海南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>重庆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>四川<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>贵州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>云南<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>西藏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>陕西<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>甘肃省<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>青海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>宁夏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>新疆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>台湾<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>香港特别行政区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>澳门<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"notch"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">let</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>)</div><div class="line">  <span class="keyword">let</span> items = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</div><div class="line">  <span class="keyword">let</span> notch = <span class="built_in">document</span>.querySelector(<span class="string">'.notch'</span>)</div><div class="line">  <span class="keyword">let</span> notchRect = notch.getBoundingClientRect()</div><div class="line"></div><div class="line">  inner.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">window</span>.requestAnimationFrame(scrollDection)</div><div class="line">  &#125;)</div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</div><div class="line">    notchRect = notch.getBoundingClientRect()</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Threshold = <span class="number">10</span></div><div class="line">  <span class="keyword">const</span> NotchWidth = <span class="number">30</span></div><div class="line">  <span class="keyword">let</span> scrollDection = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> item</div><div class="line">    <span class="keyword">for</span> (item <span class="keyword">of</span> items) &#123;</div><div class="line">      <span class="keyword">let</span> itemRect = item.getBoundingClientRect()</div><div class="line">      <span class="keyword">let</span> distFromTop = itemRect.bottom - notchRect.top</div><div class="line">      <span class="keyword">let</span> distFromBottom = itemRect.top - notchRect.bottom</div><div class="line">      <span class="keyword">let</span> x</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(distFromTop) &lt;= Threshold) &#123;</div><div class="line">        x = lerp(<span class="number">0</span>, NotchWidth, (distFromTop + Threshold) / (Threshold * <span class="number">2</span>))</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distFromTop &gt; <span class="number">0</span> &amp;&amp; distFromBottom &lt; - Threshold) &#123;</div><div class="line">        x = NotchWidth</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(distFromBottom) &lt;= Threshold) &#123;</div><div class="line">        x = lerp(NotchWidth, <span class="number">0</span>, (distFromBottom + Threshold) / (Threshold * <span class="number">2</span>))</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        x = <span class="number">0</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      item.style.transform = <span class="string">`translateX(<span class="subst">$&#123;x&#125;</span>px)`</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> lerp = <span class="function">(<span class="params">v0, v1, t</span>) =&gt;</span> v0 + (v1 - v0) * t</div><div class="line"></div><div class="line">  scrollDection()</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iPhone X 面市后，其异形屏给交互设计提供了更多想象的空间。在 Twitter 上，这位推友就针对刘海设计了列表环绕刘海滚动的效果。&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/4E124A83-5DD5-44C1-AA71-9394E34E8C57.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在 codepen 上看到已经有人实现了这个 demo：&lt;a href=&quot;https://codepen.io/davvidbaker/pen/KXgPyG&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://codepen.io/davvidbaker/pen/KXgPyG&lt;/a&gt;，本文将图文结合分析一下实现这个效果的逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="DEMO" scheme="http://objcer.com/tags/DEMO/"/>
    
  </entry>
  
  <entry>
    <title>实现一个字数限制的输入框</title>
    <link href="http://objcer.com/2017/10/10/implement-a-word-limit-input-box/"/>
    <id>http://objcer.com/2017/10/10/implement-a-word-limit-input-box/</id>
    <published>2017-10-10T07:24:25.000Z</published>
    <updated>2017-10-10T07:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/twitter-input-box.png" alt=""><br>在 Twitter 发推输入框中，有一个字数限制的逻辑，超出字数限制部分的文字会设置背景颜色提示，以便用户进行调整。这是一个很好的交互设计，在 <a href="https://ant.design/docs/spec/feature-cn" target="_blank" rel="external">Ant Design</a> 中也有提到这一点。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/ant-design-input.png" alt=""></p>
<p>本文将介绍如何实现这一字数限制输入框，效果访问：<a href="https://codepen.io/yingshandeng/pen/boRNLx" target="_blank" rel="external">Codepen</a><br><a id="more"></a></p>
<h2 id="超出限制文字设置背景提示"><a href="#超出限制文字设置背景提示" class="headerlink" title="超出限制文字设置背景提示"></a>超出限制文字设置背景提示</h2><p>实现这个输入框关键在于如何实现对超出字数限制部分的文字设置背景颜色，对于输入框一般有两种选择：</p>
<ul>
<li><code>textarea</code> 多行文本输入</li>
<li><code>div</code> 设置 <code>contenteditable=&quot;true&quot;</code></li>
</ul>
<p><code>contenteditable=&quot;true&quot;</code> 的 DIV 节点可以操作其中的 DOM 节点，那么我们可以监听输入区域，用户输入时，获取其中的 <code>innerText</code>，然后进行字数限制判断，设置其 <code>innerHTML</code>，划分两部分，超出部分设置背景颜色，代码大致如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">  文字，文字...</div><div class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>超出的文字...<span class="tag">&lt;/<span class="name">em</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> editorArea = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-area'</span>)</div><div class="line"></div><div class="line">  editorArea.addEventListener(<span class="string">'input'</span>, (evt) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> normalText;</div><div class="line">    <span class="keyword">var</span> exceedText;</div><div class="line"></div><div class="line">    editorArea.innerHTML = normalText + <span class="string">'&lt;em&gt;'</span> + exceedText + <span class="string">'&lt;/em&gt;'</span></div><div class="line">  &#125;)</div><div class="line">&lt;<span class="regexp">/script</span></div></pre></td></tr></table></figure></p>
<p>在每次输入后，都重新设置 <code>innerHTML</code>，会导致每次输入后，光标位置都跑到输入框起始位置了，看来这种方式不可行 😤</p>
<p>👉 解决方案：用两层 DIV 重叠</p>
<ul>
<li>上层 DIV 节点用于文字输入，背景颜色透明</li>
<li>下层 DIV 节点用于高亮超出部分文字，文字颜色设置为透明，超出部分节点设置背景颜色</li>
</ul>
<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/rich-input.png" alt=""></p>
<h2 id="输入框-placeholder"><a href="#输入框-placeholder" class="headerlink" title="输入框 placeholder"></a>输入框 placeholder</h2><p><code>contenteditable=&quot;true&quot;</code> 的 DIV 设置 placeholder 可以通过 CSS 来解决：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.editor-area</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</div><div class="line">  <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过选择器 <code>:empty</code> 判断输入框中内容是否为空，其实存在一些问题。点击回车的时候，会插入 <code>&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code> 或者 <code>&lt;br&gt;</code>，这部分会影响 <code>:empty</code> 的判断，譬如 DIV 中没有文字，但是存在一个换行时，这样 <code>:empty</code> 的判断就不会生效，placeholder 也就没有显示，所以我们可以通过另一种方式进行判断，通过 JS 手动添加、移除 class 类处理 placeholder 的显示和隐藏：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-class">.editor-area</span><span class="selector-class">.is-showPlaceholder</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: attr(placeholder);</div><div class="line">  <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JS</span></div><div class="line"><span class="selector-tag">editorArea</span><span class="selector-class">.addEventListener</span>(<span class="string">'input'</span>, (evt) =&gt; &#123;</div><div class="line">  <span class="selector-tag">if</span> (editorArea.innerHTML === <span class="string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> ||</div><div class="line">    editorArea.innerHTML === <span class="string">'&lt;br&gt;'</span> ||</div><div class="line">    editorArea.innerHTML === <span class="string">''</span>) &#123;</div><div class="line">    <span class="selector-tag">editorArea</span><span class="selector-class">.classList</span><span class="selector-class">.add</span>(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">  &#125; <span class="selector-tag">else</span> &#123;</div><div class="line">    <span class="selector-tag">editorArea</span><span class="selector-class">.classList</span><span class="selector-class">.remove</span>(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>还有一种解决方式，第一层输入 DIV 节点使用 <code>textarea</code> 替换，<code>textarea</code> 中有 <code>placeholder</code> 属性</p>
<h2 id="中文输入字数统计"><a href="#中文输入字数统计" class="headerlink" title="中文输入字数统计"></a>中文输入字数统计</h2><p>在中文输入是，中文还未输入到输入框，字数就在统计了；合理的是，中文输入 composing 组合过程中不应进行字数统计，在中文输入到输入框后，才进行字数统计。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/CCCDB51D-C8BD-4014-884B-C69A097F35C5.png" alt=""></p>
<p>解决这个问题需要用到 <code>compositionstart</code> 和 <code>compositionend</code> 这两个事件；前者表示输入组合开始，后者表示输入组合结束，在 <code>compositionend</code> 事件中就是我们字数统计的合理时机。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isComposing = <span class="literal">false</span></div><div class="line"></div><div class="line">editorArea.addEventListener(<span class="string">'compositionstart'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  isComposing = <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">editorArea.addEventListener(<span class="string">'compositionend'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  isComposing = <span class="literal">false</span></div><div class="line">  <span class="comment">// 字数统计</span></div><div class="line">  <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">  setCounter(limitCnt - text.length)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>🎏 如需考虑 emoji 字符长度计算的话，参考：<a href="https://objcer.com/2017/07/20/explore-emoji-length/">探究 emoji 字符长度</a></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>效果访问：<a href="https://codepen.io/yingshandeng/pen/boRNLx" target="_blank" rel="external">Codepen</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">html</span>,</div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">display</span>: flex;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#E3F3FD</span>;</div><div class="line">      <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>,Helvetica,Arial,sans-serif;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.rich-editor</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">508px</span>;</div><div class="line">      <span class="attribute">height</span>: auto;</div><div class="line">     <span class="comment">/* max-height: 134px;</span></div><div class="line">      overflow-y: scroll;*/</div><div class="line">      <span class="attribute">margin</span>: auto;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">8px</span>;</div><div class="line">      <span class="attribute">background</span>: <span class="number">#fff</span>;</div><div class="line">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</div><div class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#A4D9F9</span>;</div><div class="line">      <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">#A4D9F9</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.wrapper</span> &#123;</div><div class="line">      <span class="attribute">position</span>: relative;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">min-height</span>: <span class="number">116px</span>;</div><div class="line">      <span class="attribute">z-index</span>: <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span>, <span class="selector-class">.editor-backer</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">height</span>: auto;</div><div class="line">      <span class="attribute">min-height</span>: <span class="number">116px</span>;</div><div class="line"></div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">word-wrap</span>: break-word;</div><div class="line">      <span class="attribute">background</span>: transparent;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span> &#123;</div><div class="line">      <span class="attribute">outline</span>: none;</div><div class="line">      <span class="attribute">border</span>: none;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-area</span><span class="selector-class">.is-showPlaceholder</span><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">      <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</div><div class="line">      <span class="attribute">color</span>: <span class="number">#ccd6dd</span>;</div><div class="line">      <span class="attribute">position</span>: absolute;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-backer</span> &#123;</div><div class="line">      <span class="attribute">position</span>: absolute;</div><div class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">color</span>: transparent;</div><div class="line">      <span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.editor-backer</span> <span class="selector-tag">em</span> &#123;</div><div class="line">      <span class="attribute">background-color</span>: <span class="number">#ffb8c2</span>;</div><div class="line">      <span class="attribute">font-style</span>: normal;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">white-space</span>: pre-wrap;</div><div class="line">      <span class="attribute">word-wrap</span>: break-word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.counter</span> &#123;</div><div class="line">      <span class="attribute">float</span>: right;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#657786</span>;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">      <span class="attribute">text-align</span>: right;</div><div class="line">      <span class="attribute">user-select</span>: none;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.counter</span><span class="selector-class">.max-reached</span> &#123;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#e0245e</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rich-editor"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editor-area"</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">placeholder</span>=<span class="string">"Enter text here..."</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"editor-backer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"counter"</span>&gt;</span>140<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="keyword">var</span> editorArea = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-area'</span>)</div><div class="line">      <span class="keyword">var</span> editorBacker = <span class="built_in">document</span>.querySelector(<span class="string">'.editor-backer'</span>)</div><div class="line">      <span class="keyword">var</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>)</div><div class="line">      <span class="keyword">var</span> limitCnt = <span class="number">140</span></div><div class="line">      <span class="keyword">var</span> isComposing = <span class="literal">false</span></div><div class="line"></div><div class="line">      editorArea.addEventListener(<span class="string">'compositionstart'</span>, () =&gt; &#123;</div><div class="line">        isComposing = <span class="literal">true</span></div><div class="line">      &#125;)</div><div class="line">      editorArea.addEventListener(<span class="string">'compositionend'</span>, () =&gt; &#123;</div><div class="line">        isComposing = <span class="literal">false</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">        setCounter(limitCnt - text.length)</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setCounter</span> (<span class="params">cnt</span>) </span>&#123;</div><div class="line">        counter.innerHTML = cnt</div><div class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</div><div class="line">          counter.classList.add(<span class="string">'max-reached'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          counter.classList.remove(<span class="string">'max-reached'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">var</span> inputCompose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (editorArea.innerHTML === <span class="string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> ||</div><div class="line">          editorArea.innerHTML === <span class="string">'&lt;br&gt;'</span> ||</div><div class="line">          editorArea.innerHTML === <span class="string">''</span>) &#123;</div><div class="line">          editorArea.classList.add(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          editorArea.classList.remove(<span class="string">'is-showPlaceholder'</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> text = editorArea.innerText</div><div class="line">        <span class="keyword">let</span> remainingCnt = limitCnt - text.trim().length</div><div class="line">        <span class="keyword">if</span> (remainingCnt &lt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">let</span> allowedText = text.substring(<span class="number">0</span>, limitCnt)</div><div class="line">          <span class="keyword">let</span> refusedText = text.substring(limitCnt)</div><div class="line"></div><div class="line">          editorBacker.innerHTML = allowedText + <span class="string">'&lt;em&gt;'</span> + refusedText + <span class="string">'&lt;/em&gt;'</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          editorBacker.innerHTML = <span class="string">''</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isComposing) &#123;</div><div class="line">          setCounter(remainingCnt)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      inputCompose();</div><div class="line">      editorArea.oninput = inputCompose</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/twitter-input-box.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在 Twitter 发推输入框中，有一个字数限制的逻辑，超出字数限制部分的文字会设置背景颜色提示，以便用户进行调整。这是一个很好的交互设计，在 &lt;a href=&quot;https://ant.design/docs/spec/feature-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ant Design&lt;/a&gt; 中也有提到这一点。&lt;br&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/ant-design-input.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍如何实现这一字数限制输入框，效果访问：&lt;a href=&quot;https://codepen.io/yingshandeng/pen/boRNLx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="DEMO" scheme="http://objcer.com/tags/DEMO/"/>
    
  </entry>
  
  <entry>
    <title>动态文本自适应绘制到指定大小的 Canvas</title>
    <link href="http://objcer.com/2017/10/10/auto-size-dynamic-text-to-fill-fixed-size-canvas/"/>
    <id>http://objcer.com/2017/10/10/auto-size-dynamic-text-to-fill-fixed-size-canvas/</id>
    <published>2017-10-10T07:15:11.000Z</published>
    <updated>2017-10-10T07:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7vikhl.com1.z0.glb.clouddn.com/1-UGtq-cSfbuekV8aHalVIAw.png" alt=""><br>本文将探究动态文本如何自适应绘制到指定大小的 Canvas 🎏</p>
<a id="more"></a>
<h2 id="CanvasRenderingContext2D-fillText"><a href="#CanvasRenderingContext2D-fillText" class="headerlink" title="CanvasRenderingContext2D.fillText()"></a><code>CanvasRenderingContext2D.fillText()</code></h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ctx.fillText(<span class="built_in">text</span>, x, y [, maxWidth]);</div></pre></td></tr></table></figure>
<p>在 (x, y) 位置填充文本。如果第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度。如果绘制的文本实际宽度超过 <code>maxWidth</code>，那么会在水平方向上进行缩放，文字可能被压缩变形。<br><img src="http://7vikhl.com1.z0.glb.clouddn.com/fillText.png" alt=""></p>
<h2 id="限制宽度"><a href="#限制宽度" class="headerlink" title="限制宽度"></a>限制宽度</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.measureText(text)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>传入要绘制的文本内容，返回绘制到当前 Canvas 时文本的宽度。我们可以设置一个较大的字体，然后递减字体大小，直到绘制的文本宽度满足 Canvas 宽度限制，由此得到文本绘制到 Canvas 中合适的字体大小<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function dynamicFitTextOnCanvas (text, fontface, desiredWidth) &#123;</div><div class="line">  <span class="selector-tag">var</span> <span class="selector-tag">canvas</span> = document.createElement(<span class="string">'canvas'</span>)</div><div class="line">  <span class="selector-tag">var</span> context = <span class="selector-tag">canvas</span>.getContext(<span class="string">'2d'</span>)</div><div class="line">  <span class="comment">// start with a large font size</span></div><div class="line">  <span class="selector-tag">var</span> fontsize = <span class="number">500</span></div><div class="line">  do &#123;</div><div class="line">    context<span class="selector-class">.font</span> = `$&#123;fontsize&#125;px $&#123;fontface&#125;`</div><div class="line">    fontsize --</div><div class="line">  &#125; while (context.measureText(text)<span class="selector-class">.width</span> &gt; desiredWidth)</div><div class="line">  return fontsize</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然字体大小 fontsize 逐次递减一，效率不够好，我们可以通过二分递减来优化这个过程<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function dynamicFitTextOnCanvas (text, fontface, desiredWidth) &#123;</div><div class="line">  <span class="built_in">var</span> canvas = document.createElement('canvas')</div><div class="line">  <span class="built_in">var</span> <span class="built_in">context</span> = canvas.getContext('2d')</div><div class="line">  // start with a large <span class="built_in">font</span> size</div><div class="line">  <span class="built_in">var</span> fontsize = <span class="number">500</span></div><div class="line">  <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, <span class="number">0</span>, fontsize, fontface, desiredWidth)</div><div class="line">&#125;</div><div class="line">function measureTextBinary (<span class="built_in">context</span>, text, <span class="built_in">min</span>, <span class="built_in">max</span>, fontface, desiredWidth) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">max</span> - <span class="built_in">min</span> &lt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">return</span> Math.<span class="built_in">floor</span>(<span class="built_in">min</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">var</span> cur = <span class="built_in">min</span> + (<span class="built_in">max</span> - <span class="built_in">min</span>) / <span class="number">2</span></div><div class="line">  <span class="built_in">context</span>.<span class="built_in">font</span> = `$&#123;cur&#125;px $&#123;fontface&#125;`</div><div class="line">  <span class="built_in">var</span> measureWidth = <span class="built_in">context</span>.measureText(text).<span class="built_in">width</span></div><div class="line">  <span class="keyword">if</span> (measureWidth &gt; desiredWidth) &#123;</div><div class="line">      <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, <span class="built_in">min</span>, cur, fontface, desiredWidth)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">return</span> measureTextBinary(<span class="built_in">context</span>, text, cur, <span class="built_in">max</span>, fontface, desiredWidth)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="限制宽度和高度"><a href="#限制宽度和高度" class="headerlink" title="限制宽度和高度"></a>限制宽度和高度</h2><p>注意到 <code>measureText</code> 方法只能测量绘制文本的宽度，无法得到高度信息；我们可以往 document 中添加一个辅助的 <code>div</code> 节点，设置其 <code>innerText</code> 为要绘制的文本，再设置其字体大小，通过 <code>getBoundingClientRect</code> 方法或者 <code>offsetWidth/offsetHeight</code> 属性就可以得到绘制指定字体大小的文本宽高；同理，通过递减字体大小，使得绘制的文本宽高满足 Canvas 的宽高限制；由于有了前面的经验，我们也用二分递减提高执行效率</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicFitTextOnCanvas</span> (<span class="params">text, fontface, desiredWidth, desiredHeight</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tmpDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.tmp-div'</span>)</div><div class="line">  <span class="keyword">if</span> (!tmpDiv) &#123;</div><div class="line">    tmpDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">    tmpDiv.classList.add(<span class="string">'tmp-div'</span>)</div><div class="line">    tmpDiv.style[<span class="string">'position'</span>] = <span class="string">'absolute'</span></div><div class="line">    tmpDiv.style[<span class="string">'left'</span>] = <span class="string">'-100000px'</span></div><div class="line">    tmpDiv.style[<span class="string">'top'</span>] = <span class="string">'-100000px'</span></div><div class="line">    tmpDiv.style[<span class="string">'visibility'</span>] = <span class="string">'hidden'</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(tmpDiv)</div><div class="line">    tmpDiv.innerText = text</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// start with a large font size</span></div><div class="line">  <span class="keyword">var</span> fontsize = <span class="number">500</span></div><div class="line">  <span class="keyword">return</span> measureDivBinary(tmpDiv, <span class="number">0</span>, fontsize, fontface, desiredWidth, desiredHeight)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">measureDivBinary</span> (<span class="params">tmpDiv, min, max, fontface, desiredWidth, desiredHeight</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (max - min &lt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(min)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> cur = min + (max - min) / <span class="number">2</span></div><div class="line">  tmpDiv.style[<span class="string">'font'</span>] = <span class="string">`<span class="subst">$&#123;cur&#125;</span>px <span class="subst">$&#123;fontface&#125;</span>`</span></div><div class="line">  tmpDiv.style[<span class="string">'line-height'</span>] = <span class="string">`<span class="subst">$&#123;cur&#125;</span>px`</span></div><div class="line">  <span class="keyword">var</span> measureRect = tmpDiv.getBoundingClientRect()</div><div class="line">  <span class="keyword">if</span> (measureRect.width &gt; desiredWidth || measureRect.height &gt; desiredHeight) &#123;</div><div class="line">    <span class="keyword">return</span> measureDivBinary(tmpDiv, min, cur, fontface, desiredWidth, desiredHeight)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> measureDivBinary(tmpDiv, cur, max, fontface, desiredWidth, desiredHeight)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于-line-height"><a href="#关于-line-height" class="headerlink" title="关于 line-height"></a>关于 <code>line-height</code></h3><p><img src="http://7vikhl.com1.z0.glb.clouddn.com/2587037021-55bacfa692fb8.png" alt=""><br>通过上图来理解行高，行距</p>
<ul>
<li><strong>行高</strong> (line-height) 是指文本行基线间的垂直距离，上图中两条红线之间的距离就是行高</li>
<li>上一行的底线和下一行的顶线之间的距离就是<strong>行距</strong>，而同一行顶线和底线之间的距离是 font-size 的大小</li>
<li>行距的一半是半行距: 半行距 = (line-height - font-size) / 2，当 line-height &lt; font-size，半行距为负值，这时候两行之间就会重叠</li>
</ul>
<p>我们发现，font-size 大小即为文字绘制后的实际高度，所以在上面代码中，我们对辅助 <code>div</code> 节点也设置了 <code>line-height = font-size</code>，使得到的文字高度更加精确（去掉了两个半行距）</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>1️⃣ 最小字体大小限制<br>在 Chrome 浏览器中，设定 CSS <code>font-size</code> 小于 12px ，依然会以 12px 进行展示，也就是说 Chrome 浏览器允许设置的最小 <code>font-size</code> 为 12px（Safari 不存在这个问题）。所以如果限制绘制的 Canvas 的宽高小于辅助 <code>div</code> 节点设置 <code>font-size</code> 为 12px 的宽高，那么无法通过计算得到合适绘制的 <code>font-size</code></p>
<p><strong>为了解决这个问题：</strong>只能通过设置一个较大的 <code>font-size</code>，在 Canvas 上进行绘制，然后对这个 Canvas 缩小到限制的宽高</p>
<p>2️⃣ 高清屏绘制文字模糊<br>关于这个问题，解决方案参考：<a href="https://objcer.com/2017/10/10/High-DPI-Canvas-Render/">高清屏中 Canvas 的绘制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7vikhl.com1.z0.glb.clouddn.com/1-UGtq-cSfbuekV8aHalVIAw.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;本文将探究动态文本如何自适应绘制到指定大小的 Canvas 🎏&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://objcer.com/categories/JS/"/>
    
    
      <category term="Canvas" scheme="http://objcer.com/tags/Canvas/"/>
    
  </entry>
  
</feed>
